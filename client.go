// Package hq provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.1-0.20220609223533-7da811e1cf30 DO NOT EDIT.
package hq

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerTokenAuthScopes   = "BearerTokenAuth.Scopes"
	Email_PasswordScopes    = "Email_Password.Scopes"
	HQ_AuthenticatoinScopes = "HQ_Authenticatoin.Scopes"
	OAuth_2_0Scopes         = "oAuth_2_0.Scopes"
)

// Defines values for ActivityType.
const (
	ActivityTypeCustomer  ActivityType = "customer"
	ActivityTypeEvent     ActivityType = "event"
	ActivityTypeEventType ActivityType = "event_type"
	ActivityTypePayment   ActivityType = "payment"
)

// Defines values for ActorType.
const (
	ActorTypeHqUser          ActorType = "hq_user"
	ActorTypeMarketplaceUser ActorType = "marketplace_user"
	ActorTypeSecretary       ActorType = "secretary"
)

// Defines values for AdyenBankAccountType.
const (
	BankAccount AdyenBankAccountType = "bank_account"
)

// Defines values for AdyenOnboardingStatus.
const (
	AdyenOnboardingStatusInvalid    AdyenOnboardingStatus = "invalid"
	AdyenOnboardingStatusNotStarted AdyenOnboardingStatus = "not_started"
	AdyenOnboardingStatusPending    AdyenOnboardingStatus = "pending"
	AdyenOnboardingStatusRejected   AdyenOnboardingStatus = "rejected"
	AdyenOnboardingStatusValid      AdyenOnboardingStatus = "valid"
)

// Defines values for AvailabilityRuleType.
const (
	AvailabilityRuleTypeAvailability AvailabilityRuleType = "availability"
)

// Defines values for BillingCustomerBillingMethod.
const (
	BillingCustomerBillingMethodCard    BillingCustomerBillingMethod = "card"
	BillingCustomerBillingMethodInvoice BillingCustomerBillingMethod = "invoice"
)

// Defines values for BillingCustomerVatNumberStatus.
const (
	BillingCustomerVatNumberStatusInvalid      BillingCustomerVatNumberStatus = "invalid"
	BillingCustomerVatNumberStatusNotValidated BillingCustomerVatNumberStatus = "not_validated"
	BillingCustomerVatNumberStatusUndetermined BillingCustomerVatNumberStatus = "undetermined"
	BillingCustomerVatNumberStatusValid        BillingCustomerVatNumberStatus = "valid"
)

// Defines values for BillingInvoiceStatus.
const (
	BillingInvoiceStatusNotPaid    BillingInvoiceStatus = "not_paid"
	BillingInvoiceStatusPaid       BillingInvoiceStatus = "paid"
	BillingInvoiceStatusPaymentDue BillingInvoiceStatus = "payment_due"
	BillingInvoiceStatusPending    BillingInvoiceStatus = "pending"
	BillingInvoiceStatusPosted     BillingInvoiceStatus = "posted"
	BillingInvoiceStatusVoided     BillingInvoiceStatus = "voided"
)

// Defines values for BlockedTimeDeletionBehaviorType.
const (
	BlockedTimeDeletionBehaviorTypeFuture BlockedTimeDeletionBehaviorType = "future"
	BlockedTimeDeletionBehaviorTypeSingle BlockedTimeDeletionBehaviorType = "single"
)

// Defines values for BlockedTimeTheme.
const (
	Themeblack  BlockedTimeTheme = "themeblack"
	Themeblue   BlockedTimeTheme = "themeblue"
	Themecoral  BlockedTimeTheme = "themecoral"
	Themegreen  BlockedTimeTheme = "themegreen"
	Themegrey   BlockedTimeTheme = "themegrey"
	Thememint   BlockedTimeTheme = "thememint"
	Themeorange BlockedTimeTheme = "themeorange"
	Themepurple BlockedTimeTheme = "themepurple"
	Themered    BlockedTimeTheme = "themered"
	Themewine   BlockedTimeTheme = "themewine"
	Themeyellow BlockedTimeTheme = "themeyellow"
)

// Defines values for BlockedTimeUpdateBehaviorType.
const (
	BlockedTimeUpdateBehaviorTypeDetach BlockedTimeUpdateBehaviorType = "detach"
	BlockedTimeUpdateBehaviorTypeFuture BlockedTimeUpdateBehaviorType = "future"
)

// Defines values for BookingInterval.
const (
	N10  BookingInterval = 10
	N120 BookingInterval = 120
	N15  BookingInterval = 15
	N20  BookingInterval = 20
	N30  BookingInterval = 30
	N45  BookingInterval = 45
	N5   BookingInterval = 5
	N50  BookingInterval = 50
	N60  BookingInterval = 60
	N75  BookingInterval = 75
	N90  BookingInterval = 90
)

// Defines values for CallbackDataType.
const (
	CallbackDataTypeEventCreated CallbackDataType = "event.created"
	CallbackDataTypeEventDeleted CallbackDataType = "event.deleted"
	CallbackDataTypeEventUpdated CallbackDataType = "event.updated"
)

// Defines values for CardCardType.
const (
	CardCardTypeAmericanExpress CardCardType = "american_express"
	CardCardTypeBancontact      CardCardType = "bancontact"
	CardCardTypeDinersClub      CardCardType = "diners_club"
	CardCardTypeDiscover        CardCardType = "discover"
	CardCardTypeJcb             CardCardType = "jcb"
	CardCardTypeMastercard      CardCardType = "mastercard"
	CardCardTypeNotApplicable   CardCardType = "not_applicable"
	CardCardTypeOther           CardCardType = "other"
	CardCardTypeVisa            CardCardType = "visa"
)

// Defines values for CardStatus.
const (
	CardStatusExpired  CardStatus = "expired"
	CardStatusExpiring CardStatus = "expiring"
	CardStatusValid    CardStatus = "valid"
)

// Defines values for CheckoutBehaviorType.
const (
	CheckoutBehaviorTypeCheckout CheckoutBehaviorType = "checkout"
	CheckoutBehaviorTypeNoshow   CheckoutBehaviorType = "noshow"
)

// Defines values for ClaimStatus.
const (
	ClaimStatusCancelled           ClaimStatus = "Cancelled"
	ClaimStatusCompletedWithErrors ClaimStatus = "CompletedWithErrors"
	ClaimStatusInProgress          ClaimStatus = "InProgress"
	ClaimStatusLegalCollection     ClaimStatus = "LegalCollection"
	ClaimStatusPaid                ClaimStatus = "Paid"
	ClaimStatusSecondaryCollection ClaimStatus = "SecondaryCollection"
	ClaimStatusUnpaid              ClaimStatus = "Unpaid"
)

// Defines values for CommissionRatesType.
const (
	Rates CommissionRatesType = "rates"
)

// Defines values for CompanyVertical.
const (
	Appointment CompanyVertical = "appointment"
	Restaurant  CompanyVertical = "restaurant"
)

// Defines values for CustomPropertyScope.
const (
	CustomPropertyScopeCustomer CustomPropertyScope = "customer"
	CustomPropertyScopeEvents   CustomPropertyScope = "events"
)

// Defines values for CustomPropertyType.
const (
	CustomPropertyTypeInput    CustomPropertyType = "input"
	CustomPropertyTypeOptions  CustomPropertyType = "options"
	CustomPropertyTypeSelect   CustomPropertyType = "select"
	CustomPropertyTypeTextarea CustomPropertyType = "textarea"
)

// Defines values for CustomerActivityField.
const (
	Email            CustomerActivityField = "email"
	Kennitala        CustomerActivityField = "kennitala"
	LicensePlate     CustomerActivityField = "license_plate"
	Name             CustomerActivityField = "name"
	Notes            CustomerActivityField = "notes"
	PhoneCountryCode CustomerActivityField = "phone_country_code"
	PhoneNumber      CustomerActivityField = "phone_number"
)

// Defines values for CustomerActivityType.
const (
	CustomerActivityTypeCustomer  CustomerActivityType = "customer"
	CustomerActivityTypeEvent     CustomerActivityType = "event"
	CustomerActivityTypeEventType CustomerActivityType = "event_type"
	CustomerActivityTypePayment   CustomerActivityType = "payment"
)

// Defines values for DuplicateStatus.
const (
	Approved DuplicateStatus = "approved"
	Possible DuplicateStatus = "possible"
)

// Defines values for EmployeeField.
const (
	DisabledAt EmployeeField = "disabled_at"
)

// Defines values for EventInvoiceStatus.
const (
	EventInvoiceStatusCanceledDuringDraft EventInvoiceStatus = "canceledDuringDraft"
	EventInvoiceStatusDeleted             EventInvoiceStatus = "deleted"
	EventInvoiceStatusDraft               EventInvoiceStatus = "draft"
	EventInvoiceStatusPaid                EventInvoiceStatus = "paid"
	EventInvoiceStatusRefund              EventInvoiceStatus = "refund"
)

// Defines values for EventOrigin.
const (
	EventOriginApp       EventOrigin = "app"
	EventOriginCalendar  EventOrigin = "calendar"
	EventOriginImport    EventOrigin = "import"
	EventOriginOnline    EventOrigin = "online"
	EventOriginSecretary EventOrigin = "secretary"
)

// Defines values for EventUpdateOrigin.
const (
	EventUpdateOriginApp       EventUpdateOrigin = "app"
	EventUpdateOriginCalendar  EventUpdateOrigin = "calendar"
	EventUpdateOriginImport    EventUpdateOrigin = "import"
	EventUpdateOriginOnline    EventUpdateOrigin = "online"
	EventUpdateOriginSecretary EventUpdateOrigin = "secretary"
)

// Defines values for EventActivityField.
const (
	EventActivityFieldDuration    EventActivityField = "duration"
	EventActivityFieldEmployee    EventActivityField = "employee"
	EventActivityFieldEventTypes  EventActivityField = "event_types"
	EventActivityFieldSpace       EventActivityField = "space"
	EventActivityFieldStartsAt    EventActivityField = "starts_at"
	EventActivityFieldStatus      EventActivityField = "status"
	EventActivityFieldUnconfirmed EventActivityField = "unconfirmed"
)

// Defines values for EventActivityType.
const (
	EventActivityTypeCustomer  EventActivityType = "customer"
	EventActivityTypeEvent     EventActivityType = "event"
	EventActivityTypeEventType EventActivityType = "event_type"
	EventActivityTypePayment   EventActivityType = "payment"
)

// Defines values for EventCheckinResultInvoiceStatus.
const (
	EventCheckinResultInvoiceStatusCanceledDuringDraft EventCheckinResultInvoiceStatus = "canceledDuringDraft"
	EventCheckinResultInvoiceStatusDeleted             EventCheckinResultInvoiceStatus = "deleted"
	EventCheckinResultInvoiceStatusDraft               EventCheckinResultInvoiceStatus = "draft"
	EventCheckinResultInvoiceStatusPaid                EventCheckinResultInvoiceStatus = "paid"
	EventCheckinResultInvoiceStatusRefund              EventCheckinResultInvoiceStatus = "refund"
)

// Defines values for EventCheckinResultOrigin.
const (
	EventCheckinResultOriginApp       EventCheckinResultOrigin = "app"
	EventCheckinResultOriginCalendar  EventCheckinResultOrigin = "calendar"
	EventCheckinResultOriginImport    EventCheckinResultOrigin = "import"
	EventCheckinResultOriginOnline    EventCheckinResultOrigin = "online"
	EventCheckinResultOriginSecretary EventCheckinResultOrigin = "secretary"
)

// Defines values for EventCheckinResultUpdateOrigin.
const (
	EventCheckinResultUpdateOriginApp       EventCheckinResultUpdateOrigin = "app"
	EventCheckinResultUpdateOriginCalendar  EventCheckinResultUpdateOrigin = "calendar"
	EventCheckinResultUpdateOriginImport    EventCheckinResultUpdateOrigin = "import"
	EventCheckinResultUpdateOriginOnline    EventCheckinResultUpdateOrigin = "online"
	EventCheckinResultUpdateOriginSecretary EventCheckinResultUpdateOrigin = "secretary"
)

// Defines values for EventDeletionBehaviorType.
const (
	EventDeletionBehaviorTypeFuture EventDeletionBehaviorType = "future"
	EventDeletionBehaviorTypeSingle EventDeletionBehaviorType = "single"
)

// Defines values for EventTypeOverbookable.
const (
	FullyOverbookable     EventTypeOverbookable = "fully_overbookable"
	NotOverbookable       EventTypeOverbookable = "not_overbookable"
	PartiallyOverbookable EventTypeOverbookable = "partially_overbookable"
)

// Defines values for EventTypeActivityField.
const (
	EventTypeActivityFieldAfterPause         EventTypeActivityField = "after_pause"
	EventTypeActivityFieldBeforePause        EventTypeActivityField = "before_pause"
	EventTypeActivityFieldBufferAfterService EventTypeActivityField = "buffer_after_service"
	EventTypeActivityFieldDuration           EventTypeActivityField = "duration"
	EventTypeActivityFieldPause              EventTypeActivityField = "pause"
	EventTypeActivityFieldTitle              EventTypeActivityField = "title"
)

// Defines values for EventTypeActivityType.
const (
	EventTypeActivityTypeCustomer  EventTypeActivityType = "customer"
	EventTypeActivityTypeEvent     EventTypeActivityType = "event"
	EventTypeActivityTypeEventType EventTypeActivityType = "event_type"
	EventTypeActivityTypePayment   EventTypeActivityType = "payment"
)

// Defines values for EventTypeConnectionsCustomerSelects.
const (
	EventTypeConnectionsCustomerSelectsBoth     EventTypeConnectionsCustomerSelects = "both"
	EventTypeConnectionsCustomerSelectsEmployee EventTypeConnectionsCustomerSelects = "employee"
	EventTypeConnectionsCustomerSelectsNeither  EventTypeConnectionsCustomerSelects = "neither"
	EventTypeConnectionsCustomerSelectsSpace    EventTypeConnectionsCustomerSelects = "space"
)

// Defines values for EventTypeConnectionsServiceNeeds.
const (
	EventTypeConnectionsServiceNeedsBoth     EventTypeConnectionsServiceNeeds = "both"
	EventTypeConnectionsServiceNeedsEmployee EventTypeConnectionsServiceNeeds = "employee"
	EventTypeConnectionsServiceNeedsNeither  EventTypeConnectionsServiceNeeds = "neither"
	EventTypeConnectionsServiceNeedsSpace    EventTypeConnectionsServiceNeeds = "space"
)

// Defines values for EventTypeField.
const (
	EventTypeFieldBufferAfterService EventTypeField = "buffer_after_service"
	EventTypeFieldPayments           EventTypeField = "payments"
)

// Defines values for EventUpdateBehaviorType.
const (
	EventUpdateBehaviorTypeDetach  EventUpdateBehaviorType = "detach"
	EventUpdateBehaviorTypeFuture  EventUpdateBehaviorType = "future"
	EventUpdateBehaviorTypeInplace EventUpdateBehaviorType = "inplace"
)

// Defines values for FiscalizationProviderSaltPay.
const (
	SaltPay FiscalizationProviderSaltPay = "SaltPay"
)

// Defines values for FiscalizeTransactionErrorCode.
const (
	CustomerOnboardingError      FiscalizeTransactionErrorCode = "customer_onboarding_error"
	TaxExemptionCodeMissingError FiscalizeTransactionErrorCode = "tax_exemption_code_missing_error"
)

// Defines values for InvoicesFilterStatus.
const (
	InvoicesFilterStatusNotPaid    InvoicesFilterStatus = "not_paid"
	InvoicesFilterStatusPaid       InvoicesFilterStatus = "paid"
	InvoicesFilterStatusPaymentDue InvoicesFilterStatus = "payment_due"
	InvoicesFilterStatusPending    InvoicesFilterStatus = "pending"
	InvoicesFilterStatusPosted     InvoicesFilterStatus = "posted"
	InvoicesFilterStatusVoided     InvoicesFilterStatus = "voided"
)

// Defines values for IssuerType.
const (
	IssuerTypeCompany  IssuerType = "company"
	IssuerTypeEmployee IssuerType = "employee"
)

// Defines values for LineItemVoucherDataAmountType.
const (
	LineItemVoucherDataAmountTypeAmount LineItemVoucherDataAmountType = "amount"
)

// Defines values for LineItemVoucherDataServiceType.
const (
	LineItemVoucherDataServiceTypeService LineItemVoucherDataServiceType = "service"
)

// Defines values for MaxTotalPaxRuleType.
const (
	MaxTotalPax MaxTotalPaxRuleType = "max_total_pax"
)

// Defines values for NoticeVariant.
const (
	NoticeVariantError   NoticeVariant = "error"
	NoticeVariantInfo    NoticeVariant = "info"
	NoticeVariantSuccess NoticeVariant = "success"
	NoticeVariantWarning NoticeVariant = "warning"
)

// Defines values for NotificationEventStatus.
const (
	NotificationEventStatusCancelled   NotificationEventStatus = "cancelled"
	NotificationEventStatusConfirmed   NotificationEventStatus = "confirmed"
	NotificationEventStatusRequest     NotificationEventStatus = "request"
	NotificationEventStatusRescheduled NotificationEventStatus = "rescheduled"
)

// Defines values for NotificationEventType.
const (
	NotificationEventTypeEvent NotificationEventType = "event"
)

// Defines values for NotificationGenericType.
const (
	Generic NotificationGenericType = "generic"
)

// Defines values for NotificationIconIconVariant.
const (
	NotificationIconIconVariantError   NotificationIconIconVariant = "error"
	NotificationIconIconVariantInfo    NotificationIconIconVariant = "info"
	NotificationIconIconVariantSuccess NotificationIconIconVariant = "success"
	NotificationIconIconVariantWarning NotificationIconIconVariant = "warning"
)

// Defines values for NotificationLegacyType.
const (
	Legacy NotificationLegacyType = "legacy"
)

// Defines values for NotificationSurveyType.
const (
	Survey NotificationSurveyType = "survey"
)

// Defines values for NotificationWaitlistEntryType.
const (
	NotificationWaitlistEntryTypeWaitlistEntry NotificationWaitlistEntryType = "waitlistEntry"
)

// Defines values for OAuthConsentResponseType.
const (
	Code OAuthConsentResponseType = "code"
)

// Defines values for OAuthScope.
const (
	ActivitiesRead        OAuthScope = "activities:read"
	BlockedTimesRead      OAuthScope = "blocked_times:read"
	BlockedTimesWrite     OAuthScope = "blocked_times:write"
	ClaimsRead            OAuthScope = "claims:read"
	CompaniesRead         OAuthScope = "companies:read"
	CustomerGroupsRead    OAuthScope = "customer_groups:read"
	CustomerGroupsWrite   OAuthScope = "customer_groups:write"
	CustomersRead         OAuthScope = "customers:read"
	CustomersWrite        OAuthScope = "customers:write"
	EmployeesRead         OAuthScope = "employees:read"
	EmployeesWrite        OAuthScope = "employees:write"
	EventStatusesRead     OAuthScope = "event_statuses:read"
	EventStatusesWrite    OAuthScope = "event_statuses:write"
	EventTypeGroupsRead   OAuthScope = "event_type_groups:read"
	EventTypesRead        OAuthScope = "event_types:read"
	EventTypesWrite       OAuthScope = "event_types:write"
	EventsRead            OAuthScope = "events:read"
	EventsWrite           OAuthScope = "events:write"
	IssuersRead           OAuthScope = "issuers:read"
	MemosRead             OAuthScope = "memos:read"
	MemosWrite            OAuthScope = "memos:write"
	MetricsRead           OAuthScope = "metrics:read"
	NotificationsRead     OAuthScope = "notifications:read"
	NotificationsWrite    OAuthScope = "notifications:write"
	PaymentMethodsRead    OAuthScope = "payment_methods:read"
	PaymentsRead          OAuthScope = "payments:read"
	PaymentsWrite         OAuthScope = "payments:write"
	ProductGroupsRead     OAuthScope = "product_groups:read"
	ProductGroupsWrite    OAuthScope = "product_groups:write"
	ProductsRead          OAuthScope = "products:read"
	ProductsWrite         OAuthScope = "products:write"
	PropertiesRead        OAuthScope = "properties:read"
	PropertiesWrite       OAuthScope = "properties:write"
	ResourcesRead         OAuthScope = "resources:read"
	ResourcesWrite        OAuthScope = "resources:write"
	RuleSetTemplatesRead  OAuthScope = "rule_set_templates:read"
	RuleSetTemplatesWrite OAuthScope = "rule_set_templates:write"
	RuleSetsRead          OAuthScope = "rule_sets:read"
	RuleSetsWrite         OAuthScope = "rule_sets:write"
	SalesRead             OAuthScope = "sales:read"
	SalesWrite            OAuthScope = "sales:write"
	SettlementsRead       OAuthScope = "settlements:read"
	SmsMessagesRead       OAuthScope = "sms_messages:read"
	TerminalsRead         OAuthScope = "terminals:read"
	TerminalsWrite        OAuthScope = "terminals:write"
	TimeSlotsRead         OAuthScope = "time_slots:read"
	UserRead              OAuthScope = "user:read"
	VoucherTemplatesRead  OAuthScope = "voucher_templates:read"
	VoucherTemplatesWrite OAuthScope = "voucher_templates:write"
	VouchersRead          OAuthScope = "vouchers:read"
	VouchersWrite         OAuthScope = "vouchers:write"
	WaitlistsRead         OAuthScope = "waitlists:read"
	WaitlistsWrite        OAuthScope = "waitlists:write"
)

// Defines values for OAuthTokenRequestGrantType.
const (
	AuthorizationCode OAuthTokenRequestGrantType = "authorization_code"
	RefreshToken      OAuthTokenRequestGrantType = "refresh_token"
)

// Defines values for OnlineBookingsRuleEmployeesAssociation.
const (
	OnlineBookingsRuleEmployeesAssociationExcludes OnlineBookingsRuleEmployeesAssociation = "excludes"
	OnlineBookingsRuleEmployeesAssociationIncludes OnlineBookingsRuleEmployeesAssociation = "includes"
)

// Defines values for OnlineBookingsRuleEventTypesAssociation.
const (
	OnlineBookingsRuleEventTypesAssociationExcludes OnlineBookingsRuleEventTypesAssociation = "excludes"
	OnlineBookingsRuleEventTypesAssociationIncludes OnlineBookingsRuleEventTypesAssociation = "includes"
)

// Defines values for OnlineBookingsRuleResourcesAssociation.
const (
	OnlineBookingsRuleResourcesAssociationExcludes OnlineBookingsRuleResourcesAssociation = "excludes"
	OnlineBookingsRuleResourcesAssociationIncludes OnlineBookingsRuleResourcesAssociation = "includes"
)

// Defines values for OnlineBookingsRuleType.
const (
	OnlineBookings OnlineBookingsRuleType = "online_bookings"
)

// Defines values for POSSettingsCheckoutFirstTab.
const (
	POSSettingsCheckoutFirstTabProducts POSSettingsCheckoutFirstTab = "products"
	POSSettingsCheckoutFirstTabServices POSSettingsCheckoutFirstTab = "services"
)

// Defines values for PaymentReason.
const (
	PaymentReasonEvent   PaymentReason = "event"
	PaymentReasonPaylink PaymentReason = "paylink"
	PaymentReasonVoucher PaymentReason = "voucher"
)

// Defines values for PaymentActivityField.
const (
	Status PaymentActivityField = "status"
)

// Defines values for PaymentActivityType.
const (
	PaymentActivityTypeCustomer  PaymentActivityType = "customer"
	PaymentActivityTypeEvent     PaymentActivityType = "event"
	PaymentActivityTypeEventType PaymentActivityType = "event_type"
	PaymentActivityTypePayment   PaymentActivityType = "payment"
)

// Defines values for PaymentIntentStatus.
const (
	PaymentIntentStatusAuthorized PaymentIntentStatus = "authorized"
	PaymentIntentStatusConsumed   PaymentIntentStatus = "consumed"
	PaymentIntentStatusExpired    PaymentIntentStatus = "expired"
	PaymentIntentStatusInProgress PaymentIntentStatus = "in_progress"
	PaymentIntentStatusInited     PaymentIntentStatus = "inited"
)

// Defines values for PaymentStatus.
const (
	PaymentStatusPending   PaymentStatus = "pending"
	PaymentStatusRefunded  PaymentStatus = "refunded"
	PaymentStatusSettled   PaymentStatus = "settled"
	PaymentStatusUnsettled PaymentStatus = "unsettled"
)

// Defines values for PowerupPostBodyProduct.
const (
	PowerupPostBodyProductAppointmentsPro PowerupPostBodyProduct = "appointments_pro"
	PowerupPostBodyProductPos             PowerupPostBodyProduct = "pos"
)

// Defines values for PowerupSubscriptionCancelReason.
const (
	CurrencyIncompatibleWithGateway PowerupSubscriptionCancelReason = "currency_incompatible_with_gateway"
	FraudReviewFailed               PowerupSubscriptionCancelReason = "fraud_review_failed"
	NoCard                          PowerupSubscriptionCancelReason = "no_card"
	NonCompliantCustomer            PowerupSubscriptionCancelReason = "non_compliant_customer"
	NonCompliantEuCustomer          PowerupSubscriptionCancelReason = "non_compliant_eu_customer"
	NotPaid                         PowerupSubscriptionCancelReason = "not_paid"
	TaxCalculationFailed            PowerupSubscriptionCancelReason = "tax_calculation_failed"
)

// Defines values for PowerupSubscriptionStatus.
const (
	PowerupSubscriptionStatusActive      PowerupSubscriptionStatus = "active"
	PowerupSubscriptionStatusCancelled   PowerupSubscriptionStatus = "cancelled"
	PowerupSubscriptionStatusFuture      PowerupSubscriptionStatus = "future"
	PowerupSubscriptionStatusInTrial     PowerupSubscriptionStatus = "in_trial"
	PowerupSubscriptionStatusNonRenewing PowerupSubscriptionStatus = "non_renewing"
	PowerupSubscriptionStatusPaused      PowerupSubscriptionStatus = "paused"
)

// Defines values for RefundMarketplaceSaleErrorCode.
const (
	AlreadyRefunded       RefundMarketplaceSaleErrorCode = "already_refunded"
	PaymentHasBeenSettled RefundMarketplaceSaleErrorCode = "payment_has_been_settled"
	SaleHasBeenMutated    RefundMarketplaceSaleErrorCode = "sale_has_been_mutated"
)

// Defines values for ResourceType.
const (
	ResourceTypeSpace            ResourceType = "space"
	ResourceTypeTable            ResourceType = "table"
	ResourceTypeTableCombination ResourceType = "table_combination"
)

// Defines values for RoleType.
const (
	RoleTypeDefault RoleType = "default"
	RoleTypeOther   RoleType = "other"
	RoleTypeRoot    RoleType = "root"
)

// Defines values for RuleEntitiesEmployeesEmployeesAssociation.
const (
	RuleEntitiesEmployeesEmployeesAssociationExcludes RuleEntitiesEmployeesEmployeesAssociation = "excludes"
	RuleEntitiesEmployeesEmployeesAssociationIncludes RuleEntitiesEmployeesEmployeesAssociation = "includes"
)

// Defines values for RuleEntitiesEventTypesEventTypesAssociation.
const (
	RuleEntitiesEventTypesEventTypesAssociationExcludes RuleEntitiesEventTypesEventTypesAssociation = "excludes"
	RuleEntitiesEventTypesEventTypesAssociationIncludes RuleEntitiesEventTypesEventTypesAssociation = "includes"
)

// Defines values for RuleEntitiesResourcesResourcesAssociation.
const (
	RuleEntitiesResourcesResourcesAssociationExcludes RuleEntitiesResourcesResourcesAssociation = "excludes"
	RuleEntitiesResourcesResourcesAssociationIncludes RuleEntitiesResourcesResourcesAssociation = "includes"
)

// Defines values for RuleType.
const (
	RuleTypeAvailability   RuleType = "availability"
	RuleTypeMaxTotalPax    RuleType = "max_total_pax"
	RuleTypeOnlineBookings RuleType = "online_bookings"
)

// Defines values for SMSMessageStatus.
const (
	SMSMessageStatusCreated     SMSMessageStatus = "created"
	SMSMessageStatusDelivered   SMSMessageStatus = "delivered"
	SMSMessageStatusFailed      SMSMessageStatus = "failed"
	SMSMessageStatusProcessing  SMSMessageStatus = "processing"
	SMSMessageStatusUndelivered SMSMessageStatus = "undelivered"
)

// Defines values for SMSMessageType.
const (
	SMSMessageTypeBookingConfirmation SMSMessageType = "booking_confirmation"
	SMSMessageTypeBookingReminder     SMSMessageType = "booking_reminder"
	SMSMessageTypeExtra               SMSMessageType = "extra"
	SMSMessageTypeLoginCode           SMSMessageType = "login_code"
	SMSMessageTypeMarketing           SMSMessageType = "marketing"
	SMSMessageTypeNoShowClaimCreated  SMSMessageType = "no_show_claim_created"
	SMSMessageTypePhoneVerification   SMSMessageType = "phone_verification"
	SMSMessageTypeTest                SMSMessageType = "test"
	SMSMessageTypeVoucher             SMSMessageType = "voucher"
)

// Defines values for SortOrder.
const (
	Asc  SortOrder = "asc"
	Desc SortOrder = "desc"
)

// Defines values for SpaceType.
const (
	SpaceTypeSpace            SpaceType = "space"
	SpaceTypeTable            SpaceType = "table"
	SpaceTypeTableCombination SpaceType = "table_combination"
)

// Defines values for SubscriptionDiscountApplyOn.
const (
	InvoiceAmount     SubscriptionDiscountApplyOn = "invoice_amount"
	SpecificItemPrice SubscriptionDiscountApplyOn = "specific_item_price"
)

// Defines values for SubscriptionDiscountDurationType.
const (
	Forever       SubscriptionDiscountDurationType = "forever"
	LimitedPeriod SubscriptionDiscountDurationType = "limited_period"
	OneTime       SubscriptionDiscountDurationType = "one_time"
)

// Defines values for SubscriptionDiscountPeriodUnit.
const (
	Day   SubscriptionDiscountPeriodUnit = "day"
	Month SubscriptionDiscountPeriodUnit = "month"
	Week  SubscriptionDiscountPeriodUnit = "week"
	Year  SubscriptionDiscountPeriodUnit = "year"
)

// Defines values for SubscriptionItemItemType.
const (
	Addon  SubscriptionItemItemType = "addon"
	Charge SubscriptionItemItemType = "charge"
	Plan   SubscriptionItemItemType = "plan"
)

// Defines values for SubtransactionFailureState.
const (
	Busy      SubtransactionFailureState = "busy"
	Cancelled SubtransactionFailureState = "cancelled"
	Declined  SubtransactionFailureState = "declined"
	Unknown   SubtransactionFailureState = "unknown"
)

// Defines values for SubtransactionOrigin.
const (
	SubtransactionOriginCheckin     SubtransactionOrigin = "checkin"
	SubtransactionOriginMarketplace SubtransactionOrigin = "marketplace"
	SubtransactionOriginPos         SubtransactionOrigin = "pos"
)

// Defines values for SubtransactionState.
const (
	SubtransactionStateFailed      SubtransactionState = "failed"
	SubtransactionStatePending     SubtransactionState = "pending"
	SubtransactionStateSuccessful  SubtransactionState = "successful"
	SubtransactionStateUnprocessed SubtransactionState = "unprocessed"
)

// Defines values for SubtransactionCreationBehaviorType.
const (
	Single SubtransactionCreationBehaviorType = "single"
	Split  SubtransactionCreationBehaviorType = "split"
)

// Defines values for SubtransactionDataPaylinkChannel.
const (
	SubtransactionDataPaylinkChannelApp SubtransactionDataPaylinkChannel = "app"
	SubtransactionDataPaylinkChannelSms SubtransactionDataPaylinkChannel = "sms"
)

// Defines values for SubtransactionDataPaylinkType.
const (
	Paylink SubtransactionDataPaylinkType = "paylink"
)

// Defines values for SubtransactionDataPrePaymentType.
const (
	PrePayment SubtransactionDataPrePaymentType = "pre_payment"
)

// Defines values for SubtransactionDataTerminalType.
const (
	SubtransactionDataTerminalTypeTerminal SubtransactionDataTerminalType = "terminal"
)

// Defines values for SubtransactionDataVoucherType.
const (
	SubtransactionDataVoucherTypeVoucher SubtransactionDataVoucherType = "voucher"
)

// Defines values for TerminalProvider.
const (
	Istari TerminalProvider = "Istari"
	MPAS   TerminalProvider = "MPAS"
)

// Defines values for TransactionOrigin.
const (
	Marketplace TransactionOrigin = "marketplace"
	Pos         TransactionOrigin = "pos"
)

// Defines values for TransactionStatus.
const (
	Completed TransactionStatus = "completed"
	Draft     TransactionStatus = "draft"
)

// Defines values for TransactionType.
const (
	TransactionTypeInvoice  TransactionType = "invoice"
	TransactionTypeRefund   TransactionType = "refund"
	TransactionTypeRefunded TransactionType = "refunded"
	TransactionTypeReturn   TransactionType = "return"
)

// Defines values for TransactionCreationBehaviorRefund.
const (
	FullRefund    TransactionCreationBehaviorRefund = "full_refund"
	PartialRefund TransactionCreationBehaviorRefund = "partial_refund"
)

// Defines values for VoucherStatus.
const (
	VoucherStatusExpired    VoucherStatus = "expired"
	VoucherStatusFullyUsed  VoucherStatus = "fully_used"
	VoucherStatusNeverUsed  VoucherStatus = "never_used"
	VoucherStatusPartlyUsed VoucherStatus = "partly_used"
)

// Defines values for VoucherDataAmountType.
const (
	VoucherDataAmountTypeAmount VoucherDataAmountType = "amount"
)

// Defines values for VoucherDataServiceType.
const (
	VoucherDataServiceTypeService VoucherDataServiceType = "service"
)

// Defines values for VoucherField.
const (
	VoucherFieldCustomer VoucherField = "customer"
)

// Defines values for VoucherFilterStatus.
const (
	VoucherFilterStatusExpired    VoucherFilterStatus = "expired"
	VoucherFilterStatusFullyUsed  VoucherFilterStatus = "fully_used"
	VoucherFilterStatusNeverUsed  VoucherFilterStatus = "never_used"
	VoucherFilterStatusPartlyUsed VoucherFilterStatus = "partly_used"
)

// Defines values for VoucherFilterType.
const (
	Amount  VoucherFilterType = "amount"
	Service VoucherFilterType = "service"
)

// Defines values for WaitlistEntryField.
const (
	WaitlistEntryFieldEmployee WaitlistEntryField = "employee"
)

// Defines values for WebhookEvent.
const (
	WebhookEventCustomerCreated    WebhookEvent = "customer.created"
	WebhookEventCustomerUpdated    WebhookEvent = "customer.updated"
	WebhookEventEventCreated       WebhookEvent = "event.created"
	WebhookEventEventDeleted       WebhookEvent = "event.deleted"
	WebhookEventEventUpdated       WebhookEvent = "event.updated"
	WebhookEventTransactionCreated WebhookEvent = "transaction.created"
	WebhookEventTransactionUpdated WebhookEvent = "transaction.updated"
)

// Defines values for GetPricingByCountryCodeParamsProduct.
const (
	GetPricingByCountryCodeParamsProductBaseFee          GetPricingByCountryCodeParamsProduct = "base_fee"
	GetPricingByCountryCodeParamsProductCheckin          GetPricingByCountryCodeParamsProduct = "checkin"
	GetPricingByCountryCodeParamsProductMarketplace      GetPricingByCountryCodeParamsProduct = "marketplace"
	GetPricingByCountryCodeParamsProductNoshow           GetPricingByCountryCodeParamsProduct = "noshow"
	GetPricingByCountryCodeParamsProductPos              GetPricingByCountryCodeParamsProduct = "pos"
	GetPricingByCountryCodeParamsProductSmsAnnouncements GetPricingByCountryCodeParamsProduct = "sms_announcements"
	GetPricingByCountryCodeParamsProductSmsCustom        GetPricingByCountryCodeParamsProduct = "sms_custom"
	GetPricingByCountryCodeParamsProductSmsReminders     GetPricingByCountryCodeParamsProduct = "sms_reminders"
	GetPricingByCountryCodeParamsProductSpaces           GetPricingByCountryCodeParamsProduct = "spaces"
	GetPricingByCountryCodeParamsProductUsers            GetPricingByCountryCodeParamsProduct = "users"
)

// Defines values for UserOAuthParamsProvider.
const (
	Google  UserOAuthParamsProvider = "google"
	Saltpay UserOAuthParamsProvider = "saltpay"
)

// Activities defines model for Activities.
type Activities []Activity

// Activity defines model for Activity.
type Activity struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor `json:"created_by,omitempty"`
	Id        *string          `json:"id,omitempty"`
	NewValue  *MultiValue      `json:"new_value,omitempty"`
	OldValue  *MultiValue      `json:"old_value,omitempty"`
	Type      *ActivityType    `json:"type,omitempty"`
}

// ActivityType defines model for Activity.Type.
type ActivityType string

// The actor that performed the activity. This can be a HQ user or a Marketplace user.
type Actor struct {
	Id    *string   `json:"id,omitempty"`
	Image *Image    `json:"image,omitempty"`
	Name  *string   `json:"name,omitempty"`
	Type  ActorType `json:"type"`
}

// ActorType defines model for Actor.Type.
type ActorType string

// Actors defines model for Actors.
type Actors []Actor

// AdyenBankAccount defines model for AdyenBankAccount.
type AdyenBankAccount struct {
	// The IBAN of the bank account.
	Iban string               `json:"iban"`
	Type AdyenBankAccountType `json:"type"`
}

// AdyenBankAccountType defines model for AdyenBankAccount.Type.
type AdyenBankAccountType string

// AdyenConnection defines model for AdyenConnection.
type AdyenConnection struct {
	OnboardedAt      *time.Time             `json:"onboarded_at,omitempty"`
	OnboardingStatus *AdyenOnboardingStatus `json:"onboarding_status,omitempty"`
}

// AdyenOnboardingInfo defines model for AdyenOnboardingInfo.
type AdyenOnboardingInfo struct {
	ErrorCodes  *[]string  `json:"error_codes,omitempty"`
	OnboardedAt *time.Time `json:"onboarded_at,omitempty"`

	// The URL to Adyen's hosted onboarding flow.
	OnboardingLink     *string                  `json:"onboarding_link,omitempty"`
	OnboardingStatus   *AdyenOnboardingStatus   `json:"onboarding_status,omitempty"`
	TransferInstrument *AdyenTransferInstrument `json:"transfer_instrument,omitempty"`
}

// AdyenOnboardingRequest defines model for AdyenOnboardingRequest.
type AdyenOnboardingRequest struct {
	// The URL that Adyen should redirect to after the onboarding process is complete.
	RedirectUrl string `json:"redirect_url"`
}

// AdyenOnboardingStatus defines model for AdyenOnboardingStatus.
type AdyenOnboardingStatus string

// AdyenTransferInstrument defines model for AdyenTransferInstrument.
type AdyenTransferInstrument struct {
	union json.RawMessage
}

// AllPricing defines model for AllPricing.
type AllPricing []Pricing

// Change in amount from previous period in percent (75 = 75%)
type AmountChangeMetric struct {
	Average *float64 `json:"average,omitempty"`
	Count   *float64 `json:"count,omitempty"`
	Total   *float64 `json:"total,omitempty"`
}

// AmountMetric defines model for AmountMetric.
type AmountMetric struct {
	Average  *float64 `json:"average,omitempty"`
	Count    *int32   `json:"count,omitempty"`
	Currency *string  `json:"currency,omitempty"`
	Total    *float64 `json:"total,omitempty"`
}

// AmountMetricsByDay defines model for AmountMetricsByDay.
type AmountMetricsByDay struct {
	// Change in amount from previous period in percent (75 = 75%)
	PercentChange   *AmountChangeMetric `json:"percent_change,omitempty"`
	SameDayLastWeek *AmountMetric       `json:"same_day_last_week,omitempty"`
	Today           *AmountMetric       `json:"today,omitempty"`
}

// App defines model for App.
type App struct {
	ClientId      *string `json:"client_id,omitempty"`
	Description   *string `json:"description,omitempty"`
	DeveloperName *string `json:"developer_name,omitempty"`

	// Home page or documentation for your application.
	DeveloperUrl *string `json:"developer_url,omitempty"`

	// Whether the app is enabled for the company.
	Enabled *bool   `json:"enabled,omitempty"`
	Id      *string `json:"id,omitempty"`

	// The ID token for the app. Only generated for installed apps.
	//
	// The token is sent via a query parameter to the redirect_uri when the user opens an already installed app.
	IdToken *string `json:"id_token,omitempty"`
	Logo    *string `json:"logo,omitempty"`

	// Shown to the user when they are asked to give consent.
	Name *string `json:"name,omitempty"`

	// The URL to open the app.
	OpenUri     *string      `json:"open_uri,omitempty"`
	RedirectUri *string      `json:"redirect_uri,omitempty"`
	Scopes      *OAuthScopes `json:"scopes,omitempty"`

	// If `true`, the application will appear in the navigation within Noona HQ.
	//
	// When clicked, the application's open_uri will be displayed in an iFrame.
	ShowInNavigation *bool `json:"show_in_navigation,omitempty"`

	// The URL to uninstall the app.
	UninstallUri *string `json:"uninstall_uri,omitempty"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type AppFilter struct {
	// Filter by client ID
	ClientId *string `json:"client_id,omitempty"`
}

// Application defines model for Application.
type Application struct {
	// If true, the application will be listed in the Noona App Store.
	AppStore      *bool      `json:"app_store,omitempty"`
	Approved      *bool      `json:"approved,omitempty"`
	ClientId      *string    `json:"client_id,omitempty"`
	ClientSecret  *string    `json:"client_secret,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	Description   *string    `json:"description,omitempty"`
	DeveloperName *string    `json:"developer_name,omitempty"`

	// Home page or documentation for your application.
	DeveloperUrl *string `json:"developer_url,omitempty"`
	Id           *string `json:"id,omitempty"`
	Logo         *string `json:"logo,omitempty"`

	// Shown to the user when they are asked to give consent.
	Name *string `json:"name,omitempty"`

	// If true, the application will be usable from outside of the company.
	Public       *bool        `json:"public,omitempty"`
	RedirectUris *[]string    `json:"redirect_uris,omitempty"`
	Scopes       *OAuthScopes `json:"scopes,omitempty"`

	// If `true`, the application will appear in the navigation within Noona HQ.
	//
	// When clicked, the application's main redirect_uri will be displayed in an iFrame.
	ShowInNavigation *bool      `json:"show_in_navigation,omitempty"`
	UpdatedAt        *time.Time `json:"updated_at,omitempty"`
}

// Applications defines model for Applications.
type Applications []Application

// Apps defines model for Apps.
type Apps []App

// Attachment defines model for Attachment.
type Attachment struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Original filename of the uploaded attachment
	Filename    *string    `json:"filename,omitempty"`
	Id          *string    `json:"id,omitempty"`
	RelativeUrl *string    `json:"relative_url,omitempty"`
	SecureUrl   *string    `json:"secure_url,omitempty"`
	Type        *string    `json:"type,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// Attachments defines model for Attachments.
type Attachments []Attachment

// AvailabilityRule defines model for AvailabilityRule.
type AvailabilityRule struct {
	// End time within the day
	EndsAt *string `json:"ends_at,omitempty"`
	Open   bool    `json:"open"`

	// Start time within the day
	StartsAt *string              `json:"starts_at,omitempty"`
	Type     AvailabilityRuleType `json:"type"`
}

// AvailabilityRuleType defines model for AvailabilityRule.Type.
type AvailabilityRuleType string

// BillingAddress defines model for BillingAddress.
type BillingAddress struct {
	City       *string              `json:"city,omitempty"`
	Company    *string              `json:"company,omitempty"`
	Country    *string              `json:"country,omitempty"`
	Email      *openapi_types.Email `json:"email,omitempty"`
	FirstName  *string              `json:"first_name,omitempty"`
	LastName   *string              `json:"last_name,omitempty"`
	Phone      *string              `json:"phone,omitempty"`
	PostalCode *string              `json:"postal_code,omitempty"`
	Street     *string              `json:"street,omitempty"`
}

// BillingCustomer defines model for BillingCustomer.
type BillingCustomer struct {
	BillingAddress         *BillingAddress                 `json:"billing_address,omitempty"`
	BillingMethod          *BillingCustomerBillingMethod   `json:"billing_method,omitempty"`
	BusinessRegistrationId *string                         `json:"business_registration_id,omitempty"`
	Card                   *Card                           `json:"card,omitempty"`
	Company                *string                         `json:"company,omitempty"`
	Email                  *openapi_types.Email            `json:"email,omitempty"`
	FirstName              *string                         `json:"first_name,omitempty"`
	Id                     *string                         `json:"id,omitempty"`
	LastName               *string                         `json:"last_name,omitempty"`
	PaymentIntentId        *string                         `json:"payment_intent_id,omitempty"`
	Phone                  *string                         `json:"phone,omitempty"`
	PrimaryPaymentSourceId *string                         `json:"primary_payment_source_id,omitempty"`
	VatNumber              *string                         `json:"vat_number,omitempty"`
	VatNumberStatus        *BillingCustomerVatNumberStatus `json:"vat_number_status,omitempty"`
}

// BillingCustomerBillingMethod defines model for BillingCustomer.BillingMethod.
type BillingCustomerBillingMethod string

// BillingCustomerVatNumberStatus defines model for BillingCustomer.VatNumberStatus.
type BillingCustomerVatNumberStatus string

// BillingInvoice defines model for BillingInvoice.
type BillingInvoice struct {
	Amount     *int32                `json:"amount,omitempty"`
	Currency   *string               `json:"currency,omitempty"`
	Date       *time.Time            `json:"date,omitempty"`
	Id         *string               `json:"id,omitempty"`
	PaymentUrl *string               `json:"payment_url,omitempty"`
	Status     *BillingInvoiceStatus `json:"status,omitempty"`
}

// BillingInvoiceStatus defines model for BillingInvoice.Status.
type BillingInvoiceStatus string

// BillingInvoices defines model for BillingInvoices.
type BillingInvoices []BillingInvoice

// BlockedTime defines model for BlockedTime.
type BlockedTime struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor `json:"created_by,omitempty"`

	// Date of blocked time
	Date *string `json:"date,omitempty"`

	// Duration of blocked time from start to end
	Duration *int32 `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// End time of blocked time
	EndsAt *time.Time `json:"ends_at,omitempty"`
	Id     *string    `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Resource *ExpandableResource `json:"resource,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string for recurring events and blocked times.
	//
	// The dtstart property is ignored, and the start time of the event/blocked time is used instead.
	//
	// If no until is specified, it will default to 2 years from time of creation.
	//
	// Until has a maximum value of 2 years from time of creation.
	//
	// Count can be any value, but generated events/blocked times past the 2 year mark will be ignored.
	Rrule *RRuleString `json:"rrule,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Space *ExpandableSpace `json:"space,omitempty"`

	// Start time of blocked time
	StartsAt  *time.Time        `json:"starts_at,omitempty"`
	Theme     *BlockedTimeTheme `json:"theme,omitempty"`
	Title     *string           `json:"title,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	UpdatedBy *ExpandableActor `json:"updated_by,omitempty"`
}

// BlockedTimeCreate defines model for BlockedTimeCreate.
type BlockedTimeCreate struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor `json:"created_by,omitempty"`

	// Date of blocked time
	Date *string `json:"date,omitempty"`

	// Duration of blocked time from start to end
	Duration *int32 `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// End time of blocked time
	EndsAt time.Time `json:"ends_at"`
	Id     *string   `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Resource *ExpandableResource `json:"resource,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string for recurring events and blocked times.
	//
	// The dtstart property is ignored, and the start time of the event/blocked time is used instead.
	//
	// If no until is specified, it will default to 2 years from time of creation.
	//
	// Until has a maximum value of 2 years from time of creation.
	//
	// Count can be any value, but generated events/blocked times past the 2 year mark will be ignored.
	Rrule *RRuleString `json:"rrule,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Space *ExpandableSpace `json:"space,omitempty"`

	// Start time of blocked time
	StartsAt  time.Time         `json:"starts_at"`
	Theme     *BlockedTimeTheme `json:"theme,omitempty"`
	Title     *string           `json:"title,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	UpdatedBy *ExpandableActor `json:"updated_by,omitempty"`
}

// BlockedTimeCreateOverrides defines model for BlockedTimeCreateOverrides.
type BlockedTimeCreateOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company ExpandableCompany `json:"company"`

	// End time of blocked time
	EndsAt time.Time `json:"ends_at"`

	// Start time of blocked time
	StartsAt time.Time `json:"starts_at"`
}

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type BlockedTimeDeletionBehavior struct {
	// What blocked times to delete when deleting an blocked time that is a part of a recurring blocked time.
	//
	// - `single` - Only delete the referenced blocked time
	// - `future` - Delete referenced blocked time and all blocked times in the series after the referenced blocked time
	Type *BlockedTimeDeletionBehaviorType `json:"type,omitempty"`
}

// What blocked times to delete when deleting an blocked time that is a part of a recurring blocked time.
//
// - `single` - Only delete the referenced blocked time
// - `future` - Delete referenced blocked time and all blocked times in the series after the referenced blocked time
type BlockedTimeDeletionBehaviorType string

// BlockedTimeFilter defines model for BlockedTimeFilter.
type BlockedTimeFilter struct {
	// Filter by employee IDs
	Employees *[]string `json:"employees,omitempty"`

	// Only return blocked times where starts_at is after this timestamp.
	From *time.Time `json:"from,omitempty"`

	// Filter by resource IDs
	Resources *[]string `json:"resources,omitempty"`

	// Filter by space IDs
	Spaces *[]string `json:"spaces,omitempty"`

	// Only return blocked times where starts_at is before this timestamp.
	To *time.Time `json:"to,omitempty"`
}

// BlockedTimeResponse defines model for BlockedTimeResponse.
type BlockedTimeResponse struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor `json:"created_by,omitempty"`

	// Date of blocked time
	Date *string `json:"date,omitempty"`

	// Duration of blocked time from start to end
	Duration *int32 `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// End time of blocked time
	EndsAt time.Time `json:"ends_at"`
	Id     *string   `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Resource *ExpandableResource `json:"resource,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string for recurring events and blocked times.
	//
	// The dtstart property is ignored, and the start time of the event/blocked time is used instead.
	//
	// If no until is specified, it will default to 2 years from time of creation.
	//
	// Until has a maximum value of 2 years from time of creation.
	//
	// Count can be any value, but generated events/blocked times past the 2 year mark will be ignored.
	Rrule *RRuleString `json:"rrule,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Space *ExpandableSpace `json:"space,omitempty"`

	// Start time of blocked time
	StartsAt  time.Time        `json:"starts_at"`
	Theme     BlockedTimeTheme `json:"theme"`
	Title     *string          `json:"title,omitempty"`
	UpdatedAt *time.Time       `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	UpdatedBy *ExpandableActor `json:"updated_by,omitempty"`
}

// BlockedTimeResponseOverrides defines model for BlockedTimeResponseOverrides.
type BlockedTimeResponseOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor `json:"created_by,omitempty"`

	// Date of blocked time
	Date *string `json:"date,omitempty"`

	// Duration of blocked time from start to end
	Duration *int32 `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// End time of blocked time
	EndsAt time.Time `json:"ends_at"`
	Id     *string   `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Resource *ExpandableResource `json:"resource,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string for recurring events and blocked times.
	//
	// The dtstart property is ignored, and the start time of the event/blocked time is used instead.
	//
	// If no until is specified, it will default to 2 years from time of creation.
	//
	// Until has a maximum value of 2 years from time of creation.
	//
	// Count can be any value, but generated events/blocked times past the 2 year mark will be ignored.
	Rrule *RRuleString `json:"rrule,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Space *ExpandableSpace `json:"space,omitempty"`

	// Start time of blocked time
	StartsAt  time.Time        `json:"starts_at"`
	Theme     BlockedTimeTheme `json:"theme"`
	Title     *string          `json:"title,omitempty"`
	UpdatedAt *time.Time       `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	UpdatedBy *ExpandableActor `json:"updated_by,omitempty"`
}

// BlockedTimeTheme defines model for BlockedTimeTheme.
type BlockedTimeTheme string

// BlockedTimeUpdate defines model for BlockedTimeUpdate.
type BlockedTimeUpdate struct {
	Company   *interface{} `json:"company,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor `json:"created_by,omitempty"`

	// Date of blocked time
	Date *string `json:"date,omitempty"`

	// Duration of blocked time from start to end
	Duration *int32       `json:"duration,omitempty"`
	Employee *interface{} `json:"employee,omitempty"`

	// End time of blocked time
	EndsAt   *time.Time   `json:"ends_at,omitempty"`
	Id       *string      `json:"id,omitempty"`
	Resource *interface{} `json:"resource,omitempty"`
	Rrule    *interface{} `json:"rrule,omitempty"`
	Space    *interface{} `json:"space,omitempty"`

	// Start time of blocked time
	StartsAt  *time.Time        `json:"starts_at,omitempty"`
	Theme     *BlockedTimeTheme `json:"theme,omitempty"`
	Title     *string           `json:"title,omitempty"`
	UpdatedAt *time.Time        `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	UpdatedBy *ExpandableActor `json:"updated_by,omitempty"`
}

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type BlockedTimeUpdateBehavior struct {
	// What blocked time to update when updating a blocked time that is a part of a recurrance.
	//
	// - `detach` - Only update the referenced blocked time and detach it from the series
	// - `future` - Update referenced blocked time and all blocked times in the series after the referenced blocked time
	Type *BlockedTimeUpdateBehaviorType `json:"type,omitempty"`
}

// What blocked time to update when updating a blocked time that is a part of a recurrance.
//
// - `detach` - Only update the referenced blocked time and detach it from the series
// - `future` - Update referenced blocked time and all blocked times in the series after the referenced blocked time
type BlockedTimeUpdateBehaviorType string

// BlockedTimeUpdateOverrides defines model for BlockedTimeUpdateOverrides.
type BlockedTimeUpdateOverrides struct {
	Company  *interface{} `json:"company,omitempty"`
	Employee *interface{} `json:"employee,omitempty"`

	// End time of blocked time
	EndsAt   *time.Time   `json:"ends_at,omitempty"`
	Resource *interface{} `json:"resource,omitempty"`
	Rrule    *interface{} `json:"rrule,omitempty"`
	Space    *interface{} `json:"space,omitempty"`

	// Start time of blocked time
	StartsAt *time.Time `json:"starts_at,omitempty"`
}

// BlockedTimes defines model for BlockedTimes.
type BlockedTimes []BlockedTime

// BlockedTimesResponse defines model for BlockedTimesResponse.
type BlockedTimesResponse []BlockedTimeResponse

// Booking interval in minutes.
//
// Dictates how often customers can book events with employee or resource.
//
// A booking interval of 15 would render results like: `10:00`  `10:15`  `10:30`.
//
// A booking interval is set on the company level but can be overridden on the resource/employee level.
type BookingInterval int32

// BookingQuestion defines model for BookingQuestion.
type BookingQuestion struct {
	Answer   *string `json:"answer,omitempty"`
	Question *string `json:"question,omitempty"`
}

// BookingQuestions defines model for BookingQuestions.
type BookingQuestions []BookingQuestion

// The calculated price of an event type or event for a customer.
//
// This is calculated from the event type's price ranges, variations and possible discounts related to customer groups.
//
// On an event this is the aggregated price of all event types in the event and represents the total price of the event.
type CalculatedPrice struct {
	Amount           *float64 `json:"amount,omitempty"`
	AmountUpperLimit *float64 `json:"amount_upper_limit,omitempty"`
	Currency         *string  `json:"currency,omitempty"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type CalendarSlotFilter struct {
	// Filter by employee IDs
	Employees *[]string `json:"employees,omitempty"`

	// Filter by resource IDs
	Resources *[]string `json:"resources,omitempty"`

	// Filter by space IDs
	Spaces *[]string `json:"spaces,omitempty"`
}

// CallbackData defines model for CallbackData.
type CallbackData struct {
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Data      *CallbackData_Data `json:"data,omitempty"`

	// The unique ID of each callback. Can be treated as an idempotency key.
	Id   *string           `json:"id,omitempty"`
	Type *CallbackDataType `json:"type,omitempty"`
}

// CallbackData_Data defines model for CallbackData.Data.
type CallbackData_Data struct {
	union json.RawMessage
}

// CallbackDataType defines model for CallbackData.Type.
type CallbackDataType string

// Card defines model for Card.
type Card struct {
	CardType    *CardCardType `json:"card_type,omitempty"`
	ExpiryMonth *int32        `json:"expiry_month,omitempty"`
	ExpiryYear  *int32        `json:"expiry_year,omitempty"`
	FirstName   *string       `json:"first_name,omitempty"`
	Last4       *string       `json:"last4,omitempty"`
	LastName    *string       `json:"last_name,omitempty"`
	Status      *CardStatus   `json:"status,omitempty"`
}

// CardCardType defines model for Card.CardType.
type CardCardType string

// CardStatus defines model for Card.Status.
type CardStatus string

// ChargedBillingItem defines model for ChargedBillingItem.
type ChargedBillingItem struct {
	ItemPriceId   *string    `json:"item_price_id,omitempty"`
	LastChargedAt *time.Time `json:"last_charged_at,omitempty"`
}

// ChargedBillingItems defines model for ChargedBillingItems.
type ChargedBillingItems []ChargedBillingItem

// CheckinToken defines model for CheckinToken.
type CheckinToken struct {
	Token *string `json:"token,omitempty"`
}

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type CheckoutBehavior struct {
	// Controls the behviour of event checkout.
	//
	// - `checkout` - A normal checkout after service is performed.
	// - `noshow` - Used when a customer does not show up to an appointment with a prepayment. The line item becomes equal to the payment amount and the payment is created as a subtransaction.
	Type *CheckoutBehaviorType `json:"type,omitempty"`
}

// Controls the behviour of event checkout.
//
// - `checkout` - A normal checkout after service is performed.
// - `noshow` - Used when a customer does not show up to an appointment with a prepayment. The line item becomes equal to the payment amount and the payment is created as a subtransaction.
type CheckoutBehaviorType string

// Claim defines model for Claim.
type Claim struct {
	Amount            *int32       `json:"amount,omitempty"`
	BillNumber        *string      `json:"bill_number,omitempty"`
	ClaimantId        *string      `json:"claimant_id,omitempty"`
	CreatedAt         *time.Time   `json:"created_at,omitempty"`
	Currency          *string      `json:"currency,omitempty"`
	CustomerKennitala *string      `json:"customer_kennitala,omitempty"`
	CustomerName      *string      `json:"customer_name,omitempty"`
	DueDate           *string      `json:"due_date,omitempty"`
	EmployeeName      *string      `json:"employee_name,omitempty"`
	Id                *string      `json:"id,omitempty"`
	ReferenceId       *string      `json:"reference_id,omitempty"`
	Status            *ClaimStatus `json:"status,omitempty"`
}

// ClaimStatus defines model for ClaimStatus.
type ClaimStatus string

// Claims defines model for Claims.
type Claims []Claim

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type ClaimsFilter struct {
	CreatedAt *DateFilter `json:"created_at,omitempty"`
}

// CommissionConfig defines model for CommissionConfig.
type CommissionConfig struct {
	union json.RawMessage
}

// CommissionRates defines model for CommissionRates.
type CommissionRates struct {
	// Default commission rate
	DefaultRate float64             `json:"default_rate"`
	Type        CommissionRatesType `json:"type"`
}

// CommissionRatesType defines model for CommissionRates.Type.
type CommissionRatesType string

// Companies defines model for Companies.
type Companies []Company

// Company defines model for Company.
type Company struct {
	Adyen     *AdyenConnection        `json:"adyen,omitempty"`
	Checkin   *CompanyCheckin         `json:"checkin,omitempty"`
	CreatedAt *time.Time              `json:"created_at,omitempty"`
	Currency  *CompanyDefaultCurrency `json:"currency,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Enterprise  *ExpandableEnterprise `json:"enterprise,omitempty"`
	Id          *string               `json:"id,omitempty"`
	Locale      *Locale               `json:"locale,omitempty"`
	Location    *Location             `json:"location,omitempty"`
	Marketplace *CompanyMarketplace   `json:"marketplace,omitempty"`
	Name        *string               `json:"name,omitempty"`

	// Dynamic mapping of payment reasons to fees. Valid keys include "event", "paylink", "voucher", etc.,  representing different reasons for payments. Each key maps to a fee represented as a floating-point number.
	PaymentFees *PaymentFees     `json:"payment_fees,omitempty"`
	Payments    *PaymentSettings `json:"payments,omitempty"`

	// Deprecated, use profile.phone_country_code instead
	PhoneCountryCode *string `json:"phone_country_code,omitempty"`

	// Deprecated, use profile.phone_number instead
	PhoneNumber *string          `json:"phone_number,omitempty"`
	Pos         *POSSettings     `json:"pos,omitempty"`
	Profile     *CompanyProfile  `json:"profile,omitempty"`
	UpdatedAt   *time.Time       `json:"updated_at,omitempty"`
	Vertical    *CompanyVertical `json:"vertical,omitempty"`
	Vouchers    *VoucherSettings `json:"vouchers,omitempty"`
}

// CompanyVertical defines model for Company.Vertical.
type CompanyVertical string

// CompanyCheckin defines model for CompanyCheckin.
type CompanyCheckin struct {
	SuccessMessage *string `json:"success_message,omitempty"`
}

// CompanyDefaultCurrency defines model for CompanyDefaultCurrency.
type CompanyDefaultCurrency struct {
	Code   *string `json:"code,omitempty"`
	Name   *string `json:"name,omitempty"`
	Symbol *string `json:"symbol,omitempty"`
}

// CompanyMarketplace defines model for CompanyMarketplace.
type CompanyMarketplace struct {
	AllowBookingMultipleServices    *bool `json:"allow_booking_multiple_services,omitempty"`
	AllowBookingOverCancelledEvents *bool `json:"allow_booking_over_cancelled_events,omitempty"`
	AllowBookingWithoutConfirmation *bool `json:"allow_booking_without_confirmation,omitempty"`

	// Indicates if the company should receive email notifications upon booking confirmation. Notifications are sent to the company's primary email address.
	//
	// This feature is especially beneficial for businesses without dedicated employees, relying solely on resources.
	EmailNotification *bool `json:"email_notification,omitempty"`

	// Whether the company is enabled on the marketplace. If true, the company will appear in search results, category listings etc. `visible` must be true for this to have any effect.
	Enabled *bool `json:"enabled,omitempty"`

	// The date and time when the company was onboarded to online bookings.
	// This is used to determine if the company has been onboarded online bookings or not, regardless of the value of `enabled` and `visible`.
	OnboardedAt *time.Time `json:"onboarded_at,omitempty"`

	// Used when constructing the marketplace url for the company.
	//
	// Can include lowercase letters, numbers and dashes.
	UrlName *string `json:"url_name,omitempty"`

	// Whether the company is visible through the marketplace API.
	//
	// `visible: true - enabled: true` means that the company is visible and enabled on the marketplace. Appears in search results etc.
	//
	// `visible: true - enabled: false` means that the company is visible but not enabled on the marketplace. The company does not appear in search results
	// and category listings but their booking page is accessbile. This supports the case where companies only want to receive bookings through their own website
	// or directly through their noona booking page. (https://noona.app/thebookingpage)
	//
	// `visible: false - enabled: true/false` means that the company is not visible at all. The *enabled* flag is ignored in this case.
	Visible *bool `json:"visible,omitempty"`

	// Indicates if the company should be able to receive waitlist entries from the marketplace.
	//
	// This allows customers to add themselves to the waitlist at company.
	WaitlistEnabled *bool `json:"waitlist_enabled,omitempty"`
}

// CompanyProfile defines model for CompanyProfile.
type CompanyProfile struct {
	BookingRedirectUrl    *string   `json:"booking_redirect_url,omitempty"`
	BookingSuccessMessage *string   `json:"booking_success_message,omitempty"`
	CompanyTypes          *[]string `json:"company_types,omitempty"`
	ContactEmail          *string   `json:"contact_email,omitempty"`

	// The marketplace images displayed on a companies profile
	CoverImages *[]Image `json:"cover_images,omitempty"`
	Description *string  `json:"description,omitempty"`

	// The number of favorites/likes on the company.
	Favorites                *int32 `json:"favorites,omitempty"`
	Image                    *Image `json:"image,omitempty"`
	LicensePlate             *bool  `json:"license_plate,omitempty"`
	MaxBookableFutureDays    *int32 `json:"max_bookable_future_days,omitempty"`
	MinBookingNoticeMinutes  *int32 `json:"min_booking_notice_minutes,omitempty"`
	MinCancelNoticeHours     *int32 `json:"min_cancel_notice_hours,omitempty"`
	MinRescheduleNoticeHours *int32 `json:"min_reschedule_notice_hours,omitempty"`

	// Opening hours for the company. Array of seven (7) items, 0 being Monday and 6 Sunday. Or 0 being Sunday. Nobody really knows.
	OpeningHours     *OpeningHours `json:"opening_hours,omitempty"`
	PhoneCountryCode *string       `json:"phone_country_code,omitempty"`
	PhoneNumber      *string       `json:"phone_number,omitempty"`

	// Whether the company prefers 12 hour time format.
	Prefer12Hours *bool `json:"prefer_12_hours,omitempty"`

	// The price category of the company.
	PriceCategory  *int32          `json:"price_category,omitempty"`
	RequiredFields *RequiredFields `json:"required_fields,omitempty"`
	StoreName      *string         `json:"store_name,omitempty"`
	WebAuthOptOut  *bool           `json:"web_auth_opt_out,omitempty"`
}

// Country defines model for Country.
type Country struct {
	LongName  *string `json:"long_name,omitempty"`
	ShortName *string `json:"short_name,omitempty"`
}

// CustomDuration defines model for CustomDuration.
type CustomDuration struct {
	AfterPause  *int32 `json:"after_pause,omitempty"`
	BeforePause *int32 `json:"before_pause,omitempty"`
	Duration    *int32 `json:"duration,omitempty"`
	Pause       *int32 `json:"pause,omitempty"`
}

// CustomProperties defines model for CustomProperties.
type CustomProperties []CustomProperty

// CustomProperty defines model for CustomProperty.
type CustomProperty struct {
	Company   *string                `json:"company,omitempty"`
	CreatedAt *time.Time             `json:"created_at,omitempty"`
	Id        *string                `json:"id,omitempty"`
	Name      *string                `json:"name,omitempty"`
	Options   *CustomPropertyOptions `json:"options,omitempty"`
	Scope     *CustomPropertyScope   `json:"scope,omitempty"`
	Type      *CustomPropertyType    `json:"type,omitempty"`
	UpdatedAt *time.Time             `json:"updated_at,omitempty"`
}

// CustomPropertyScope defines model for CustomProperty.Scope.
type CustomPropertyScope string

// CustomPropertyType defines model for CustomProperty.Type.
type CustomPropertyType string

// CustomPropertyOption defines model for CustomPropertyOption.
type CustomPropertyOption struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// CustomPropertyOptions defines model for CustomPropertyOptions.
type CustomPropertyOptions []CustomPropertyOption

// CustomPropertyValue defines model for CustomPropertyValue.
type CustomPropertyValue struct {
	Id        *string   `json:"id,omitempty"`
	ValueIsId *bool     `json:"valueIsId,omitempty"`
	Values    *[]string `json:"values,omitempty"`
}

// CustomPropertyValues defines model for CustomPropertyValues.
type CustomPropertyValues []CustomPropertyValue

// Customer defines model for Customer.
type Customer struct {
	Attachments *Attachments `json:"attachments,omitempty"`

	// ID of the company that the customer belongs to.
	Company          *string               `json:"company,omitempty"`
	CompanyId        *string               `json:"company_id,omitempty"`
	CreatedAt        *time.Time            `json:"created_at,omitempty"`
	CustomProperties *CustomPropertyValues `json:"custom_properties,omitempty"`

	// The customers duplicate status.
	//
	// If `approved` the customer has been approved as a duplicate.
	//
	// If `possible` the duplication has to be manually resolved.
	DuplicateStatus *DuplicateStatus     `json:"duplicateStatus,omitempty"`
	Duplicates      *ExpandableCustomers `json:"duplicates,omitempty"`
	Email           *string              `json:"email,omitempty"`
	EmployeeIds     *[]string            `json:"employee_ids,omitempty"`
	EventCount      *int32               `json:"event_count,omitempty"`

	// Customer groups that the customer belongs to.
	Groups       *ExpandableCustomerGroups `json:"groups,omitempty"`
	Id           *string                   `json:"id,omitempty"`
	Kennitala    *string                   `json:"kennitala,omitempty"`
	LastEmployee *string                   `json:"last_employee,omitempty"`
	LastEvent    *string                   `json:"last_event,omitempty"`
	LicensePlate *string                   `json:"license_plate,omitempty"`

	// All different license plates that the customer has used.
	LicensePlates *[]string `json:"license_plates,omitempty"`
	Name          *string   `json:"name,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	NextEvent        *ExpandableEvent `json:"next_event,omitempty"`
	Notes            *string          `json:"notes,omitempty"`
	Notices          *Notices         `json:"notices,omitempty"`
	PhoneCountryCode *string          `json:"phone_country_code,omitempty"`
	PhoneNumber      *string          `json:"phone_number,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	PreviousEvent *ExpandableEvent `json:"previous_event,omitempty"`
	Tags          *CustomerTags    `json:"tags,omitempty"`
	UpdateOrigin  *string          `json:"update_origin,omitempty"`
	UpdatedAt     *time.Time       `json:"updated_at,omitempty"`
	UpdatedBy     *string          `json:"updated_by,omitempty"`
}

// CustomerActivities defines model for CustomerActivities.
type CustomerActivities []CustomerActivity

// CustomerActivity defines model for CustomerActivity.
type CustomerActivity struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor      `json:"created_by,omitempty"`
	Field     CustomerActivityField `json:"field"`
	Id        *string               `json:"id,omitempty"`
	NewValue  *MultiValue           `json:"new_value,omitempty"`
	OldValue  *MultiValue           `json:"old_value,omitempty"`
	Type      *CustomerActivityType `json:"type,omitempty"`
}

// CustomerActivityField defines model for CustomerActivity.Field.
type CustomerActivityField string

// CustomerActivityType defines model for CustomerActivity.Type.
type CustomerActivityType string

// CustomerFilter defines model for CustomerFilter.
type CustomerFilter struct {
	// The customers duplicate status.
	//
	// If `approved` the customer has been approved as a duplicate.
	//
	// If `possible` the duplication has to be manually resolved.
	DuplicateStatus *DuplicateStatus `json:"duplicate_status,omitempty"`

	// Filter by phone country code of customer
	PhoneCountryCode *string `json:"phone_country_code,omitempty"`

	// Filter by phone number of customer
	PhoneNumber *string `json:"phone_number,omitempty"`
}

// CustomerGroup defines model for CustomerGroup.
type CustomerGroup struct {
	Company     *string    `json:"company,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Title       *string    `json:"title,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// CustomerGroups defines model for CustomerGroups.
type CustomerGroups []CustomerGroup

// CustomerTags defines model for CustomerTags.
type CustomerTags struct {
	Vip *bool `json:"vip,omitempty"`
}

// Customers defines model for Customers.
type Customers []Customer

// DateFilter defines model for DateFilter.
type DateFilter struct {
	From *time.Time `json:"from,omitempty"`
	To   *time.Time `json:"to,omitempty"`
}

// DeletionResult defines model for DeletionResult.
type DeletionResult struct {
	// Number of notifications deleted
	Count *int32 `json:"count,omitempty"`
}

// The customers duplicate status.
//
// If `approved` the customer has been approved as a duplicate.
//
// If `possible` the duplication has to be manually resolved.
type DuplicateStatus string

// Employee defines model for Employee.
type Employee struct {
	Adyen *AdyenConnection `json:"adyen,omitempty"`

	// Whether the employee is visible on the calendar
	AvailableForBookings *bool                `json:"available_for_bookings,omitempty"`
	Commissions          *EmployeeCommissions `json:"commissions,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company *ExpandableCompany `json:"company,omitempty"`

	// Use `company` instead
	CompanyId *string `json:"company_id,omitempty"`

	// Whether the employee is connected to teya
	ConnectedToTeya      *bool                         `json:"connected_to_teya,omitempty"`
	CreatedAt            *time.Time                    `json:"created_at,omitempty"`
	Description          *string                       `json:"description,omitempty"`
	DisabledAt           *time.Time                    `json:"disabled_at,omitempty"`
	Email                *string                       `json:"email,omitempty"`
	EmailVerified        *bool                         `json:"email_verified,omitempty"`
	EventTypePreferences *EventTypePreferences         `json:"event_type_preferences,omitempty"`
	Id                   *string                       `json:"id,omitempty"`
	Image                *Image                        `json:"image,omitempty"`
	Marketplace          *EmployeeMarketplaceSettings  `json:"marketplace,omitempty"`
	Name                 *string                       `json:"name,omitempty"`
	Notifications        *EmployeeNotificationSettings `json:"notifications,omitempty"`

	// The order of the employee in the list of employees on the marketplace.
	Order *int32 `json:"order,omitempty"`

	// Whether the employee is pending owner approval
	PendingOwnerApproval *bool `json:"pending_owner_approval,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Role *ExpandableRole `json:"role,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	SettlementAccount *ExpandableSettlementAccount `json:"settlement_account,omitempty"`
	UpdatedAt         *time.Time                   `json:"updated_at,omitempty"`
}

// EmployeeCommissions defines model for EmployeeCommissions.
type EmployeeCommissions struct {
	Calendar *EmployeeCommissionsCalendar `json:"calendar,omitempty"`
	Pos      *EmployeeCommissionsPOS      `json:"pos,omitempty"`
}

// EmployeeCommissionsCalendar defines model for EmployeeCommissionsCalendar.
type EmployeeCommissionsCalendar struct {
	Bookings *CommissionConfig `json:"bookings,omitempty"`
}

// EmployeeCommissionsPOS defines model for EmployeeCommissionsPOS.
type EmployeeCommissionsPOS struct {
	Products *CommissionConfig `json:"products,omitempty"`
	Services *CommissionConfig `json:"services,omitempty"`
	Vouchers *CommissionConfig `json:"vouchers,omitempty"`
}

// EmployeeField defines model for EmployeeField.
type EmployeeField string

// EmployeeFields defines model for EmployeeFields.
type EmployeeFields []EmployeeField

// EmployeeMarketplaceSettings defines model for EmployeeMarketplaceSettings.
type EmployeeMarketplaceSettings struct {
	// Whether the employee should be able to receive bookings without confirmation
	AllowBookingWithoutConfirmation *bool `json:"allow_booking_without_confirmation,omitempty"`

	// Booking interval in minutes.
	//
	// Dictates how often customers can book events with employee or resource.
	//
	// A booking interval of 15 would render results like: `10:00`  `10:15`  `10:30`.
	//
	// A booking interval is set on the company level but can be overridden on the resource/employee level.
	BookingInterval *BookingInterval `json:"booking_interval,omitempty"`

	// Whether the employee is enabled on the marketplace
	Enabled *bool `json:"enabled,omitempty"`

	// Whether the employee should be excluded from randomization pool on the marketplace
	ExcludeFromRandomizationPool *bool `json:"exclude_from_randomization_pool,omitempty"`

	// Whether the employee is receiving their own settlements.
	//
	// Calculated from own_settlements_allowed and own_settlements_preferred.
	OwnSettlements *bool `json:"own_settlements,omitempty"`

	// Whether the employee is allowed to receive their own settlements.
	//
	// Can only be edited by the owner of the company.
	OwnSettlementsAllowed *bool `json:"own_settlements_allowed,omitempty"`

	// Whether the employee prefers to receive their own settlements.
	//
	// Can only be edited by the employee.
	OwnSettlementsPreferred *bool `json:"own_settlements_preferred,omitempty"`

	// Whether the employee can receive pre-payments
	//
	// Can only be edited by the owner of the company.
	PrePaymentsEnabled *bool `json:"pre_payments_enabled,omitempty"`

	// Whether the employee should be prioritized in random selection on the marketplace
	Prioritized *bool `json:"prioritized,omitempty"`
}

// EmployeeNotificationSettings defines model for EmployeeNotificationSettings.
type EmployeeNotificationSettings struct {
	// Whether the employee should receive emails when a booking is made
	BookingEmail *bool `json:"booking_email,omitempty"`
}

// Employees defines model for Employees.
type Employees []Employee

// Enterprise defines model for Enterprise.
type Enterprise struct {
	// An array of companies belonging to enterprise.
	Companies   *[]string              `json:"companies,omitempty"`
	Connections *EnterpriseConnections `json:"connections,omitempty"`
	Id          *string                `json:"id,omitempty"`
	Profile     *EnterpriseProfile     `json:"profile,omitempty"`
}

// EnterpriseConnections defines model for EnterpriseConnections.
type EnterpriseConnections struct {
	// Controls whether customers can make appointments without authentication
	AllowsBookingWithoutAuth *bool                             `json:"allows_booking_without_auth,omitempty"`
	AvailableOnMarketplace   *bool                             `json:"available_on_marketplace,omitempty"`
	Marketplace              *EnterpriseConnectionsMarketplace `json:"marketplace,omitempty"`

	// Used when constructing the marketplace url for the enterprise.
	//
	// Can include lowercase letters, numbers and dashes.
	UrlName  *string                        `json:"url_name,omitempty"`
	Vouchers *EnterpriseConnectionsVouchers `json:"vouchers,omitempty"`
}

// EnterpriseConnectionsMarketplace defines model for EnterpriseConnectionsMarketplace.
type EnterpriseConnectionsMarketplace struct {
	EnableVouchers *bool `json:"enable_vouchers,omitempty"`
}

// EnterpriseConnectionsVouchers defines model for EnterpriseConnectionsVouchers.
type EnterpriseConnectionsVouchers struct {
	Enabled             *bool   `json:"enabled,omitempty"`
	SettlementAccountId *string `json:"settlement_account_id,omitempty"`
}

// EnterpriseProfile defines model for EnterpriseProfile.
type EnterpriseProfile struct {
	Image *Image  `json:"image,omitempty"`
	Name  *string `json:"name,omitempty"`
}

// Enterprises defines model for Enterprises.
type Enterprises []Enterprise

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Event defines model for Event.
type Event struct {
	AcceptedAt       *time.Time        `json:"accepted_at,omitempty"`
	Attachments      *Attachments      `json:"attachments,omitempty"`
	BookingQuestions *BookingQuestions `json:"booking_questions,omitempty"`

	// Provided by customers when they decline through the marketplace.
	CancelReason  *string      `json:"cancel_reason,omitempty"`
	CheckInAt     *int32       `json:"check_in_at,omitempty"`
	CheckInOrigin *string      `json:"check_in_origin,omitempty"`
	ClaimStatus   *ClaimStatus `json:"claim_status,omitempty"`
	Comment       *string      `json:"comment,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy        *ExpandableActor      `json:"created_by,omitempty"`
	CustomProperties *CustomPropertyValues `json:"custom_properties,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer *Event_Customer `json:"customer,omitempty"`

	// A comment that the customer included during a marketplace booking.
	CustomerComment *string `json:"customer_comment,omitempty"`

	// Deprecated, expand customer property instead
	CustomerName *string    `json:"customer_name,omitempty"`
	DeclinedAt   *time.Time `json:"declined_at,omitempty"`
	DeletedAt    *time.Time `json:"deleted_at,omitempty"`
	Duration     *int32     `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// Deprecated, expand employee property instead
	EmployeeName *string `json:"employee_name,omitempty"`

	// Deprecated, use ends_at instead
	EndTime *string `json:"end_time,omitempty"`

	// End time of event
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// Deprecated, use starts_at instead
	EventDate     *string             `json:"event_date,omitempty"`
	EventTypes    *EventTypes         `json:"event_types,omitempty"`
	Id            *string             `json:"id,omitempty"`
	InvoiceStatus *EventInvoiceStatus `json:"invoice_status,omitempty"`

	// License plate for the vehicle associated with this event
	LicensePlate            *string                  `json:"license_plate,omitempty"`
	NotificationPreferences *NotificationPreferences `json:"notification_preferences,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32       `json:"number_of_guests,omitempty"`
	Origin         *EventOrigin `json:"origin,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Payment *ExpandablePayment `json:"payment,omitempty"`

	// A property that users can use to pin events.
	Pinned *bool `json:"pinned,omitempty"`

	// The calculated price of an event type or event for a customer.
	//
	// This is calculated from the event type's price ranges, variations and possible discounts related to customer groups.
	//
	// On an event this is the aggregated price of all event types in the event and represents the total price of the event.
	Price          *CalculatedPrice      `json:"price,omitempty"`
	RecurringEvent *Event_RecurringEvent `json:"recurring_event,omitempty"`
	Resources      *ExpandableResources  `json:"resources,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string for recurring events and blocked times.
	//
	// The dtstart property is ignored, and the start time of the event/blocked time is used instead.
	//
	// If no until is specified, it will default to 2 years from time of creation.
	//
	// Until has a maximum value of 2 years from time of creation.
	//
	// Count can be any value, but generated events/blocked times past the 2 year mark will be ignored.
	Rrule *RRuleString `json:"rrule,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Sale *ExpandableSale `json:"sale,omitempty"`

	// Use resource instead
	Space *Event_Space `json:"space,omitempty"`

	// Deprecated, expand resource property instead
	SpaceName *string `json:"space_name,omitempty"`

	// A property that users can use to mark events as special. Has no affect on system behavior.
	Special *bool `json:"special,omitempty"`

	// Deprecated, use starts_at instead
	StartTime *string `json:"start_time,omitempty"`

	// Start time of event
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// The status of the event.
	//
	// See [Event Statuses](#section/Event-Statuses) for more information.
	Status *string `json:"status,omitempty"`

	// Event is unconfirmed if the employee has not yet confirmed the booking.
	// This is only relevant for companies that have the "Require employee confirmation" setting enabled.
	Unconfirmed *bool `json:"unconfirmed,omitempty"`

	// What system last updated the event
	UpdateOrigin *EventUpdateOrigin `json:"update_origin,omitempty"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	UpdatedBy *ExpandableActor `json:"updated_by,omitempty"`

	// The version of the event.
	//
	// This is incremented every time the event is updated.
	//
	// This is useful for detecting if an event has been updated since it was last fetched.
	Version *int32 `json:"version,omitempty"`

	// The ID of the waitlist entry that this event is associated with.
	//
	// Waitlist entries are automatically deleted when the event is created.
	WaitlistEntry *string `json:"waitlist_entry,omitempty"`
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type Event_Customer struct {
	union json.RawMessage
}

// EventInvoiceStatus defines model for Event.InvoiceStatus.
type EventInvoiceStatus string

// EventOrigin defines model for Event.Origin.
type EventOrigin string

// Event_RecurringEvent defines model for Event.RecurringEvent.
type Event_RecurringEvent struct {
	union json.RawMessage
}

// Use resource instead
type Event_Space struct {
	union json.RawMessage
}

// What system last updated the event
type EventUpdateOrigin string

// EventActivities defines model for EventActivities.
type EventActivities []EventActivity

// EventActivity defines model for EventActivity.
type EventActivity struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor   `json:"created_by,omitempty"`
	Field     EventActivityField `json:"field"`
	Id        *string            `json:"id,omitempty"`
	NewValue  *MultiValue        `json:"new_value,omitempty"`
	OldValue  *MultiValue        `json:"old_value,omitempty"`
	Type      *EventActivityType `json:"type,omitempty"`
}

// EventActivityField defines model for EventActivity.Field.
type EventActivityField string

// EventActivityType defines model for EventActivity.Type.
type EventActivityType string

// EventCheckinResult defines model for EventCheckinResult.
type EventCheckinResult struct {
	AcceptedAt       *time.Time        `json:"accepted_at,omitempty"`
	Attachments      *Attachments      `json:"attachments,omitempty"`
	BookingQuestions *BookingQuestions `json:"booking_questions,omitempty"`

	// Provided by customers when they decline through the marketplace.
	CancelReason          *string      `json:"cancel_reason,omitempty"`
	CheckInAt             *int32       `json:"check_in_at,omitempty"`
	CheckInOrigin         *string      `json:"check_in_origin,omitempty"`
	CheckInSuccessMessage *string      `json:"check_in_success_message,omitempty"`
	ClaimStatus           *ClaimStatus `json:"claim_status,omitempty"`
	Comment               *string      `json:"comment,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy        *ExpandableActor      `json:"created_by,omitempty"`
	CustomProperties *CustomPropertyValues `json:"custom_properties,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer *EventCheckinResult_Customer `json:"customer,omitempty"`

	// A comment that the customer included during a marketplace booking.
	CustomerComment *string `json:"customer_comment,omitempty"`

	// Deprecated, expand customer property instead
	CustomerName *string    `json:"customer_name,omitempty"`
	DeclinedAt   *time.Time `json:"declined_at,omitempty"`
	DeletedAt    *time.Time `json:"deleted_at,omitempty"`
	Duration     *int32     `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// Deprecated, expand employee property instead
	EmployeeName *string `json:"employee_name,omitempty"`

	// Deprecated, use ends_at instead
	EndTime *string `json:"end_time,omitempty"`

	// End time of event
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// Deprecated, use starts_at instead
	EventDate     *string                          `json:"event_date,omitempty"`
	EventTypes    *EventTypes                      `json:"event_types,omitempty"`
	Id            *string                          `json:"id,omitempty"`
	InvoiceStatus *EventCheckinResultInvoiceStatus `json:"invoice_status,omitempty"`

	// License plate for the vehicle associated with this event
	LicensePlate            *string                  `json:"license_plate,omitempty"`
	NotificationPreferences *NotificationPreferences `json:"notification_preferences,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32                    `json:"number_of_guests,omitempty"`
	Origin         *EventCheckinResultOrigin `json:"origin,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Payment *ExpandablePayment `json:"payment,omitempty"`

	// A property that users can use to pin events.
	Pinned *bool `json:"pinned,omitempty"`

	// The calculated price of an event type or event for a customer.
	//
	// This is calculated from the event type's price ranges, variations and possible discounts related to customer groups.
	//
	// On an event this is the aggregated price of all event types in the event and represents the total price of the event.
	Price          *CalculatedPrice                   `json:"price,omitempty"`
	RecurringEvent *EventCheckinResult_RecurringEvent `json:"recurring_event,omitempty"`
	Resources      *ExpandableResources               `json:"resources,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string for recurring events and blocked times.
	//
	// The dtstart property is ignored, and the start time of the event/blocked time is used instead.
	//
	// If no until is specified, it will default to 2 years from time of creation.
	//
	// Until has a maximum value of 2 years from time of creation.
	//
	// Count can be any value, but generated events/blocked times past the 2 year mark will be ignored.
	Rrule *RRuleString `json:"rrule,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Sale   *ExpandableSale `json:"sale,omitempty"`
	SaleId *string         `json:"sale_id,omitempty"`

	// Use resource instead
	Space *EventCheckinResult_Space `json:"space,omitempty"`

	// Deprecated, expand resource property instead
	SpaceName *string `json:"space_name,omitempty"`

	// A property that users can use to mark events as special. Has no affect on system behavior.
	Special *bool `json:"special,omitempty"`

	// Deprecated, use starts_at instead
	StartTime *string `json:"start_time,omitempty"`

	// Start time of event
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// The status of the event.
	//
	// See [Event Statuses](#section/Event-Statuses) for more information.
	Status *string `json:"status,omitempty"`

	// The ID of the subtransaction tied to this self-checkin.
	//
	// If the company does not have a terminal associated with their checkin, this ID will be empty.
	SubtransactionId *string `json:"subtransaction_id,omitempty"`
	TransactionId    *string `json:"transaction_id,omitempty"`

	// Event is unconfirmed if the employee has not yet confirmed the booking.
	// This is only relevant for companies that have the "Require employee confirmation" setting enabled.
	Unconfirmed *bool `json:"unconfirmed,omitempty"`

	// What system last updated the event
	UpdateOrigin *EventCheckinResultUpdateOrigin `json:"update_origin,omitempty"`
	UpdatedAt    *time.Time                      `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	UpdatedBy *ExpandableActor `json:"updated_by,omitempty"`

	// The version of the event.
	//
	// This is incremented every time the event is updated.
	//
	// This is useful for detecting if an event has been updated since it was last fetched.
	Version *int32 `json:"version,omitempty"`

	// The ID of the waitlist entry that this event is associated with.
	//
	// Waitlist entries are automatically deleted when the event is created.
	WaitlistEntry *string `json:"waitlist_entry,omitempty"`
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type EventCheckinResult_Customer struct {
	union json.RawMessage
}

// EventCheckinResultInvoiceStatus defines model for EventCheckinResult.InvoiceStatus.
type EventCheckinResultInvoiceStatus string

// EventCheckinResultOrigin defines model for EventCheckinResult.Origin.
type EventCheckinResultOrigin string

// EventCheckinResult_RecurringEvent defines model for EventCheckinResult.RecurringEvent.
type EventCheckinResult_RecurringEvent struct {
	union json.RawMessage
}

// Use resource instead
type EventCheckinResult_Space struct {
	union json.RawMessage
}

// What system last updated the event
type EventCheckinResultUpdateOrigin string

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type EventCreationBehavior struct {
	// Whether to notify customer about the event.
	//
	// When true, the customer will receive an email and push notification about the event.
	//
	// When false, the customer will not receive any notification about the event.
	Notify *bool `json:"notify,omitempty"`
}

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type EventDeletionBehavior struct {
	// What events to delete when deleting an event that is a part of a recurring event.
	//
	// - `single` - Only delete the referenced event
	// - `future` - Delete referenced event and all events in the series after the referenced event
	Type *EventDeletionBehaviorType `json:"type,omitempty"`
}

// What events to delete when deleting an event that is a part of a recurring event.
//
// - `single` - Only delete the referenced event
// - `future` - Delete referenced event and all events in the series after the referenced event
type EventDeletionBehaviorType string

// EventFilter defines model for EventFilter.
type EventFilter struct {
	// Use `customers` instead.
	Customer *string `json:"customer,omitempty"`

	// Filter by customer IDs
	Customers *[]string `json:"customers,omitempty"`

	// Filter by employee IDs
	Employees *[]string `json:"employees,omitempty"`

	// Exclude specific event IDs from response
	Exclude *[]string `json:"exclude,omitempty"`

	// Only return events where starts_at is after this timestamp.
	From *time.Time `json:"from,omitempty"`

	// Filter by specific event IDs
	Ids *[]string `json:"ids,omitempty"`

	// Whether to include deleted events in the response.
	//
	// When true, deleted events will be included in the response.
	//
	// When false, deleted events will not be included in the response.
	IncludeDeleted *bool `json:"include_deleted,omitempty"`

	// Filter by phone country code of customer
	PhoneCountryCode *string `json:"phone_country_code,omitempty"`

	// Filter by phone number of customer
	PhoneNumber *string `json:"phone_number,omitempty"`

	// Filter by resource IDs
	Resources *[]string `json:"resources,omitempty"`

	// Filter by space IDs
	Spaces *[]string `json:"spaces,omitempty"`

	// Only return events where starts_at is before this timestamp.
	To *time.Time `json:"to,omitempty"`

	// Only return events where updated_at is after this timestamp.
	UpdatedFrom *time.Time `json:"updated_from,omitempty"`
}

// EventStatus defines model for EventStatus.
type EventStatus struct {
	Color *string `json:"color,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Default   *bool              `json:"default,omitempty"`
	Id        *string            `json:"id,omitempty"`

	// The label of the status. This is the label that is shown to the user in the UI.
	//
	// For default Noona statuses the label is translated according to the Accept-Language header.
	//
	// For custom statuses the label is simply the value of the `label` field.
	Label *string `json:"label,omitempty"`
	Name  *string `json:"name,omitempty"`

	// The order of the status. This is the order that the statuses are shown in the UI.
	//
	// For default Noona statuses the order is always 0.
	//
	// Order can be used to sort custom statuses.
	Order     *int32     `json:"order,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// EventStatuses defines model for EventStatuses.
type EventStatuses []EventStatus

// EventType defines model for EventType.
type EventType struct {
	// The event duration after the pause
	AfterPause *int32 `json:"afterPause,omitempty"`

	// The event duration before the pause
	BeforePause *int32 `json:"beforePause,omitempty"`

	// How many minutes of buffer the service needs after it ends. This does not affect the duration of the event shown to customers but is considered when calculating timeslots.
	BufferAfterService *int32 `json:"buffer_after_service,omitempty"`

	// Color code for the event
	Color *string `json:"color,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company *ExpandableCompany `json:"company,omitempty"`

	// Deprecated, please use company instead
	CompanyId   *string               `json:"company_id,omitempty"`
	Connections *EventTypeConnections `json:"connections,omitempty"`
	CreatedAt   *time.Time            `json:"created_at,omitempty"`

	// By providing a **payments** object this is implicitly `true`.
	//
	// By using the unset query parameter and passing in the **payments** key this is implicitly `false`.
	CustomPaymentSettings *bool `json:"custom_payment_settings,omitempty"`

	// Delay in minutes from event start time
	Delay       *int32  `json:"delay,omitempty"`
	Description *string `json:"description,omitempty"`

	// Duration of the event type
	Duration *int32 `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventTypeCategory *ExpandableEventTypeCategory `json:"event_type_category,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventTypeCategoryGroup *ExpandableEventTypeCategoryGroup `json:"event_type_category_group,omitempty"`
	Id                     *string                           `json:"id,omitempty"`

	// The event type's image URL in the original size
	Image *string `json:"image,omitempty"`

	// Deprecated, please use duration instead
	Minutes *int32 `json:"minutes,omitempty"`

	// How event is overbookable
	Overbookable *EventTypeOverbookable `json:"overbookable,omitempty"`

	// The pause duration
	Pause    *int32           `json:"pause,omitempty"`
	Payments *PaymentSettings `json:"payments,omitempty"`

	// The calculated price of an event type or event for a customer.
	//
	// This is calculated from the event type's price ranges, variations and possible discounts related to customer groups.
	//
	// On an event this is the aggregated price of all event types in the event and represents the total price of the event.
	Price       *CalculatedPrice      `json:"price,omitempty"`
	PriceRanges *EventTypePriceRanges `json:"price_ranges,omitempty"`

	// An ID that can be used to reference the event type in an external system.
	// This ID is not used by Noona and is not guaranteed to be unique.
	ReferenceId *string `json:"reference_id,omitempty"`

	// The reason for tax exemption. This is only used if the event type is tax exempt.
	// If the event type is not tax exempt, this field is ignored.
	TaxExemptionReason *string `json:"tax_exemption_reason,omitempty"`

	// The event type's image URL as thumb (low res)
	Thumb      *string              `json:"thumb,omitempty"`
	Title      *string              `json:"title,omitempty"`
	UpdatedAt  *time.Time           `json:"updated_at,omitempty"`
	Variations *EventTypeVariations `json:"variations,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Vat *ExpandableVAT `json:"vat,omitempty"`
}

// How event is overbookable
type EventTypeOverbookable string

// EventTypeActivities defines model for EventTypeActivities.
type EventTypeActivities []EventTypeActivity

// EventTypeActivity defines model for EventTypeActivity.
type EventTypeActivity struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor       `json:"created_by,omitempty"`
	Field     EventTypeActivityField `json:"field"`
	Id        *string                `json:"id,omitempty"`
	NewValue  *MultiValue            `json:"new_value,omitempty"`
	OldValue  *MultiValue            `json:"old_value,omitempty"`
	Type      *EventTypeActivityType `json:"type,omitempty"`
}

// EventTypeActivityField defines model for EventTypeActivity.Field.
type EventTypeActivityField string

// EventTypeActivityType defines model for EventTypeActivity.Type.
type EventTypeActivityType string

// EventTypeCategories defines model for EventTypeCategories.
type EventTypeCategories []EventTypeCategory

// EventTypeCategory defines model for EventTypeCategory.
type EventTypeCategory struct {
	Group string `json:"group"`
	Id    string `json:"id"`
	Name  string `json:"name"`
}

// EventTypeCategoryGroup defines model for EventTypeCategoryGroup.
type EventTypeCategoryGroup struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// EventTypeCategoryGroups defines model for EventTypeCategoryGroups.
type EventTypeCategoryGroups []EventTypeCategoryGroup

// EventTypeConnections defines model for EventTypeConnections.
type EventTypeConnections struct {
	// When booking, users are prompted these booking questions and are required to fill in an answer.
	BookingQuestion *string `json:"booking_question,omitempty"`

	// For a successful booking, this message is displayed for each event type booked.
	BookingSuccessMessage *string `json:"booking_success_message,omitempty"`

	// For this event type, does the customer select the employee/space or is it selected automatically at random?
	CustomerSelects *EventTypeConnectionsCustomerSelects `json:"customer_selects,omitempty"`
	Hidden          *bool                                `json:"hidden,omitempty"`

	// Does this service need an employee, space, both or neither?
	ServiceNeeds *EventTypeConnectionsServiceNeeds `json:"service_needs,omitempty"`
}

// For this event type, does the customer select the employee/space or is it selected automatically at random?
type EventTypeConnectionsCustomerSelects string

// Does this service need an employee, space, both or neither?
type EventTypeConnectionsServiceNeeds string

// EventTypeField defines model for EventTypeField.
type EventTypeField string

// EventTypeFields defines model for EventTypeFields.
type EventTypeFields []EventTypeField

// EventTypeGroup defines model for EventTypeGroup.
type EventTypeGroup struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company *ExpandableCompany `json:"company,omitempty"`
	Id      *string            `json:"id,omitempty"`

	// Whether this is the default group for event types that do not have a group.
	IsDefaultGroup *bool `json:"is_default_group,omitempty"`

	// Used to control order in list hierarchy.
	Order             *int32                       `json:"order,omitempty"`
	OrderedEventTypes *OrderedExpandableEventTypes `json:"ordered_event_types,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	ParentEventTypeGroup *ExpandableEventTypeGroup `json:"parent_event_type_group,omitempty"`
	Title                *string                   `json:"title,omitempty"`
}

// EventTypeGroups defines model for EventTypeGroups.
type EventTypeGroups []EventTypeGroup

// EventTypePreference defines model for EventTypePreference.
type EventTypePreference struct {
	CustomDuration *CustomDuration `json:"custom_duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType *ExpandableEventType `json:"event_type,omitempty"`

	// If true, resource can set custom duration for this event type.
	HasCustomDuration *bool `json:"has_custom_duration,omitempty"`

	// If true, resource can not service this event type.
	Skip *bool `json:"skip,omitempty"`
}

// EventTypePreferences defines model for EventTypePreferences.
type EventTypePreferences []EventTypePreference

// EventTypePriceRange defines model for EventTypePriceRange.
type EventTypePriceRange struct {
	Currency *string  `json:"currency,omitempty"`
	Max      *float64 `json:"max,omitempty"`
	Min      *float64 `json:"min,omitempty"`
}

// EventTypePriceRanges defines model for EventTypePriceRanges.
type EventTypePriceRanges []EventTypePriceRange

// EventTypeVariation defines model for EventTypeVariation.
type EventTypeVariation struct {
	// [Expandable](#section/Expandable-attributes)
	CustomerGroup *ExpandableCustomerGroup   `json:"customer_group,omitempty"`
	Id            *string                    `json:"id,omitempty"`
	Label         *string                    `json:"label,omitempty"`
	Prices        *[]EventTypeVariationPrice `json:"prices,omitempty"`
}

// EventTypeVariationPrice defines model for EventTypeVariationPrice.
type EventTypeVariationPrice struct {
	Amount   *float64 `json:"amount,omitempty"`
	Currency *string  `json:"currency,omitempty"`
}

// EventTypeVariations defines model for EventTypeVariations.
type EventTypeVariations []EventTypeVariation

// EventTypes defines model for EventTypes.
type EventTypes []EventType

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type EventUpdateBehavior struct {
	// Whether to notify customer about the event update.
	//
	// When true, the customer will receive an email and push notification about the event update.
	//
	// When false, the customer will not receive any notification about the event update.
	Notify *bool `json:"notify,omitempty"`

	// What events to update when updating an event that is a part of a recurring event.
	//
	// - `detach` - Only update the referenced event and detach it from the series
	// - `inplace` - Only update the referenced event but keep it a part of the series
	// - `future` - Update referenced event and all events in the series after the referenced event
	Type *EventUpdateBehaviorType `json:"type,omitempty"`
}

// What events to update when updating an event that is a part of a recurring event.
//
// - `detach` - Only update the referenced event and detach it from the series
// - `inplace` - Only update the referenced event but keep it a part of the series
// - `future` - Update referenced event and all events in the series after the referenced event
type EventUpdateBehaviorType string

// Events defines model for Events.
type Events []Event

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableActor struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableApp struct {
	union json.RawMessage
}

// ExpandableCompanies defines model for ExpandableCompanies.
type ExpandableCompanies []ExpandableCompany

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableCompany struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableCustomer struct {
	union json.RawMessage
}

// [Expandable](#section/Expandable-attributes)
type ExpandableCustomerGroup struct {
	union json.RawMessage
}

// Customer groups that the customer belongs to.
type ExpandableCustomerGroups []ExpandableCustomerGroup

// ExpandableCustomers defines model for ExpandableCustomers.
type ExpandableCustomers []ExpandableCustomer

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableEmployee struct {
	union json.RawMessage
}

// ExpandableEmployees defines model for ExpandableEmployees.
type ExpandableEmployees []ExpandableEmployee

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableEnterprise struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableEvent struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableEventType struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableEventTypeCategory struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableEventTypeCategoryGroup struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableEventTypeGroup struct {
	union json.RawMessage
}

// ExpandableEventTypes defines model for ExpandableEventTypes.
type ExpandableEventTypes []ExpandableEventType

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableGoogleCalendarConnection struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableIssuer struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableLineItem struct {
	union json.RawMessage
}

// ExpandableLineItems defines model for ExpandableLineItems.
type ExpandableLineItems []ExpandableLineItem

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableMarketplaceUser struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandablePayment struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableProduct struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableResource struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableResourceGroup struct {
	union json.RawMessage
}

// ExpandableResources defines model for ExpandableResources.
type ExpandableResources []ExpandableResource

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableRole struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableSale struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableSettlementAccount struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableSpace struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableSubtransaction struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableTransaction struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableVAT struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableVoucher struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableVoucherTemplate struct {
	union json.RawMessage
}

// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
type ExpandableWebhook struct {
	union json.RawMessage
}

// FiscalizationOnboarding defines model for FiscalizationOnboarding.
type FiscalizationOnboarding struct {
	Data *FiscalizationOnboardingData `json:"data,omitempty"`
}

// FiscalizationOnboardingData defines model for FiscalizationOnboardingData.
type FiscalizationOnboardingData struct {
	union json.RawMessage
}

// FiscalizationOnboardingDataSaltPay defines model for FiscalizationOnboardingDataSaltPay.
type FiscalizationOnboardingDataSaltPay struct {
	FiscalCode *string                      `json:"fiscal_code,omitempty"`
	Provider   FiscalizationProviderSaltPay `json:"provider"`

	// The Saltpay company that is being onboarded.
	SaltpayCompany *string `json:"saltpay_company,omitempty"`

	// The Saltpay store that is being onboarded, the store must be under the specified company.
	SaltpayStore           *string   `json:"saltpay_store,omitempty"`
	Series                 *[]string `json:"series,omitempty"`
	TaxCredentialsPassword *string   `json:"tax_credentials_password,omitempty"`
	TaxCredentialsUsername *string   `json:"tax_credentials_username,omitempty"`
}

// FiscalizationProviderSaltPay defines model for FiscalizationProviderSaltPay.
type FiscalizationProviderSaltPay string

// FiscalizationRecord defines model for FiscalizationRecord.
type FiscalizationRecord struct {
	Company   *string                  `json:"company,omitempty"`
	CreatedAt *time.Time               `json:"created_at,omitempty"`
	Data      *FiscalizationRecordData `json:"data,omitempty"`
	Id        *string                  `json:"id,omitempty"`
	UpdatedAt *time.Time               `json:"updated_at,omitempty"`
}

// FiscalizationRecordData defines model for FiscalizationRecordData.
type FiscalizationRecordData struct {
	union json.RawMessage
}

// FiscalizationRecordDataSaltPay defines model for FiscalizationRecordDataSaltPay.
type FiscalizationRecordDataSaltPay struct {
	ExternalId *string                      `json:"external_id,omitempty"`
	Provider   FiscalizationProviderSaltPay `json:"provider"`
}

// FiscalizeTransactionError defines model for FiscalizeTransactionError.
type FiscalizeTransactionError struct {
	// The error code. Only populated for certain errors.
	Code    FiscalizeTransactionErrorCode `json:"code"`
	Message string                        `json:"message"`
}

// The error code. Only populated for certain errors.
type FiscalizeTransactionErrorCode string

// GoogleCalendarConnection defines model for GoogleCalendarConnection.
type GoogleCalendarConnection struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// Whether blocked times should be synced from Noona to Google.
	SyncBlockedTimesToGoogle *bool `json:"sync_blocked_times_to_google,omitempty"`

	// Whether blocked times should be synced from Google to Noona.
	SyncBlockedTimesToNoona *bool `json:"sync_blocked_times_to_noona,omitempty"`

	// Whether events should be synced between Noona and Google Calendar.
	SyncEvents *bool `json:"sync_events,omitempty"`
}

// GroupProduct defines model for GroupProduct.
type GroupProduct struct {
	Id *string `json:"id,omitempty"`

	// Used to control order in list hierarchy.
	Order *int32 `json:"order,omitempty"`
}

// Holiday defines model for Holiday.
type Holiday struct {
	Date string `json:"date"`
	Name string `json:"name"`
}

// Holidays defines model for Holidays.
type Holidays []Holiday

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type HolidaysFilter struct {
	// Only return reservations where starts_at is after this timestamp.
	From time.Time `json:"from"`

	// Only return reservations where starts_at is before this timestamp.
	To time.Time `json:"to"`
}

// ID defines model for ID.
type ID string

// Image defines model for Image.
type Image struct {
	Image    *string `json:"image,omitempty"`
	PublicId *string `json:"public_id,omitempty"`
	Thumb    *string `json:"thumb,omitempty"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type InvoicesFilter struct {
	// Filter by invoice payment status
	Status *[]InvoicesFilterStatus `json:"status,omitempty"`
}

// InvoicesFilterStatus defines model for InvoicesFilter.Status.
type InvoicesFilterStatus string

// Issuer defines model for Issuer.
type Issuer struct {
	// Business Identification Number
	Bin *string `json:"bin,omitempty"`

	// Extra information to include on invoices.
	ExtraInvoiceInfo *string `json:"extra_invoice_info,omitempty"`

	// ID of company or employee
	Id           *string     `json:"id,omitempty"`
	LegalAddress *string     `json:"legal_address,omitempty"`
	Name         *string     `json:"name,omitempty"`
	Other        *string     `json:"other,omitempty"`
	Type         *IssuerType `json:"type,omitempty"`

	// VAT Identification Number
	VatId *string `json:"vat_id,omitempty"`
}

// IssuerType defines model for Issuer.Type.
type IssuerType string

// Issuers defines model for Issuers.
type Issuers []Issuer

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type IssuersFilter struct {
	// Only return Issuers that can be attached to a terminal, from the calling user's perspective.
	TerminalAttachable *bool `json:"terminal_attachable,omitempty"`
}

// LineItem defines model for LineItem.
type LineItem struct {
	// ID of the employee that booked the service on the appointment linked to the transaction. This is used to calculate commissions for the employee that booked the service.
	BookedBy *string `json:"booked_by,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company *ExpandableCompany `json:"company,omitempty"`

	// Discount percentage
	Discount *float64 `json:"discount,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`
	Event    *string             `json:"event,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType *ExpandableEventType `json:"event_type,omitempty"`
	Id        *string              `json:"id,omitempty"`

	// True if the item was returned. Quantity and all amounts are positive for returning items.
	IsReturning *bool `json:"is_returning,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Product  *ExpandableProduct `json:"product,omitempty"`
	Quantity *int32             `json:"quantity,omitempty"`

	// The VAT exemption reason when the VAT amount is equal to 0
	TaxExemptionReason *string    `json:"tax_exemption_reason,omitempty"`
	Title              *string    `json:"title,omitempty"`
	Transaction        *string    `json:"transaction,omitempty"`
	UnitPrice          *UnitPrice `json:"unit_price,omitempty"`
	VariationId        *string    `json:"variation_id,omitempty"`

	// The VAT ratio
	VatAmount *float64 `json:"vat_amount,omitempty"`

	// The voucher object is only returned when the line item is a voucher template.
	//
	// The voucher object is accepted and returned when the line item is an amount voucher.
	Voucher         *LineItemVoucher   `json:"voucher,omitempty"`
	VoucherTemplate *VoucherTemplateID `json:"voucher_template,omitempty"`
}

// The voucher object is only returned when the line item is a voucher template.
//
// The voucher object is accepted and returned when the line item is an amount voucher.
type LineItemVoucher struct {
	// 6 uppercase letters / numbers
	Code *string              `json:"code,omitempty"`
	Data *LineItemVoucherData `json:"data,omitempty"`
	Id   *string              `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Voucher *ExpandableVoucher `json:"voucher,omitempty"`
}

// LineItemVoucherData defines model for LineItemVoucherData.
type LineItemVoucherData struct {
	union json.RawMessage
}

// LineItemVoucherDataAmount defines model for LineItemVoucherDataAmount.
type LineItemVoucherDataAmount struct {
	Amount *float64                      `json:"amount,omitempty"`
	Type   LineItemVoucherDataAmountType `json:"type"`
}

// LineItemVoucherDataAmountType defines model for LineItemVoucherDataAmount.Type.
type LineItemVoucherDataAmountType string

// LineItemVoucherDataService defines model for LineItemVoucherDataService.
type LineItemVoucherDataService struct {
	Amount        *float64                       `json:"amount,omitempty"`
	EventTypeId   *string                        `json:"event_type_id,omitempty"`
	SessionsTotal *int32                         `json:"sessions_total,omitempty"`
	TemplateId    *string                        `json:"template_id,omitempty"`
	Type          LineItemVoucherDataServiceType `json:"type"`
	Value         *float64                       `json:"value,omitempty"`
}

// LineItemVoucherDataServiceType defines model for LineItemVoucherDataService.Type.
type LineItemVoucherDataServiceType string

// LineItems defines model for LineItems.
type LineItems []LineItem

// Locale defines model for Locale.
type Locale struct {
	MessagingLanguage *string `json:"messaging_language,omitempty"`
	UiLanguage        *string `json:"ui_language,omitempty"`
}

// Location defines model for Location.
type Location struct {
	Country          *Country        `json:"country,omitempty"`
	FormattedAddress *string         `json:"formatted_address,omitempty"`
	LatLng           *LocationLatLng `json:"lat_lng,omitempty"`
	TimeZone         *string         `json:"time_zone,omitempty"`
}

// LocationLatLng defines model for LocationLatLng.
type LocationLatLng struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
}

// MarketplaceUser defines model for MarketplaceUser.
type MarketplaceUser struct {
	Email *string `json:"email,omitempty"`
	Id    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
}

// MarketplaceUsers defines model for MarketplaceUsers.
type MarketplaceUsers []MarketplaceUser

// MaxTotalPaxRule defines model for MaxTotalPaxRule.
type MaxTotalPaxRule struct {
	// End time within the day
	EndsAt      *string `json:"ends_at,omitempty"`
	MaxTotalPax int32   `json:"max_total_pax"`

	// Start time within the day
	StartsAt *string             `json:"starts_at,omitempty"`
	Type     MaxTotalPaxRuleType `json:"type"`
}

// MaxTotalPaxRuleType defines model for MaxTotalPaxRule.Type.
type MaxTotalPaxRuleType string

// Memo defines model for Memo.
type Memo struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	Content   *string            `json:"content,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Date      *string            `json:"date,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee  *ExpandableEmployee `json:"employee,omitempty"`
	Id        *string             `json:"id,omitempty"`
	Title     *string             `json:"title,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// MemoCreate defines model for MemoCreate.
type MemoCreate struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	Content   *string           `json:"content,omitempty"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`
	Date      *string           `json:"date,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee  *ExpandableEmployee `json:"employee,omitempty"`
	Id        *string             `json:"id,omitempty"`
	Title     string              `json:"title"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// MemoCreateOverrides defines model for MemoCreateOverrides.
type MemoCreateOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company ExpandableCompany `json:"company"`
	Content *string           `json:"content,omitempty"`
	Date    *string           `json:"date,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`
	Title    string              `json:"title"`
}

// Filtering options for Memos
type MemoFilter struct {
	// Filter by employees
	Employees *[]string `json:"employees,omitempty"`
}

// MemoResponse defines model for MemoResponse.
type MemoResponse struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	Content   *string           `json:"content,omitempty"`
	CreatedAt time.Time         `json:"created_at"`
	Date      *string           `json:"date,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee  *ExpandableEmployee `json:"employee,omitempty"`
	Id        string              `json:"id"`
	Title     string              `json:"title"`
	UpdatedAt time.Time           `json:"updated_at"`
}

// MemoResponseOverrides defines model for MemoResponseOverrides.
type MemoResponseOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	Content   *string           `json:"content,omitempty"`
	CreatedAt time.Time         `json:"created_at"`
	Date      *string           `json:"date,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee  *ExpandableEmployee `json:"employee,omitempty"`
	Id        string              `json:"id"`
	Title     string              `json:"title"`
	UpdatedAt time.Time           `json:"updated_at"`
}

// MemoUpdate defines model for MemoUpdate.
type MemoUpdate struct {
	Company   *interface{} `json:"company,omitempty"`
	Content   *string      `json:"content,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`
	Date      *string      `json:"date,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee  *ExpandableEmployee `json:"employee,omitempty"`
	Id        *string             `json:"id,omitempty"`
	Title     *string             `json:"title,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// MemoUpdateOverrides defines model for MemoUpdateOverrides.
type MemoUpdateOverrides struct {
	Company *interface{} `json:"company,omitempty"`
	Content *string      `json:"content,omitempty"`
	Date    *string      `json:"date,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`
	Title    *string             `json:"title,omitempty"`
}

// Memos defines model for Memos.
type Memos []Memo

// MemosResponse defines model for MemosResponse.
type MemosResponse []MemoResponse

// Notice defines model for Notice.
type Notice struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Configures whether the notice can be dismissed by the user.
	Dismissable *bool `json:"dismissable,omitempty"`

	// Optionally configure a timestamp for when the notice should expire and stop being visible in Noona HQ.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// The message to be displayed in Noona HQ.
	Message   string     `json:"message"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Configures the visual appearance of the notice in Noona HQ.
	Variant NoticeVariant `json:"variant"`
}

// Configures the visual appearance of the notice in Noona HQ.
type NoticeVariant string

// Notices defines model for Notices.
type Notices []Notice

// Notification defines model for Notification.
type Notification struct {
	union json.RawMessage
}

// NotificationCreate defines model for NotificationCreate.
type NotificationCreate struct {
	Company  string `json:"company"`
	Employee string `json:"employee"`
	Message  string `json:"message"`
	Title    string `json:"title"`
}

// NotificationEvent defines model for NotificationEvent.
type NotificationEvent struct {
	// Provided by customers when they decline through the marketplace.
	CancelReason *string    `json:"cancel_reason,omitempty"`
	Company      *string    `json:"company,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	Customer     *string    `json:"customer,omitempty"`

	// A comment that the customer included during a marketplace booking.
	CustomerComment *string `json:"customer_comment,omitempty"`
	CustomerName    *string `json:"customer_name,omitempty"`

	// Duration of event in minutes
	Duration     *int32  `json:"duration,omitempty"`
	Employee     *string `json:"employee,omitempty"`
	EmployeeName *string `json:"employee_name,omitempty"`

	// The event which the notification is for.
	Event *string `json:"event,omitempty"`

	// The names of the event types
	EventTypeNames *[]string `json:"event_type_names,omitempty"`
	Id             *string   `json:"id,omitempty"`

	// True if the customer is new
	NewCustomer *bool `json:"new_customer,omitempty"`

	// The amount of the payment if the event has a payment associated with it.
	PaymentAmount *float64 `json:"payment_amount,omitempty"`

	// The currency of the payment if the event has a payment associated with it.
	PaymentCurrency *string        `json:"payment_currency,omitempty"`
	PaymentStatus   *PaymentStatus `json:"payment_status,omitempty"`

	// The original date and time of the event
	RescheduledFrom *time.Time `json:"rescheduled_from,omitempty"`

	// The names of the resources that are booked for the event
	ResourceNames *[]string `json:"resource_names,omitempty"`

	// The resources that are booked for the event
	Resources *[]string `json:"resources,omitempty"`
	Space     *string   `json:"space,omitempty"`
	SpaceName *string   `json:"space_name,omitempty"`

	// Start time of event
	StartsAt  *time.Time              `json:"starts_at,omitempty"`
	Status    NotificationEventStatus `json:"status"`
	Type      NotificationEventType   `json:"type"`
	UpdatedAt *time.Time              `json:"updated_at,omitempty"`
}

// NotificationEventStatus defines model for NotificationEvent.Status.
type NotificationEventStatus string

// NotificationEventType defines model for NotificationEvent.Type.
type NotificationEventType string

// NotificationGeneric defines model for NotificationGeneric.
type NotificationGeneric struct {
	CreatedAt *time.Time              `json:"created_at,omitempty"`
	Employee  *string                 `json:"employee,omitempty"`
	Icon      *NotificationIcon       `json:"icon,omitempty"`
	Id        *string                 `json:"id,omitempty"`
	Message   *string                 `json:"message,omitempty"`
	Priority  *int32                  `json:"priority,omitempty"`
	Title     string                  `json:"title"`
	Type      NotificationGenericType `json:"type"`
	UpdatedAt *time.Time              `json:"updated_at,omitempty"`

	// A valid URL path for HQ which is redirected to when the notification is clicked
	Url *string `json:"url,omitempty"`
}

// NotificationGenericType defines model for NotificationGeneric.Type.
type NotificationGenericType string

// NotificationIcon defines model for NotificationIcon.
type NotificationIcon struct {
	Icon        *string                      `json:"icon,omitempty"`
	IconColor   *string                      `json:"icon_color,omitempty"`
	IconText    *string                      `json:"icon_text,omitempty"`
	IconVariant *NotificationIconIconVariant `json:"icon_variant,omitempty"`
}

// NotificationIconIconVariant defines model for NotificationIcon.IconVariant.
type NotificationIconIconVariant string

// NotificationLegacy defines model for NotificationLegacy.
type NotificationLegacy struct {
	Company   *string    `json:"company,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Date      *string    `json:"date,omitempty"`
	Employee  *string    `json:"employee,omitempty"`

	// The event which the notification is for.
	Event   *string           `json:"event,omitempty"`
	Icon    *NotificationIcon `json:"icon,omitempty"`
	Id      *string           `json:"id,omitempty"`
	Message *string           `json:"message,omitempty"`

	// The amount of the payment if the event has a payment associated with it.
	PaymentAmount *float64 `json:"payment_amount,omitempty"`

	// The currency of the payment if the event has a payment associated with it.
	PaymentCurrency *string                `json:"payment_currency,omitempty"`
	PaymentStatus   *PaymentStatus         `json:"payment_status,omitempty"`
	Priority        *int32                 `json:"priority,omitempty"`
	SideMessage     *string                `json:"side_message,omitempty"`
	Space           *string                `json:"space,omitempty"`
	Title           *string                `json:"title,omitempty"`
	Type            NotificationLegacyType `json:"type"`
	UpdatedAt       *time.Time             `json:"updated_at,omitempty"`
}

// NotificationLegacyType defines model for NotificationLegacy.Type.
type NotificationLegacyType string

// NotificationPreferences defines model for NotificationPreferences.
type NotificationPreferences struct {
	Email *bool `json:"email,omitempty"`
	Push  *bool `json:"push,omitempty"`
	Sms   *bool `json:"sms,omitempty"`
}

// NotificationSurvey defines model for NotificationSurvey.
type NotificationSurvey struct {
	CreatedAt *time.Time             `json:"created_at,omitempty"`
	Employee  *string                `json:"employee,omitempty"`
	Id        *string                `json:"id,omitempty"`
	Priority  *int32                 `json:"priority,omitempty"`
	Type      NotificationSurveyType `json:"type"`
	UpdatedAt *time.Time             `json:"updated_at,omitempty"`
}

// NotificationSurveyType defines model for NotificationSurvey.Type.
type NotificationSurveyType string

// NotificationWaitlistEntry defines model for NotificationWaitlistEntry.
type NotificationWaitlistEntry struct {
	Company      *string    `json:"company,omitempty"`
	CreatedAt    *time.Time `json:"created_at,omitempty"`
	Customer     *string    `json:"customer,omitempty"`
	CustomerName *string    `json:"customer_name,omitempty"`
	Employee     *string    `json:"employee,omitempty"`
	EmployeeName *string    `json:"employee_name,omitempty"`

	// The names of the event types
	EventTypeNames *[]string `json:"event_type_names,omitempty"`

	// The time when the waitlist entry expires
	ExpiresAt     *time.Time                    `json:"expires_at,omitempty"`
	Id            *string                       `json:"id,omitempty"`
	Type          NotificationWaitlistEntryType `json:"type"`
	UpdatedAt     *time.Time                    `json:"updated_at,omitempty"`
	WaitlistEntry *string                       `json:"waitlist_entry,omitempty"`
}

// NotificationWaitlistEntryType defines model for NotificationWaitlistEntry.Type.
type NotificationWaitlistEntryType string

// Notifications defines model for Notifications.
type Notifications []Notification

// OAuthConsent defines model for OAuthConsent.
type OAuthConsent struct {
	ClientId     string                   `json:"client_id"`
	CompanyId    string                   `json:"company_id"`
	RedirectUri  string                   `json:"redirect_uri"`
	ResponseType OAuthConsentResponseType `json:"response_type"`
	Scopes       OAuthScopes              `json:"scopes"`
	State        *string                  `json:"state,omitempty"`
}

// OAuthConsentResponseType defines model for OAuthConsent.ResponseType.
type OAuthConsentResponseType string

// OAuthConsentResponse defines model for OAuthConsentResponse.
type OAuthConsentResponse struct {
	RedirectUri *string `json:"redirect_uri,omitempty"`
}

// Public key in the JWK format to validate the JWT signature of ID tokens.
type OAuthPublicKey struct {
	Alg string `json:"alg"`

	// base64-encoded-exponent
	E   string `json:"e"`
	Kid string `json:"kid"`
	Kty string `json:"kty"`

	// base64-encoded-modulus
	N   string `json:"n"`
	Use string `json:"use"`
}

// OAuthScope defines model for OAuthScope.
type OAuthScope string

// OAuthScopes defines model for OAuthScopes.
type OAuthScopes []OAuthScope

// OAuthToken defines model for OAuthToken.
type OAuthToken struct {
	AccessToken  *string    `json:"access_token,omitempty"`
	ExpiresAt    *time.Time `json:"expires_at,omitempty"`
	RefreshToken *string    `json:"refresh_token,omitempty"`
	TokenType    *string    `json:"token_type,omitempty"`
}

// OAuthTokenRequest defines model for OAuthTokenRequest.
type OAuthTokenRequest struct {
	Code         *string                    `json:"code,omitempty"`
	GrantType    OAuthTokenRequestGrantType `json:"grant_type"`
	RefreshToken *string                    `json:"refresh_token,omitempty"`
}

// OAuthTokenRequestGrantType defines model for OAuthTokenRequest.GrantType.
type OAuthTokenRequestGrantType string

// OnlineBookingsRule defines model for OnlineBookingsRule.
type OnlineBookingsRule struct {
	Employees            *[]string                               `json:"employees,omitempty"`
	EmployeesAssociation *OnlineBookingsRuleEmployeesAssociation `json:"employees_association,omitempty"`
	Enabled              bool                                    `json:"enabled"`

	// End time within the day
	EndsAt                *string                                  `json:"ends_at,omitempty"`
	EventTypes            *[]string                                `json:"event_types,omitempty"`
	EventTypesAssociation *OnlineBookingsRuleEventTypesAssociation `json:"event_types_association,omitempty"`
	Resources             *[]string                                `json:"resources,omitempty"`
	ResourcesAssociation  *OnlineBookingsRuleResourcesAssociation  `json:"resources_association,omitempty"`

	// Start time within the day
	StartsAt *string                `json:"starts_at,omitempty"`
	Type     OnlineBookingsRuleType `json:"type"`
}

// OnlineBookingsRuleEmployeesAssociation defines model for OnlineBookingsRule.EmployeesAssociation.
type OnlineBookingsRuleEmployeesAssociation string

// OnlineBookingsRuleEventTypesAssociation defines model for OnlineBookingsRule.EventTypesAssociation.
type OnlineBookingsRuleEventTypesAssociation string

// OnlineBookingsRuleResourcesAssociation defines model for OnlineBookingsRule.ResourcesAssociation.
type OnlineBookingsRuleResourcesAssociation string

// OnlineBookingsRuleType defines model for OnlineBookingsRule.Type.
type OnlineBookingsRuleType string

// OpeningHour defines model for OpeningHour.
type OpeningHour struct {
	ClosesAt *string `json:"closes_at,omitempty"`
	IsClosed *bool   `json:"is_closed,omitempty"`
	OpensAt  *string `json:"opens_at,omitempty"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
//
// Date range must be less than a year.
type OpeningHourFilter struct {
	From *string `json:"from,omitempty"`
	To   *string `json:"to,omitempty"`
}

// Opening hours for the company. Array of seven (7) items, 0 being Monday and 6 Sunday. Or 0 being Sunday. Nobody really knows.
type OpeningHours []OpeningHour

// OpeningHoursResponse defines model for OpeningHoursResponse.
type OpeningHoursResponse map[string][]TimeRange

// Used to control order in list hierarchy.
type Order int32

// OrderedExpandableEventType defines model for OrderedExpandableEventType.
type OrderedExpandableEventType struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType *ExpandableEventType `json:"event_type,omitempty"`

	// Used to control order in list hierarchy.
	Order *int32 `json:"order,omitempty"`
}

// OrderedExpandableEventTypes defines model for OrderedExpandableEventTypes.
type OrderedExpandableEventTypes []OrderedExpandableEventType

// OrderedProduct defines model for OrderedProduct.
type OrderedProduct struct {
	Amount      *float64      `json:"amount,omitempty"`
	Barcode     *string       `json:"barcode,omitempty"`
	Company     *string       `json:"company,omitempty"`
	CreatedAt   *int32        `json:"created_at,omitempty"`
	Description *string       `json:"description,omitempty"`
	Id          *string       `json:"id,omitempty"`
	Image       *ProductImage `json:"image,omitempty"`

	// Set during import of products, usually an identifier from an external system.
	ImportReferenceId *string `json:"import_reference_id,omitempty"`

	// Used to control how a product group is ordered with respect to siblings.
	Order *int32 `json:"order,omitempty"`

	// List of product group ids product belongs to.
	ProductGroups *[]string `json:"product_groups,omitempty"`
	Sku           *string   `json:"sku,omitempty"`
	StockLevel    *int32    `json:"stock_level,omitempty"`

	// VAT exemption reason when having a VAT amount of 0%
	TaxExemptionReason *string `json:"tax_exemption_reason,omitempty"`
	Title              *string `json:"title,omitempty"`
	UpdatedAt          *int32  `json:"updated_at,omitempty"`

	// Id of VAT to use for product
	VatId *string `json:"vat_id,omitempty"`
}

// POSSettings defines model for POSSettings.
type POSSettings struct {
	// The first tab to show in the checkout flow.
	CheckoutFirstTab *POSSettingsCheckoutFirstTab `json:"checkout_first_tab,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	DefaultVat *ExpandableVAT `json:"default_vat,omitempty"`

	// Extra information to include on invoices.
	ExtraInvoiceInfo *string `json:"extra_invoice_info,omitempty"`

	// The initial invoice number for the company.
	InitialInvoiceNumber *int32 `json:"initial_invoice_number,omitempty"`

	// The kennitala for the company.
	Kennitala    *string `json:"kennitala,omitempty"`
	LegalAddress *string `json:"legal_address,omitempty"`

	// The name that will be printed on invoices.
	NameOnInvoices *string `json:"name_on_invoices,omitempty"`

	// The VAT number for the company.
	VatNumber *string `json:"vat_number,omitempty"`
}

// The first tab to show in the checkout flow.
type POSSettingsCheckoutFirstTab string

// Pagination defines model for Pagination.
type Pagination struct {
	// The maximum number of results to return.
	Limit  *int32 `json:"limit,omitempty"`
	Offset *int32 `json:"offset,omitempty"`
}

// Payment defines model for Payment.
type Payment struct {
	Amount *float64 `json:"amount,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Currency  *string            `json:"currency,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer *ExpandableCustomer `json:"customer,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Event *ExpandableEvent `json:"event,omitempty"`
	Id    *string          `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	MarketplaceUser *ExpandableMarketplaceUser `json:"marketplace_user,omitempty"`
	Reason          *PaymentReason             `json:"reason,omitempty"`

	// The name of the settlement recipient.
	SettledTo *string `json:"settled_to,omitempty"`

	// The ID of the settlement that this payment belongs to.
	Settlement *string `json:"settlement,omitempty"`

	// Indicates if the payment is settled to the employee or the company.
	//
	// If true, the payment is settled to the employee. If false, the payment is settled to the company.
	//
	// This evaluates this payment and related data as it is exactly on time of fetch. Meaning that this flag has no relevance to already settled payments.
	SettlesToEmployee *bool          `json:"settles_to_employee,omitempty"`
	Status            *PaymentStatus `json:"status,omitempty"`
	UpdatedAt         *time.Time     `json:"updated_at,omitempty"`
}

// PaymentReason defines model for Payment.Reason.
type PaymentReason string

// PaymentActivities defines model for PaymentActivities.
type PaymentActivities []PaymentActivity

// PaymentActivity defines model for PaymentActivity.
type PaymentActivity struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CreatedBy *ExpandableActor     `json:"created_by,omitempty"`
	Field     PaymentActivityField `json:"field"`
	Id        *string              `json:"id,omitempty"`
	NewValue  *MultiValue          `json:"new_value,omitempty"`
	OldValue  *MultiValue          `json:"old_value,omitempty"`
	Type      *PaymentActivityType `json:"type,omitempty"`
}

// PaymentActivityField defines model for PaymentActivity.Field.
type PaymentActivityField string

// PaymentActivityType defines model for PaymentActivity.Type.
type PaymentActivityType string

// Dynamic mapping of payment reasons to fees. Valid keys include "event", "paylink", "voucher", etc.,  representing different reasons for payments. Each key maps to a fee represented as a floating-point number.
type PaymentFees map[string]float64

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type PaymentFilter struct {
	// Deprecated: Use ListPayments endpoint to get payments for a company
	Company  *string          `json:"company,omitempty"`
	From     *time.Time       `json:"from,omitempty"`
	Statuses *[]PaymentStatus `json:"statuses,omitempty"`
	To       *time.Time       `json:"to,omitempty"`
}

// PaymentIntent defines model for PaymentIntent.
type PaymentIntent struct {
	// Amount in cents to be authorized for 3DS flow
	Amount    *int32 `json:"amount,omitempty"`
	CreatedAt *int64 `json:"created_at,omitempty"`

	// Currency code (ISO 4217 format) for transaction
	CurrencyCode     *string              `json:"currency_code,omitempty"`
	CustomerId       *string              `json:"customer_id,omitempty"`
	ExpiresAt        *int64               `json:"expires_at,omitempty"`
	Gateway          *string              `json:"gateway,omitempty"`
	GatewayAccountId *string              `json:"gateway_account_id,omitempty"`
	Id               *string              `json:"id,omitempty"`
	ModifiedAt       *int64               `json:"modified_at,omitempty"`
	ResourceVersion  *int64               `json:"resource_version,omitempty"`
	Status           *PaymentIntentStatus `json:"status,omitempty"`
	UpdatedAt        *int64               `json:"updated_at,omitempty"`
}

// PaymentIntentStatus defines model for PaymentIntent.Status.
type PaymentIntentStatus string

// PaymentMethod defines model for PaymentMethod.
type PaymentMethod struct {
	// If true the payment method is hidden from the POS
	Hidden      *bool   `json:"hidden,omitempty"`
	IconName    *string `json:"icon_name,omitempty"`
	Id          *string `json:"id,omitempty"`
	LocaleKey   *string `json:"locale_key,omitempty"`
	Order       *int32  `json:"order,omitempty"`
	Title       *string `json:"title,omitempty"`
	UseTerminal *bool   `json:"use_terminal,omitempty"`
}

// PaymentMethods defines model for PaymentMethods.
type PaymentMethods []PaymentMethod

// PaymentReceiptRecipient defines model for PaymentReceiptRecipient.
type PaymentReceiptRecipient struct {
	Email *string `json:"email,omitempty"`
}

// PaymentSettings defines model for PaymentSettings.
type PaymentSettings struct {
	OnboardedAt *time.Time `json:"onboarded_at,omitempty"`

	// Is full payment optional?
	//
	// `true` - on_location_payment_amount can optionally be fully paid.
	//
	// `false` - no optional payment.
	OptionalFullPayment *bool `json:"optional_full_payment,omitempty"`

	// Is pre-payment enabled at all for the company?
	//
	// `true` - Other flags have meaning.
	//
	// `false` - Other flags are ignored.
	PrePaymentEnabled *bool `json:"pre_payment_enabled,omitempty"`

	// How much of the total price must be paid in advance in %.
	PrePaymentRatio *int32 `json:"pre_payment_ratio,omitempty"`

	// Is any upfront payment required?
	//
	// `true` - pre_payment_ratio is used to indicate how much.
	//
	// `false` - pre_payment_ratio is ignored.
	PrePaymentRequired *bool `json:"pre_payment_required,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	SettlementAccount *ExpandableSettlementAccount `json:"settlement_account,omitempty"`
}

// PaymentStatus defines model for PaymentStatus.
type PaymentStatus string

// Payments defines model for Payments.
type Payments []Payment

// PowerupPostBody defines model for PowerupPostBody.
type PowerupPostBody struct {
	Product *PowerupPostBodyProduct `json:"product,omitempty"`
}

// PowerupPostBodyProduct defines model for PowerupPostBody.Product.
type PowerupPostBodyProduct string

// PowerupSubscription defines model for PowerupSubscription.
type PowerupSubscription struct {
	AutoCloseInvoices *bool                            `json:"auto_close_invoices,omitempty"`
	CancelReason      *PowerupSubscriptionCancelReason `json:"cancel_reason,omitempty"`
	CancelledAt       *time.Time                       `json:"cancelled_at,omitempty"`
	ChargedItems      *ChargedBillingItems             `json:"charged_items,omitempty"`
	Coupons           *SubscriptionCoupons             `json:"coupons,omitempty"`
	CreatedAt         *time.Time                       `json:"created_at,omitempty"`
	CurrencyCode      *string                          `json:"currency_code,omitempty"`
	CurrentTermEnd    *time.Time                       `json:"current_term_end,omitempty"`
	CurrentTermStart  *time.Time                       `json:"current_term_start,omitempty"`
	Customer          *string                          `json:"customer,omitempty"`
	Deleted           *bool                            `json:"deleted,omitempty"`
	Discounts         *SubscriptionDiscounts           `json:"discounts,omitempty"`
	DueInvoicesCount  *int32                           `json:"due_invoices_count,omitempty"`
	DueSince          *time.Time                       `json:"due_since,omitempty"`
	ExchangeRate      *float64                         `json:"exchange_rate,omitempty"`
	Id                *string                          `json:"id,omitempty"`
	NextBillingAt     *time.Time                       `json:"next_billing_at,omitempty"`
	StartedAt         *time.Time                       `json:"started_at,omitempty"`
	Status            *PowerupSubscriptionStatus       `json:"status,omitempty"`
	SubscriptionItems *SubscriptionItems               `json:"subscription_items,omitempty"`
	TotalDues         *int32                           `json:"total_dues,omitempty"`

	// Start of the trial period for the subscription. Presence of this value for future subscription implies the subscription will go into in_trial state when it starts.
	TrialStart *time.Time `json:"trial_start,omitempty"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`
}

// PowerupSubscriptionCancelReason defines model for PowerupSubscription.CancelReason.
type PowerupSubscriptionCancelReason string

// PowerupSubscriptionStatus defines model for PowerupSubscription.Status.
type PowerupSubscriptionStatus string

// Price defines model for Price.
type Price struct {
	Amount     *float64 `json:"amount,omitempty"`
	Title      *string  `json:"title,omitempty"`
	TrialUnits *int32   `json:"trial_units,omitempty"`
}

// Pricing defines model for Pricing.
type Pricing struct {
	CountryCode *string  `json:"country_code,omitempty"`
	Currency    *string  `json:"currency,omitempty"`
	Prices      *[]Price `json:"prices,omitempty"`
}

// PricingCalculation defines model for PricingCalculation.
type PricingCalculation struct {
	// Price per month
	Amount   *float64 `json:"amount,omitempty"`
	Currency *string  `json:"currency,omitempty"`

	// Price per sms
	Sms *float64 `json:"sms,omitempty"`
}

// Product defines model for Product.
type Product struct {
	Amount      *float64      `json:"amount,omitempty"`
	Barcode     *string       `json:"barcode,omitempty"`
	Company     *string       `json:"company,omitempty"`
	CreatedAt   *int32        `json:"created_at,omitempty"`
	Description *string       `json:"description,omitempty"`
	Id          *string       `json:"id,omitempty"`
	Image       *ProductImage `json:"image,omitempty"`

	// Set during import of products, usually an identifier from an external system.
	ImportReferenceId *string `json:"import_reference_id,omitempty"`

	// List of product group ids product belongs to.
	ProductGroups *[]string `json:"product_groups,omitempty"`
	Sku           *string   `json:"sku,omitempty"`
	StockLevel    *int32    `json:"stock_level,omitempty"`

	// VAT exemption reason when having a VAT amount of 0%
	TaxExemptionReason *string `json:"tax_exemption_reason,omitempty"`
	Title              *string `json:"title,omitempty"`
	UpdatedAt          *int32  `json:"updated_at,omitempty"`

	// Id of VAT to use for product
	VatId *string `json:"vat_id,omitempty"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type ProductFilter struct {
	Barcode *string `json:"barcode,omitempty"`
}

// ProductGroup defines model for ProductGroup.
type ProductGroup struct {
	Color         *string         `json:"color,omitempty"`
	Company       *string         `json:"company,omitempty"`
	CreatedAt     *int32          `json:"created_at,omitempty"`
	Description   *string         `json:"description,omitempty"`
	GroupProducts *[]GroupProduct `json:"group_products,omitempty"`
	Id            *string         `json:"id,omitempty"`

	// If true the product group is a special, uneditable, group that contains all products that have not been added to user created product groups.
	IsDefaultGroup *bool `json:"is_default_group,omitempty"`

	// Used to control how a product group is ordered with respect to siblings.
	Order         *int32  `json:"order,omitempty"`
	ParentGroupId *string `json:"parent_group_id,omitempty"`
	Title         *string `json:"title,omitempty"`
	UpdatedAt     *int32  `json:"updated_at,omitempty"`
}

// ProductGroupExpanded defines model for ProductGroupExpanded.
type ProductGroupExpanded struct {
	Color              *string                 `json:"color,omitempty"`
	Company            *string                 `json:"company,omitempty"`
	CreatedAt          *int32                  `json:"created_at,omitempty"`
	Description        *string                 `json:"description,omitempty"`
	GroupProductGroups *[]ProductGroupExpanded `json:"group_product_groups,omitempty"`
	GroupProducts      *[]OrderedProduct       `json:"group_products,omitempty"`
	Id                 *string                 `json:"id,omitempty"`

	// If true the product group is a special, uneditable, group that contains all products that have not been added to user created product groups.
	IsDefaultGroup *bool `json:"is_default_group,omitempty"`

	// Used to control how a product group is ordered with respect to siblings.
	Order         *int32  `json:"order,omitempty"`
	ParentGroupId *string `json:"parent_group_id,omitempty"`
	Title         *string `json:"title,omitempty"`
	UpdatedAt     *int32  `json:"updated_at,omitempty"`
}

// ProductGroupOrder defines model for ProductGroupOrder.
type ProductGroupOrder struct {
	// ID of product group.
	Id string `json:"id"`

	// Order of product group.
	Order int32 `json:"order"`
}

// ProductGroups defines model for ProductGroups.
type ProductGroups []ProductGroup

// ProductGroupsExpanded defines model for ProductGroupsExpanded.
type ProductGroupsExpanded []ProductGroupExpanded

// ProductGroupsOrder defines model for ProductGroupsOrder.
type ProductGroupsOrder []ProductGroupOrder

// ProductImage defines model for ProductImage.
type ProductImage struct {
	// Link to product image
	Thumb *string `json:"thumb,omitempty"`
}

// Products defines model for Products.
type Products []Product

// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string for recurring events and blocked times.
//
// The dtstart property is ignored, and the start time of the event/blocked time is used instead.
//
// If no until is specified, it will default to 2 years from time of creation.
//
// Until has a maximum value of 2 years from time of creation.
//
// Count can be any value, but generated events/blocked times past the 2 year mark will be ignored.
type RRuleString string

// RefundMarketplaceSaleError defines model for RefundMarketplaceSaleError.
type RefundMarketplaceSaleError struct {
	// The error code. Only populated for certain errors.
	//
	// - `payment_has_been_settled`: The payment has already been settled and cannot be refunded.
	// - `already_refunded`: The payment has already been refunded.
	// - `sale_has_been_mutated`: The sale has been mutated and cannot be refunded automatically.
	Code    *RefundMarketplaceSaleErrorCode `json:"code,omitempty"`
	Message string                          `json:"message"`
}

// The error code. Only populated for certain errors.
//
// - `payment_has_been_settled`: The payment has already been settled and cannot be refunded.
// - `already_refunded`: The payment has already been refunded.
// - `sale_has_been_mutated`: The sale has been mutated and cannot be refunded automatically.
type RefundMarketplaceSaleErrorCode string

// RequiredFields defines model for RequiredFields.
type RequiredFields struct {
	Email     *bool `json:"email,omitempty"`
	Kennitala *bool `json:"kennitala,omitempty"`
}

// Resource defines model for Resource.
type Resource struct {
	// Whether the resource is visible on the calendar
	AvailableForBookings *bool `json:"available_for_bookings,omitempty"`

	// Booking interval in minutes.
	//
	// Dictates how often customers can book events with employee or resource.
	//
	// A booking interval of 15 would render results like: `10:00`  `10:15`  `10:30`.
	//
	// A booking interval is set on the company level but can be overridden on the resource/employee level.
	BookingInterval *BookingInterval `json:"booking_interval,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company              *ExpandableCompany    `json:"company,omitempty"`
	CreatedAt            *time.Time            `json:"created_at,omitempty"`
	Description          *string               `json:"description,omitempty"`
	EventTypePreferences *EventTypePreferences `json:"event_type_preferences,omitempty"`
	Id                   *string               `json:"id,omitempty"`
	Image                *Image                `json:"image,omitempty"`

	// If true, resource is visible on the marketplace.
	Marketplace *bool `json:"marketplace,omitempty"`

	// The maximum capacity of the resource, for example how many people can occupy a table at maximum.
	MaxCapacity *int32 `json:"max_capacity,omitempty"`

	// The mininum capacity of the resource, for example how many people can occupy a table at minimum.
	MinCapacity *int32  `json:"min_capacity,omitempty"`
	Name        *string `json:"name,omitempty"`

	// The order of the resource in the list of resources on the marketplace.
	Order *int32 `json:"order,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	ResourceGroup *ExpandableResourceGroup `json:"resource_group,omitempty"`
	SubResources  *[]string                `json:"sub_resources,omitempty"`
	Type          *ResourceType            `json:"type,omitempty"`
	UpdatedAt     *time.Time               `json:"updated_at,omitempty"`
}

// ResourceGroup defines model for ResourceGroup.
type ResourceGroup struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany   `json:"company,omitempty"`
	CreatedAt *time.Time           `json:"created_at,omitempty"`
	Id        *string              `json:"id,omitempty"`
	Order     *int32               `json:"order,omitempty"`
	Resources *ExpandableResources `json:"resources,omitempty"`
	Title     *string              `json:"title,omitempty"`
	UpdatedAt *time.Time           `json:"updated_at,omitempty"`
}

// ResourceGroupCreate defines model for ResourceGroupCreate.
type ResourceGroupCreate struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany   `json:"company"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *string             `json:"id,omitempty"`
	Order     *int32              `json:"order,omitempty"`
	Resources ExpandableResources `json:"resources"`
	Title     string              `json:"title"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// ResourceGroupCreateOverrides defines model for ResourceGroupCreateOverrides.
type ResourceGroupCreateOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany   `json:"company"`
	Resources ExpandableResources `json:"resources"`
	Title     string              `json:"title"`
}

// ResourceGroupResponse defines model for ResourceGroupResponse.
type ResourceGroupResponse struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany   `json:"company"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *string             `json:"id,omitempty"`
	Order     *int32              `json:"order,omitempty"`
	Resources ExpandableResources `json:"resources"`
	Title     string              `json:"title"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// ResourceGroupResponseOverrides defines model for ResourceGroupResponseOverrides.
type ResourceGroupResponseOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany   `json:"company"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *string             `json:"id,omitempty"`
	Order     *int32              `json:"order,omitempty"`
	Resources ExpandableResources `json:"resources"`
	Title     string              `json:"title"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
}

// ResourceGroupUpdate defines model for ResourceGroupUpdate.
type ResourceGroupUpdate struct {
	Company   *interface{}         `json:"company,omitempty"`
	CreatedAt *time.Time           `json:"created_at,omitempty"`
	Id        *string              `json:"id,omitempty"`
	Order     *int32               `json:"order,omitempty"`
	Resources *ExpandableResources `json:"resources,omitempty"`
	Title     *string              `json:"title,omitempty"`
	UpdatedAt *time.Time           `json:"updated_at,omitempty"`
}

// ResourceGroupUpdateOverrides defines model for ResourceGroupUpdateOverrides.
type ResourceGroupUpdateOverrides struct {
	Company   *interface{}         `json:"company,omitempty"`
	Resources *ExpandableResources `json:"resources,omitempty"`
	Title     *string              `json:"title,omitempty"`
}

// ResourceGroups defines model for ResourceGroups.
type ResourceGroups []ResourceGroup

// ResourceGroupsResponse defines model for ResourceGroupsResponse.
type ResourceGroupsResponse []ResourceGroupResponse

// ResourceType defines model for ResourceType.
type ResourceType string

// Resources defines model for Resources.
type Resources []Resource

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type ResourcesFilter struct {
	// Filter by resource IDs
	Types *[]ResourceType `json:"types,omitempty"`
}

// Role defines model for Role.
type Role struct {
	Id    *string   `json:"id,omitempty"`
	Title *string   `json:"title,omitempty"`
	Type  *RoleType `json:"type,omitempty"`
}

// RoleType defines model for Role.Type.
type RoleType string

// Rule defines model for Rule.
type Rule struct {
	union json.RawMessage
}

// RuleEntitiesEmployees defines model for RuleEntitiesEmployees.
type RuleEntitiesEmployees struct {
	Employees            *[]string                                  `json:"employees,omitempty"`
	EmployeesAssociation *RuleEntitiesEmployeesEmployeesAssociation `json:"employees_association,omitempty"`
}

// RuleEntitiesEmployeesEmployeesAssociation defines model for RuleEntitiesEmployees.EmployeesAssociation.
type RuleEntitiesEmployeesEmployeesAssociation string

// RuleEntitiesEventTypes defines model for RuleEntitiesEventTypes.
type RuleEntitiesEventTypes struct {
	EventTypes            *[]string                                    `json:"event_types,omitempty"`
	EventTypesAssociation *RuleEntitiesEventTypesEventTypesAssociation `json:"event_types_association,omitempty"`
}

// RuleEntitiesEventTypesEventTypesAssociation defines model for RuleEntitiesEventTypes.EventTypesAssociation.
type RuleEntitiesEventTypesEventTypesAssociation string

// RuleEntitiesResources defines model for RuleEntitiesResources.
type RuleEntitiesResources struct {
	Resources            *[]string                                  `json:"resources,omitempty"`
	ResourcesAssociation *RuleEntitiesResourcesResourcesAssociation `json:"resources_association,omitempty"`
}

// RuleEntitiesResourcesResourcesAssociation defines model for RuleEntitiesResources.ResourcesAssociation.
type RuleEntitiesResourcesResourcesAssociation string

// RuleInterval defines model for RuleInterval.
type RuleInterval struct {
	// End time within the day
	EndsAt *string `json:"ends_at,omitempty"`

	// Start time within the day
	StartsAt *string `json:"starts_at,omitempty"`
}

// RuleSet defines model for RuleSet.
type RuleSet struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// The date of the rule set.
	//
	// For recurring rule sets, this is the date where the recurrance rule starts.
	Date *string `json:"date,omitempty"`

	// End time
	EndsAt *string `json:"ends_at,omitempty"`
	Id     *string `json:"id,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string.
	//
	// The dtstart property is ignored, and the date attribute of the rule set is used to define the beginnin of the reccurence.
	Rrule *string `json:"rrule,omitempty"`

	// The template that was used to create this rule set
	RuleSetTemplateId *string `json:"rule_set_template_id,omitempty"`
	Rules             *Rules  `json:"rules,omitempty"`

	// Start time
	StartsAt  *string    `json:"starts_at,omitempty"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetCreate defines model for RuleSetCreate.
type RuleSetCreate struct {
	Company   string     `json:"company"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// The date of the rule set.
	//
	// For recurring rule sets, this is the date where the recurrance rule starts.
	Date string `json:"date"`

	// End time
	EndsAt string  `json:"ends_at"`
	Id     *string `json:"id,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string.
	//
	// The dtstart property is ignored, and the date attribute of the rule set is used to define the beginnin of the reccurence.
	Rrule *string `json:"rrule,omitempty"`

	// The template that was used to create this rule set
	RuleSetTemplateId *string `json:"rule_set_template_id,omitempty"`
	Rules             *Rules  `json:"rules,omitempty"`

	// Start time
	StartsAt  string     `json:"starts_at"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetCreateOverrides defines model for RuleSetCreateOverrides.
type RuleSetCreateOverrides struct {
	Company string `json:"company"`

	// The date of the rule set.
	//
	// For recurring rule sets, this is the date where the recurrance rule starts.
	Date string `json:"date"`

	// End time
	EndsAt string `json:"ends_at"`

	// Start time
	StartsAt string `json:"starts_at"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type RuleSetFilter struct {
	// Expand recurring rule sets into individual rule sets.
	//
	// From/To must also be set for expansions to take place.
	ExpandRecurring *bool   `json:"expand_recurring,omitempty"`
	From            *string `json:"from,omitempty"`

	// Only created from template with this ID.
	TemplateId *string `json:"template_id,omitempty"`
	To         *string `json:"to,omitempty"`
}

// RuleSetResponse defines model for RuleSetResponse.
type RuleSetResponse struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// The date of the rule set.
	//
	// For recurring rule sets, this is the date where the recurrance rule starts.
	Date string `json:"date"`

	// End time
	EndsAt string  `json:"ends_at"`
	Id     *string `json:"id,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string.
	//
	// The dtstart property is ignored, and the date attribute of the rule set is used to define the beginnin of the reccurence.
	Rrule *string `json:"rrule,omitempty"`

	// The template that was used to create this rule set
	RuleSetTemplateId *string `json:"rule_set_template_id,omitempty"`
	Rules             Rules   `json:"rules"`

	// Start time
	StartsAt  string     `json:"starts_at"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetResponseOverrides defines model for RuleSetResponseOverrides.
type RuleSetResponseOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// The date of the rule set.
	//
	// For recurring rule sets, this is the date where the recurrance rule starts.
	Date string `json:"date"`

	// End time
	EndsAt string  `json:"ends_at"`
	Id     *string `json:"id,omitempty"`
	Rules  Rules   `json:"rules"`

	// Start time
	StartsAt  string     `json:"starts_at"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetTemplate defines model for RuleSetTemplate.
type RuleSetTemplate struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// End time
	EndsAt *string `json:"ends_at,omitempty"`
	Id     *string `json:"id,omitempty"`
	Rules  *Rules  `json:"rules,omitempty"`

	// Start time
	StartsAt  *string    `json:"starts_at,omitempty"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetTemplateCreate defines model for RuleSetTemplateCreate.
type RuleSetTemplateCreate struct {
	Company   string     `json:"company"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// End time
	EndsAt string  `json:"ends_at"`
	Id     *string `json:"id,omitempty"`
	Rules  *Rules  `json:"rules,omitempty"`

	// Start time
	StartsAt  string     `json:"starts_at"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetTemplateCreateOverrides defines model for RuleSetTemplateCreateOverrides.
type RuleSetTemplateCreateOverrides struct {
	Company string `json:"company"`

	// End time
	EndsAt string `json:"ends_at"`

	// Start time
	StartsAt string `json:"starts_at"`
}

// RuleSetTemplateResponse defines model for RuleSetTemplateResponse.
type RuleSetTemplateResponse struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// End time
	EndsAt string  `json:"ends_at"`
	Id     *string `json:"id,omitempty"`
	Rules  Rules   `json:"rules"`

	// Start time
	StartsAt  string     `json:"starts_at"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetTemplateResponseOverrides defines model for RuleSetTemplateResponseOverrides.
type RuleSetTemplateResponseOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// End time
	EndsAt string  `json:"ends_at"`
	Id     *string `json:"id,omitempty"`
	Rules  Rules   `json:"rules"`

	// Start time
	StartsAt  string     `json:"starts_at"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetTemplateUpdate defines model for RuleSetTemplateUpdate.
type RuleSetTemplateUpdate struct {
	Company   *interface{} `json:"company,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`

	// End time
	EndsAt *string `json:"ends_at,omitempty"`
	Id     *string `json:"id,omitempty"`
	Rules  *Rules  `json:"rules,omitempty"`

	// Start time
	StartsAt  *string    `json:"starts_at,omitempty"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetTemplateUpdateOverrides defines model for RuleSetTemplateUpdateOverrides.
type RuleSetTemplateUpdateOverrides struct {
	Company *interface{} `json:"company,omitempty"`
}

// RuleSetTemplates defines model for RuleSetTemplates.
type RuleSetTemplates []RuleSetTemplate

// RuleSetTemplatesResponse defines model for RuleSetTemplatesResponse.
type RuleSetTemplatesResponse []RuleSetTemplateResponse

// RuleSetUpdate defines model for RuleSetUpdate.
type RuleSetUpdate struct {
	Company   *interface{} `json:"company,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`

	// The date of the rule set.
	//
	// For recurring rule sets, this is the date where the recurrance rule starts.
	Date *string `json:"date,omitempty"`

	// End time
	EndsAt *string `json:"ends_at,omitempty"`
	Id     *string `json:"id,omitempty"`

	// [RRULE](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html) string.
	//
	// The dtstart property is ignored, and the date attribute of the rule set is used to define the beginnin of the reccurence.
	Rrule             *string      `json:"rrule,omitempty"`
	RuleSetTemplateId *interface{} `json:"rule_set_template_id,omitempty"`
	Rules             *Rules       `json:"rules,omitempty"`

	// Start time
	StartsAt  *string    `json:"starts_at,omitempty"`
	Title     *string    `json:"title,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RuleSetUpdateOverrides defines model for RuleSetUpdateOverrides.
type RuleSetUpdateOverrides struct {
	Company           *interface{} `json:"company,omitempty"`
	RuleSetTemplateId *interface{} `json:"rule_set_template_id,omitempty"`
}

// RuleSets defines model for RuleSets.
type RuleSets []RuleSet

// RuleSetsResponse defines model for RuleSetsResponse.
type RuleSetsResponse []RuleSetResponse

// RuleType defines model for RuleType.
type RuleType string

// Rules defines model for Rules.
type Rules []Rule

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type SMSFilter struct {
	// Filter by recipient phone number
	PhoneNumber *string `json:"phone_number,omitempty"`
}

// SMSMessage defines model for SMSMessage.
type SMSMessage struct {
	Body *string `json:"body,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee *ExpandableEmployee `json:"employee,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Event            *ExpandableEvent  `json:"event,omitempty"`
	Id               *string           `json:"id,omitempty"`
	PhoneCountryCode *string           `json:"phone_country_code,omitempty"`
	PhoneNumber      *string           `json:"phone_number,omitempty"`
	SenderName       *string           `json:"sender_name,omitempty"`
	Status           *SMSMessageStatus `json:"status,omitempty"`
	Type             *SMSMessageType   `json:"type,omitempty"`
	UpdatedAt        *time.Time        `json:"updated_at,omitempty"`
}

// SMSMessageStatus defines model for SMSMessage.Status.
type SMSMessageStatus string

// SMSMessageType defines model for SMSMessage.Type.
type SMSMessageType string

// SMSMessages defines model for SMSMessages.
type SMSMessages []SMSMessage

// Sale defines model for Sale.
type Sale struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer     *ExpandableCustomer      `json:"customer,omitempty"`
	Events       *[]ExpandableEvent       `json:"events,omitempty"`
	Id           *string                  `json:"id,omitempty"`
	Transactions *[]ExpandableTransaction `json:"transactions,omitempty"`
	UpdatedAt    *time.Time               `json:"updated_at,omitempty"`
}

// Sales defines model for Sales.
type Sales []Sale

// SalesMetrics defines model for SalesMetrics.
type SalesMetrics struct {
	Payments     *AmountMetricsByDay `json:"payments,omitempty"`
	Transactions *AmountMetricsByDay `json:"transactions,omitempty"`
}

// SaltpayBankAccount defines model for SaltpayBankAccount.
type SaltpayBankAccount struct {
	AccountNumber *string `json:"account_number,omitempty"`
	AccountType   *string `json:"account_type,omitempty"`
	BankCode      *string `json:"bank_code,omitempty"`

	// The company ID tied to the bank account.
	CompanyId *string `json:"company_id,omitempty"`

	// Deprecated: use company_id instead
	EnterpriseId *string `json:"enterprise_id,omitempty"`
	Id           *string `json:"id,omitempty"`
	Kennitala    *string `json:"kennitala,omitempty"`

	// The user ID tied to the bank account.
	//
	// **Note:** A user can only tie a bank account to his own user ID.
	UserId *string `json:"user_id,omitempty"`
}

// SaltpayCompanies defines model for SaltpayCompanies.
type SaltpayCompanies []SaltpayCompany

// SaltpayCompany defines model for SaltpayCompany.
type SaltpayCompany struct {
	BankAccount *SaltpayBankAccount `json:"bank_account,omitempty"`
	Id          *string             `json:"id,omitempty"`
	Name        *string             `json:"name,omitempty"`
}

// SaltpayStore defines model for SaltpayStore.
type SaltpayStore struct {
	Address *SaltpayStoreAddress `json:"address,omitempty"`
	Id      *string              `json:"id,omitempty"`
	Name    *string              `json:"name,omitempty"`
}

// SaltpayStoreAddress defines model for SaltpayStoreAddress.
type SaltpayStoreAddress struct {
	City               *string `json:"city,omitempty"`
	Country            *string `json:"country,omitempty"`
	StreetAddressLine1 *string `json:"street_address_line_1,omitempty"`
	StreetAddressLine2 *string `json:"street_address_line_2,omitempty"`
	ZipCode            *string `json:"zip_code,omitempty"`
}

// SaltpayStores defines model for SaltpayStores.
type SaltpayStores []SaltpayStore

// SaltpayTerminal defines model for SaltpayTerminal.
type SaltpayTerminal struct {
	// The issuer tied to the terminal.
	Issuer       *string `json:"issuer,omitempty"`
	SerialNumber *string `json:"serial_number,omitempty"`
	TerminalId   *string `json:"terminal_id,omitempty"`
	TerminalName *string `json:"terminal_name,omitempty"`
}

// SaltpayTerminals defines model for SaltpayTerminals.
type SaltpayTerminals []SaltpayTerminal

// The search query.
type Search string

// Settlement defines model for Settlement.
type Settlement struct {
	CreatedAt    *time.Time           `json:"created_at,omitempty"`
	Fee          *float64             `json:"fee,omitempty"`
	Id           *string              `json:"id,omitempty"`
	LineItems    *SettlementLineItems `json:"line_items,omitempty"`
	NetTotal     *float64             `json:"net_total,omitempty"`
	PaymentsFrom *time.Time           `json:"payments_from,omitempty"`
	PaymentsTo   *time.Time           `json:"payments_to,omitempty"`

	// The name of the settlement recipient.
	SettledTo                 *string            `json:"settled_to,omitempty"`
	SettlementAccount         *SettlementAccount `json:"settlement_account,omitempty"`
	Total                     *float64           `json:"total,omitempty"`
	TransferredToEnterprise   *bool              `json:"transferred_to_enterprise,omitempty"`
	TransferredToEnterpriseAt *time.Time         `json:"transferred_to_enterprise_at,omitempty"`
	UpdatedAt                 *time.Time         `json:"updated_at,omitempty"`
}

// SettlementAccount defines model for SettlementAccount.
type SettlementAccount struct {
	Account     *string    `json:"account,omitempty"`
	Bank        *string    `json:"bank,omitempty"`
	Book        *string    `json:"book,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Ssn         *string    `json:"ssn,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// SettlementAccounts defines model for SettlementAccounts.
type SettlementAccounts []SettlementAccount

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type SettlementFilter struct {
	From *time.Time `json:"from,omitempty"`
	To   *time.Time `json:"to,omitempty"`
}

// SettlementLineItem defines model for SettlementLineItem.
type SettlementLineItem struct {
	Fee      *float64 `json:"fee,omitempty"`
	NetTotal *float64 `json:"net_total,omitempty"`
	Quantity *int32   `json:"quantity,omitempty"`
	Title    *string  `json:"title,omitempty"`
	Total    *float64 `json:"total,omitempty"`
}

// SettlementLineItems defines model for SettlementLineItems.
type SettlementLineItems []SettlementLineItem

// Settlements defines model for Settlements.
type Settlements []Settlement

// Sort defines model for Sort.
type Sort struct {
	Field *string    `json:"field,omitempty"`
	Order *SortOrder `json:"order,omitempty"`
}

// SortOrder defines model for Sort.Order.
type SortOrder string

// Space defines model for Space.
type Space struct {
	// Whether the space is visible on the calendar
	AvailableForBookings *bool `json:"available_for_bookings,omitempty"`

	// Booking interval in minutes.
	//
	// Dictates how often customers can book events with employee or resource.
	//
	// A booking interval of 15 would render results like: `10:00`  `10:15`  `10:30`.
	//
	// A booking interval is set on the company level but can be overridden on the resource/employee level.
	BookingInterval *BookingInterval `json:"booking_interval,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company *ExpandableCompany `json:"company,omitempty"`

	// Use `company` instead.
	CompanyId            *string               `json:"company_id,omitempty"`
	CreatedAt            *time.Time            `json:"created_at,omitempty"`
	Description          *string               `json:"description,omitempty"`
	EventTypePreferences *EventTypePreferences `json:"event_type_preferences,omitempty"`
	Id                   *string               `json:"id,omitempty"`
	Image                *Image                `json:"image,omitempty"`

	// If true, space is visible on the marketplace.
	Marketplace *bool `json:"marketplace,omitempty"`

	// The maximum capacity of the space, for example how many people can occupy a table at maximum.
	MaxCapacity *int32 `json:"max_capacity,omitempty"`

	// The mininum capacity of the space, for example how many people can occupy a table at minimum.
	MinCapacity *int32  `json:"min_capacity,omitempty"`
	Name        *string `json:"name,omitempty"`

	// The order of the space in the list of spaces on the marketplace.
	Order        *int32     `json:"order,omitempty"`
	SubResources *[]string  `json:"sub_resources,omitempty"`
	Type         *SpaceType `json:"type,omitempty"`
	UpdatedAt    *time.Time `json:"updated_at,omitempty"`
}

// SpaceType defines model for SpaceType.
type SpaceType string

// Spaces defines model for Spaces.
type Spaces []Space

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type SpacesFilter struct {
	// Filter by space IDs
	Types *[]SpaceType `json:"types,omitempty"`
}

// SubscriptionCoupon defines model for SubscriptionCoupon.
type SubscriptionCoupon struct {
	AppliedCount *int32     `json:"applied_count,omitempty"`
	ApplyTill    *time.Time `json:"apply_till,omitempty"`
	CouponCode   *string    `json:"coupon_code,omitempty"`
	CouponId     *string    `json:"coupon_id,omitempty"`
}

// SubscriptionCoupons defines model for SubscriptionCoupons.
type SubscriptionCoupons []SubscriptionCoupon

// SubscriptionDiscount defines model for SubscriptionDiscount.
type SubscriptionDiscount struct {
	Amount        *int32                            `json:"amount,omitempty"`
	AppliedCount  *int32                            `json:"applied_count,omitempty"`
	ApplyOn       *SubscriptionDiscountApplyOn      `json:"apply_on,omitempty"`
	ApplyTill     *time.Time                        `json:"apply_till,omitempty"`
	Coupon        *string                           `json:"coupon,omitempty"`
	CreatedAt     *time.Time                        `json:"created_at,omitempty"`
	CurrencyCode  *string                           `json:"currency_code,omitempty"`
	DurationType  *SubscriptionDiscountDurationType `json:"duration_type,omitempty"`
	Id            *string                           `json:"id,omitempty"`
	IncludedInMrr *bool                             `json:"included_in_mrr,omitempty"`
	InvoiceName   *string                           `json:"invoice_name,omitempty"`
	ItemPriceId   *string                           `json:"item_price_id,omitempty"`
	Percentage    *float64                          `json:"percentage,omitempty"`
	Period        *int32                            `json:"period,omitempty"`
	PeriodUnit    *SubscriptionDiscountPeriodUnit   `json:"period_unit,omitempty"`
}

// SubscriptionDiscountApplyOn defines model for SubscriptionDiscount.ApplyOn.
type SubscriptionDiscountApplyOn string

// SubscriptionDiscountDurationType defines model for SubscriptionDiscount.DurationType.
type SubscriptionDiscountDurationType string

// SubscriptionDiscountPeriodUnit defines model for SubscriptionDiscount.PeriodUnit.
type SubscriptionDiscountPeriodUnit string

// SubscriptionDiscounts defines model for SubscriptionDiscounts.
type SubscriptionDiscounts []SubscriptionDiscount

// SubscriptionItem defines model for SubscriptionItem.
type SubscriptionItem struct {
	Amount      *int32                    `json:"amount,omitempty"`
	ItemPriceId *string                   `json:"item_price_id,omitempty"`
	ItemType    *SubscriptionItemItemType `json:"item_type,omitempty"`
	Quantity    *int32                    `json:"quantity,omitempty"`
	TrialEnd    *time.Time                `json:"trial_end,omitempty"`
	UnitPrice   *int32                    `json:"unit_price,omitempty"`
}

// SubscriptionItemItemType defines model for SubscriptionItem.ItemType.
type SubscriptionItemItemType string

// SubscriptionItems defines model for SubscriptionItems.
type SubscriptionItems []SubscriptionItem

// Subtransaction defines model for Subtransaction.
type Subtransaction struct {
	Amount          *float64                    `json:"amount,omitempty"`
	CreatedAt       *time.Time                  `json:"created_at,omitempty"`
	Currency        *string                     `json:"currency,omitempty"`
	Data            *SubtransactionData         `json:"data,omitempty"`
	FailureState    *SubtransactionFailureState `json:"failure_state,omitempty"`
	Id              *string                     `json:"id,omitempty"`
	Note            *string                     `json:"note,omitempty"`
	Origin          *SubtransactionOrigin       `json:"origin,omitempty"`
	PaymentMethodId *string                     `json:"payment_method_id,omitempty"`
	State           *SubtransactionState        `json:"state,omitempty"`
	TransactionId   *string                     `json:"transaction_id,omitempty"`
	UpdatedAt       *time.Time                  `json:"updated_at,omitempty"`
}

// SubtransactionFailureState defines model for Subtransaction.FailureState.
type SubtransactionFailureState string

// SubtransactionOrigin defines model for Subtransaction.Origin.
type SubtransactionOrigin string

// SubtransactionState defines model for Subtransaction.State.
type SubtransactionState string

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type SubtransactionCreationBehavior struct {
	// The type of subtransaction to create.
	//
	// Single will create a single subtransaction for the transaction.
	//
	// Split will create subtransactions on all transactions in the sale with the remaining amount of each transation.
	Type *SubtransactionCreationBehaviorType `json:"type,omitempty"`
}

// The type of subtransaction to create.
//
// Single will create a single subtransaction for the transaction.
//
// Split will create subtransactions on all transactions in the sale with the remaining amount of each transation.
type SubtransactionCreationBehaviorType string

// SubtransactionData defines model for SubtransactionData.
type SubtransactionData struct {
	union json.RawMessage
}

// SubtransactionDataPaylink defines model for SubtransactionDataPaylink.
type SubtransactionDataPaylink struct {
	Channel               *SubtransactionDataPaylinkChannel `json:"channel,omitempty"`
	PaylinkPaymentGroupId *string                           `json:"paylink_payment_group_id,omitempty"`
	PaylinkPaymentId      *string                           `json:"paylink_payment_id,omitempty"`
	PhoneCountryCode      string                            `json:"phone_country_code"`
	PhoneNumber           string                            `json:"phone_number"`
	Type                  SubtransactionDataPaylinkType     `json:"type"`
}

// SubtransactionDataPaylinkChannel defines model for SubtransactionDataPaylink.Channel.
type SubtransactionDataPaylinkChannel string

// SubtransactionDataPaylinkType defines model for SubtransactionDataPaylink.Type.
type SubtransactionDataPaylinkType string

// SubtransactionDataPrePayment defines model for SubtransactionDataPrePayment.
type SubtransactionDataPrePayment struct {
	PaymentId string                           `json:"payment_id"`
	Type      SubtransactionDataPrePaymentType `json:"type"`
}

// SubtransactionDataPrePaymentType defines model for SubtransactionDataPrePayment.Type.
type SubtransactionDataPrePaymentType string

// SubtransactionDataTerminal defines model for SubtransactionDataTerminal.
type SubtransactionDataTerminal struct {
	TerminalId string                         `json:"terminal_id"`
	Type       SubtransactionDataTerminalType `json:"type"`
}

// SubtransactionDataTerminalType defines model for SubtransactionDataTerminal.Type.
type SubtransactionDataTerminalType string

// SubtransactionDataVoucher defines model for SubtransactionDataVoucher.
type SubtransactionDataVoucher struct {
	Type      SubtransactionDataVoucherType `json:"type"`
	VoucherId string                        `json:"voucher_id"`
}

// SubtransactionDataVoucherType defines model for SubtransactionDataVoucher.Type.
type SubtransactionDataVoucherType string

// Subtransactions defines model for Subtransactions.
type Subtransactions []Subtransaction

// Terminal defines model for Terminal.
type Terminal struct {
	Brand     *string  `json:"brand,omitempty"`
	CreatedAt *float64 `json:"created_at,omitempty"`

	// Whether this terminal is the default terminal to use for sales.
	Default     *bool   `json:"default,omitempty"`
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Issuer             *ExpandableIssuer `json:"issuer,omitempty"`
	Model              *string           `json:"model,omitempty"`
	Provider           *TerminalProvider `json:"provider,omitempty"`
	ReadableIdentifier *string           `json:"readable_identifier,omitempty"`
	Serial             *string           `json:"serial,omitempty"`
}

// TerminalProvider defines model for Terminal.Provider.
type TerminalProvider string

// Terminals defines model for Terminals.
type Terminals []Terminal

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type TerminalsFilter struct {
	// Only get terminals directly connected to the company.
	CompanyOnly *bool `json:"company_only,omitempty"`
}

// TimeRange defines model for TimeRange.
type TimeRange struct {
	// End time within the day
	EndsAt *string `json:"ends_at,omitempty"`

	// Start time within the day
	StartsAt *string `json:"starts_at,omitempty"`
}

// TimeSlot defines model for TimeSlot.
type TimeSlot struct {
	// The IDs of the employees that are available for this time slot
	EmployeeIds *[]string `json:"employeeIds,omitempty"`

	// The IDs of the resources that are available for this time slot
	ResourceIds *[]string `json:"resourceIds,omitempty"`

	// The start time of the time slot
	Slot *time.Time `json:"slot,omitempty"`
}

// TimeSlotReservation defines model for TimeSlotReservation.
type TimeSlotReservation struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// Date of timeslot reservation
	Date     *string `json:"date,omitempty"`
	Duration *int32  `json:"duration,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee    `json:"employee,omitempty"`
	EndsAt     *time.Time             `json:"ends_at,omitempty"`
	EventTypes *[]ExpandableEventType `json:"event_types,omitempty"`
	ExpiresAt  *time.Time             `json:"expires_at,omitempty"`
	Id         *string                `json:"id,omitempty"`
	Resources  *ExpandableResources   `json:"resources,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Space     *ExpandableSpace `json:"space,omitempty"`
	StartsAt  *time.Time       `json:"starts_at,omitempty"`
	UpdatedAt *time.Time       `json:"updated_at,omitempty"`
}

// TimeSlotReservationFilter defines model for TimeSlotReservationFilter.
type TimeSlotReservationFilter struct {
	// Filter by employee IDs
	Employees *[]string `json:"employees,omitempty"`

	// Only return reservations where starts_at is after this timestamp.
	From *time.Time `json:"from,omitempty"`

	// Filter by resource IDs
	Resources *[]string `json:"resources,omitempty"`

	// Filter by space IDs
	Spaces *[]string `json:"spaces,omitempty"`

	// Only return reservations where starts_at is before this timestamp.
	To *time.Time `json:"to,omitempty"`
}

// TimeSlotReservations defines model for TimeSlotReservations.
type TimeSlotReservations []TimeSlotReservation

// TimeSlots defines model for TimeSlots.
type TimeSlots []TimeSlot

// Token defines model for Token.
type Token struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Token     *string    `json:"token,omitempty"`
}

// Tokens defines model for Tokens.
type Tokens []Token

// Transaction defines model for Transaction.
type Transaction struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company       *ExpandableCompany    `json:"company,omitempty"`
	CompletedAt   *time.Time            `json:"completed_at,omitempty"`
	CreatedAt     *time.Time            `json:"created_at,omitempty"`
	Currency      *string               `json:"currency,omitempty"`
	DraftedAt     *time.Time            `json:"drafted_at,omitempty"`
	DueAmount     *float64              `json:"due_amount,omitempty"`
	Employees     *[]ExpandableEmployee `json:"employees,omitempty"`
	Fiscalization *string               `json:"fiscalization,omitempty"`
	Id            *string               `json:"id,omitempty"`
	InvoiceNumber *int64                `json:"invoice_number,omitempty"`
	Issuer        *Issuer               `json:"issuer,omitempty"`
	LineItems     *ExpandableLineItems  `json:"line_items,omitempty"`
	Note          *string               `json:"note,omitempty"`

	// The origin of the transaction.
	//
	// * marketplace: The transaction was created via the marketplace.
	// * pos: The transaction was created via the POS.
	Origin *TransactionOrigin `json:"origin,omitempty"`

	// Amount paid on marketplace during booking.
	//
	// Only applicable for bookings made on the marketplace.
	//
	// Example: Payment is $10 via voucher and remaining $5 via card. The value of this field would be $15.
	PaidOnMarketplaceAmount *float64 `json:"paid_on_marketplace_amount,omitempty"`

	// References the original transaction that was refunded.
	RefundOrigin *string `json:"refund_origin,omitempty"`

	// References refunds for this transaction.
	Refunds *[]string `json:"refunds,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Sale            *ExpandableSale             `json:"sale,omitempty"`
	Status          *TransactionStatus          `json:"status,omitempty"`
	Subtransactions *[]ExpandableSubtransaction `json:"subtransactions,omitempty"`

	// The VAT exemption reason when the VAT amount is equal to 0
	TaxExemptionReason *string          `json:"tax_exemption_reason,omitempty"`
	TotalAmount        *float64         `json:"total_amount,omitempty"`
	Type               *TransactionType `json:"type,omitempty"`
	UpdatedAt          *time.Time       `json:"updated_at,omitempty"`

	// The total VAT amount
	VatAmount *float64 `json:"vat_amount,omitempty"`

	// Only supported to unset this field. That is done by providing the value as "zero date" (0001-01-01T00:00:00Z)
	VoidedAt *time.Time `json:"voided_at,omitempty"`
}

// The origin of the transaction.
//
// * marketplace: The transaction was created via the marketplace.
// * pos: The transaction was created via the POS.
type TransactionOrigin string

// TransactionStatus defines model for Transaction.Status.
type TransactionStatus string

// TransactionType defines model for Transaction.Type.
type TransactionType string

// [Behavior](https://api.noona.is/docs/working-with-the-apis/behavior)
type TransactionCreationBehavior struct {
	// Controls the behviour of creating refund transactions. Only applicable when refund_origin is included in the request body.
	//
	// The default value is *full_refund* which means that the entire transaction is copied over and completed.
	//
	// If *partial_refund* is used, only the line items are copied over to the new transaction and the new transaction is left in draft state.
	Refund *TransactionCreationBehaviorRefund `json:"refund,omitempty"`
}

// Controls the behviour of creating refund transactions. Only applicable when refund_origin is included in the request body.
//
// The default value is *full_refund* which means that the entire transaction is copied over and completed.
//
// If *partial_refund* is used, only the line items are copied over to the new transaction and the new transaction is left in draft state.
type TransactionCreationBehaviorRefund string

// Transactions defines model for Transactions.
type Transactions []Transaction

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type TransactionsFilter struct {
	CompletedAt *DateFilter `json:"completed_at,omitempty"`
	CreatedAt   *DateFilter `json:"created_at,omitempty"`

	// Filter by customer IDs
	Customers *[]string `json:"customers,omitempty"`
	Employees *[]string `json:"employees,omitempty"`
	Issuers   *[]string `json:"issuers,omitempty"`

	// Filter by sale ID
	Sale *string `json:"sale,omitempty"`
}

// UnifiedActivities defines model for UnifiedActivities.
type UnifiedActivities []UnifiedActivity

// UnifiedActivity defines model for UnifiedActivity.
type UnifiedActivity struct {
	union json.RawMessage
}

// UnitPrice defines model for UnitPrice.
type UnitPrice struct {
	Amount   *float64 `json:"amount,omitempty"`
	Currency *string  `json:"currency,omitempty"`

	// Discount percentage
	Discount       *float64 `json:"discount,omitempty"`
	Id             *string  `json:"id,omitempty"`
	OriginalAmount *float64 `json:"original_amount,omitempty"`
}

// User defines model for User.
type User struct {
	Companies   *ExpandableCompanies `json:"companies,omitempty"`
	Connections *UserConnections     `json:"connections,omitempty"`
	Email       *string              `json:"email,omitempty"`
	Employees   *Employees           `json:"employees,omitempty"`
	Id          *string              `json:"id,omitempty"`
}

// UserConnections defines model for UserConnections.
type UserConnections struct {
	Google *UserConnectionsGoogle `json:"google,omitempty"`
}

// UserConnectionsGoogle defines model for UserConnectionsGoogle.
type UserConnectionsGoogle struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	CalendarConnection *ExpandableGoogleCalendarConnection `json:"calendar_connection,omitempty"`

	// Whether the user has connected their Google account.
	Connected *bool `json:"connected,omitempty"`
}

// Users defines model for Users.
type Users []User

// VAT defines model for VAT.
type VAT struct {
	CountryCode *string  `json:"country_code,omitempty"`
	Default     *bool    `json:"default,omitempty"`
	Id          *string  `json:"id,omitempty"`
	Ratio       *float64 `json:"ratio,omitempty"`
}

// VATs defines model for VATs.
type VATs []VAT

// Voucher defines model for Voucher.
type Voucher struct {
	Amount *float64 `json:"amount,omitempty"`

	// 6 uppercase letters / numbers
	Code  *string `json:"code,omitempty"`
	Color *string `json:"color,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`
	Currency  *string            `json:"currency,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer  *ExpandableCustomer `json:"customer,omitempty"`
	Data      *VoucherData        `json:"data,omitempty"`
	DeletedAt *time.Time          `json:"deleted_at,omitempty"`

	// If an email is provided, it receives news of the newly created voucher.
	Email *string `json:"email,omitempty"`

	// Vouchers expire after 3 years
	Expiration *time.Time `json:"expiration,omitempty"`
	Id         *string    `json:"id,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	MarketplaceUser  *ExpandableMarketplaceUser `json:"marketplace_user,omitempty"`
	Message          *string                    `json:"message,omitempty"`
	PhoneCountryCode *string                    `json:"phone_country_code,omitempty"`

	// If a phone number is provided, it receives news of the newly created voucher.
	PhoneNumber *string        `json:"phone_number,omitempty"`
	Status      *VoucherStatus `json:"status,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Template  *ExpandableVoucherTemplate `json:"template,omitempty"`
	UpdatedAt *time.Time                 `json:"updated_at,omitempty"`
}

// VoucherStatus defines model for Voucher.Status.
type VoucherStatus string

// VoucherData defines model for VoucherData.
type VoucherData struct {
	union json.RawMessage
}

// VoucherDataAmount defines model for VoucherDataAmount.
type VoucherDataAmount struct {
	AmountUsed *float64              `json:"amount_used,omitempty"`
	Type       VoucherDataAmountType `json:"type"`
}

// VoucherDataAmountType defines model for VoucherDataAmount.Type.
type VoucherDataAmountType string

// VoucherDataService defines model for VoucherDataService.
type VoucherDataService struct {
	EventTypeId           *string                `json:"event_type_id,omitempty"`
	EventTypeName         *string                `json:"event_type_name,omitempty"`
	SessionsTotal         *int32                 `json:"sessions_total,omitempty"`
	SessionsUsed          *int32                 `json:"sessions_used,omitempty"`
	Type                  VoucherDataServiceType `json:"type"`
	VoucherTemplate       *string                `json:"voucher_template,omitempty"`
	VoucherTemplateAmount *float64               `json:"voucher_template_amount,omitempty"`
}

// VoucherDataServiceType defines model for VoucherDataService.Type.
type VoucherDataServiceType string

// VoucherField defines model for VoucherField.
type VoucherField string

// VoucherFields defines model for VoucherFields.
type VoucherFields []VoucherField

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type VoucherFilter struct {
	// Regex match of code
	Code       *string    `json:"code,omitempty"`
	Companies  *[]string  `json:"companies,omitempty"`
	Customer   *string    `json:"customer,omitempty"`
	EventTypes *[]string  `json:"event_types,omitempty"`
	From       *time.Time `json:"from,omitempty"`

	// Whether to include deleted vouchers in the response.
	//
	// When true, deleted vouchers will be included in the response.
	//
	// When false, deleted vouchers will not be included in the response.
	IncludeDeleted  *bool                `json:"include_deleted,omitempty"`
	MarketplaceUser *string              `json:"marketplace_user,omitempty"`
	Status          *VoucherFilterStatus `json:"status,omitempty"`
	To              *time.Time           `json:"to,omitempty"`
	Type            *VoucherFilterType   `json:"type,omitempty"`
}

// VoucherFilterStatus defines model for VoucherFilter.Status.
type VoucherFilterStatus string

// VoucherFilterType defines model for VoucherFilter.Type.
type VoucherFilterType string

// VoucherNotification defines model for VoucherNotification.
type VoucherNotification struct {
	// Email to send voucher to.
	Email *string `json:"email,omitempty"`
}

// VoucherSettings defines model for VoucherSettings.
type VoucherSettings struct {
	// Are amount vouchers enabled?
	AmountVouchersEnabled *bool `json:"amount_vouchers_enabled,omitempty"`

	// Are vouchers enabled?
	Enabled *bool `json:"enabled,omitempty"`
}

// VoucherTemplate defines model for VoucherTemplate.
type VoucherTemplate struct {
	Amount    *float64   `json:"amount,omitempty"`
	Company   *string    `json:"company,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Currency  *string    `json:"currency,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType *ExpandableEventType `json:"event_type,omitempty"`
	Id        *string              `json:"id,omitempty"`

	// If true, voucher is visible on the marketplace.
	Marketplace   *bool      `json:"marketplace,omitempty"`
	SessionsTotal *int32     `json:"sessions_total,omitempty"`
	Title         *string    `json:"title,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	Value         *float64   `json:"value,omitempty"`

	// The ID of the event type variation that the value of the voucher should be calculated from.
	VariationId *string `json:"variation_id,omitempty"`
}

// VoucherTemplateCreate defines model for VoucherTemplateCreate.
type VoucherTemplateCreate struct {
	Amount    float64    `json:"amount"`
	Company   string     `json:"company"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Currency  string     `json:"currency"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType ExpandableEventType `json:"event_type"`
	Id        *string             `json:"id,omitempty"`

	// If true, voucher is visible on the marketplace.
	Marketplace   *bool      `json:"marketplace,omitempty"`
	SessionsTotal int32      `json:"sessions_total"`
	Title         *string    `json:"title,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	Value         *float64   `json:"value,omitempty"`

	// The ID of the event type variation that the value of the voucher should be calculated from.
	VariationId *string `json:"variation_id,omitempty"`
}

// VoucherTemplateCreateOverrides defines model for VoucherTemplateCreateOverrides.
type VoucherTemplateCreateOverrides struct {
	Amount   float64 `json:"amount"`
	Company  string  `json:"company"`
	Currency string  `json:"currency"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType     ExpandableEventType `json:"event_type"`
	SessionsTotal int32               `json:"sessions_total"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type VoucherTemplateFilter struct {
	Companies  *[]string `json:"companies,omitempty"`
	EventTypes *[]string `json:"event_types,omitempty"`
}

// VoucherTemplateResponse defines model for VoucherTemplateResponse.
type VoucherTemplateResponse struct {
	Amount    float64    `json:"amount"`
	Company   string     `json:"company"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Currency  string     `json:"currency"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType ExpandableEventType `json:"event_type"`
	Id        *string             `json:"id,omitempty"`

	// If true, voucher is visible on the marketplace.
	Marketplace   bool       `json:"marketplace"`
	SessionsTotal int32      `json:"sessions_total"`
	Title         *string    `json:"title,omitempty"`
	UpdatedAt     *time.Time `json:"updated_at,omitempty"`
	Value         *float64   `json:"value,omitempty"`

	// The ID of the event type variation that the value of the voucher should be calculated from.
	VariationId *string `json:"variation_id,omitempty"`
}

// VoucherTemplateResponseOverrides defines model for VoucherTemplateResponseOverrides.
type VoucherTemplateResponseOverrides struct {
	Amount    float64    `json:"amount"`
	Company   string     `json:"company"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Currency  string     `json:"currency"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	EventType     ExpandableEventType `json:"event_type"`
	Id            *string             `json:"id,omitempty"`
	SessionsTotal int32               `json:"sessions_total"`
	UpdatedAt     *time.Time          `json:"updated_at,omitempty"`
	Value         *float64            `json:"value,omitempty"`

	// The ID of the event type variation that the value of the voucher should be calculated from.
	VariationId *string `json:"variation_id,omitempty"`
}

// VoucherTemplateUpdate defines model for VoucherTemplateUpdate.
type VoucherTemplateUpdate struct {
	Amount    *float64     `json:"amount,omitempty"`
	Company   *interface{} `json:"company,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`
	Currency  *interface{} `json:"currency,omitempty"`
	EventType *interface{} `json:"event_type,omitempty"`
	Id        *string      `json:"id,omitempty"`

	// If true, voucher is visible on the marketplace.
	Marketplace   *bool        `json:"marketplace,omitempty"`
	SessionsTotal *int32       `json:"sessions_total,omitempty"`
	Title         *string      `json:"title,omitempty"`
	UpdatedAt     *time.Time   `json:"updated_at,omitempty"`
	Value         *float64     `json:"value,omitempty"`
	VariationId   *interface{} `json:"variation_id,omitempty"`
}

// VoucherTemplateUpdateOverrides defines model for VoucherTemplateUpdateOverrides.
type VoucherTemplateUpdateOverrides struct {
	Company     *interface{} `json:"company,omitempty"`
	Currency    *interface{} `json:"currency,omitempty"`
	EventType   *interface{} `json:"event_type,omitempty"`
	VariationId *interface{} `json:"variation_id,omitempty"`
}

// VoucherTemplates defines model for VoucherTemplates.
type VoucherTemplates []VoucherTemplate

// VoucherTemplatesResponse defines model for VoucherTemplatesResponse.
type VoucherTemplatesResponse []VoucherTemplateResponse

// Vouchers defines model for Vouchers.
type Vouchers []Voucher

// WaitlistEntries defines model for WaitlistEntries.
type WaitlistEntries []WaitlistEntry

// WaitlistEntriesResponse defines model for WaitlistEntriesResponse.
type WaitlistEntriesResponse []WaitlistEntryResponse

// WaitlistEntry defines model for WaitlistEntry.
type WaitlistEntry struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   *ExpandableCompany `json:"company,omitempty"`
	CreatedAt *time.Time         `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer *ExpandableCustomer `json:"customer,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee    `json:"employee,omitempty"`
	EventTypes *[]ExpandableEventType `json:"event_types,omitempty"`
	ExpiresAt  *time.Time             `json:"expires_at,omitempty"`
	Id         *string                `json:"id,omitempty"`
	Notes      *string                `json:"notes,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32     `json:"number_of_guests,omitempty"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// WaitlistEntryCreate defines model for WaitlistEntryCreate.
type WaitlistEntryCreate struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt *time.Time        `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer ExpandableCustomer `json:"customer"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee   `json:"employee,omitempty"`
	EventTypes []ExpandableEventType `json:"event_types"`
	ExpiresAt  *time.Time            `json:"expires_at,omitempty"`
	Id         *string               `json:"id,omitempty"`
	Notes      *string               `json:"notes,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32     `json:"number_of_guests,omitempty"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// WaitlistEntryCreateOverrides defines model for WaitlistEntryCreateOverrides.
type WaitlistEntryCreateOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company ExpandableCompany `json:"company"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer ExpandableCustomer `json:"customer"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee   `json:"employee,omitempty"`
	EventTypes []ExpandableEventType `json:"event_types"`
	ExpiresAt  *time.Time            `json:"expires_at,omitempty"`
	Notes      *string               `json:"notes,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32 `json:"number_of_guests,omitempty"`
}

// WaitlistEntryField defines model for WaitlistEntryField.
type WaitlistEntryField string

// WaitlistEntryFields defines model for WaitlistEntryFields.
type WaitlistEntryFields []WaitlistEntryField

// WaitlistEntryResponse defines model for WaitlistEntryResponse.
type WaitlistEntryResponse struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt time.Time         `json:"created_at"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer ExpandableCustomer `json:"customer"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee   `json:"employee,omitempty"`
	EventTypes []ExpandableEventType `json:"event_types"`
	ExpiresAt  *time.Time            `json:"expires_at,omitempty"`
	Id         string                `json:"id"`
	Notes      *string               `json:"notes,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32    `json:"number_of_guests,omitempty"`
	UpdatedAt      time.Time `json:"updated_at"`
}

// WaitlistEntryResponseOverrides defines model for WaitlistEntryResponseOverrides.
type WaitlistEntryResponseOverrides struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company   ExpandableCompany `json:"company"`
	CreatedAt time.Time         `json:"created_at"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer ExpandableCustomer `json:"customer"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee   `json:"employee,omitempty"`
	EventTypes []ExpandableEventType `json:"event_types"`
	ExpiresAt  *time.Time            `json:"expires_at,omitempty"`
	Id         string                `json:"id"`
	Notes      *string               `json:"notes,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32    `json:"number_of_guests,omitempty"`
	UpdatedAt      time.Time `json:"updated_at"`
}

// WaitlistEntryUpdate defines model for WaitlistEntryUpdate.
type WaitlistEntryUpdate struct {
	Company   *interface{} `json:"company,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer *ExpandableCustomer `json:"customer,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee    `json:"employee,omitempty"`
	EventTypes *[]ExpandableEventType `json:"event_types,omitempty"`
	ExpiresAt  *time.Time             `json:"expires_at,omitempty"`
	Id         *string                `json:"id,omitempty"`
	Notes      *string                `json:"notes,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32     `json:"number_of_guests,omitempty"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// WaitlistEntryUpdateOverrides defines model for WaitlistEntryUpdateOverrides.
type WaitlistEntryUpdateOverrides struct {
	Company *interface{} `json:"company,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Customer *ExpandableCustomer `json:"customer,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Employee   *ExpandableEmployee    `json:"employee,omitempty"`
	EventTypes *[]ExpandableEventType `json:"event_types,omitempty"`
	ExpiresAt  *time.Time             `json:"expires_at,omitempty"`
	Notes      *string                `json:"notes,omitempty"`

	// Number of guests for the event.
	NumberOfGuests *int32 `json:"number_of_guests,omitempty"`
}

// [Filtering](https://api.noona.is/docs/working-with-the-apis/filtering)
type WaitlistFilter struct {
	// Filter by employee IDs
	Employees *[]string `json:"employees,omitempty"`

	// Filter by maximum duration in minutes
	MaxDuration *int32 `json:"max_duration,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	App         *ExpandableApp `json:"app,omitempty"`
	CallbackUrl *string        `json:"callback_url,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company     *ExpandableCompany `json:"company,omitempty"`
	CreatedAt   *time.Time         `json:"created_at,omitempty"`
	Description *string            `json:"description,omitempty"`

	// Whether the webhook is enabled or not
	Enabled   *bool           `json:"enabled,omitempty"`
	Events    *WebhookEvents  `json:"events,omitempty"`
	Headers   *WebhookHeaders `json:"headers,omitempty"`
	Id        *string         `json:"id,omitempty"`
	Title     *string         `json:"title,omitempty"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
}

// WebhookEvent defines model for WebhookEvent.
type WebhookEvent string

// WebhookEvents defines model for WebhookEvents.
type WebhookEvents []WebhookEvent

// WebhookHeader defines model for WebhookHeader.
type WebhookHeader struct {
	Key    *string   `json:"key,omitempty"`
	Values *[]string `json:"values,omitempty"`
}

// WebhookHeaders defines model for WebhookHeaders.
type WebhookHeaders []WebhookHeader

// WebhookInvocation defines model for WebhookInvocation.
type WebhookInvocation struct {
	CallbackUrl *string `json:"callback_url,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Company     *ExpandableCompany          `json:"company,omitempty"`
	CreatedAt   *time.Time                  `json:"created_at,omitempty"`
	Event       *WebhookEvent               `json:"event,omitempty"`
	FailedTries *int                        `json:"failed_tries,omitempty"`
	Id          *string                     `json:"id,omitempty"`
	Responses   *WebhookInvocationResponses `json:"responses,omitempty"`
	Success     *bool                       `json:"success,omitempty"`
	UpdatedAt   *time.Time                  `json:"updated_at,omitempty"`

	// [Expandable](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Webhook *ExpandableWebhook `json:"webhook,omitempty"`
}

// WebhookInvocationResponse defines model for WebhookInvocationResponse.
type WebhookInvocationResponse struct {
	Body *string `json:"body,omitempty"`
	Code *int    `json:"code,omitempty"`
}

// WebhookInvocationResponses defines model for WebhookInvocationResponses.
type WebhookInvocationResponses []WebhookInvocationResponse

// WebhookInvocations defines model for WebhookInvocations.
type WebhookInvocations []WebhookInvocation

// Webhooks defines model for Webhooks.
type Webhooks []Webhook

// Boolean defines model for boolean.
type Boolean bool

// DateTime defines model for date_time.
type DateTime time.Time

// Integer defines model for integer.
type Integer int32

// MultiValue defines model for multi_value.
type MultiValue struct {
	union json.RawMessage
}

// String defines model for string.
type String string

// Expand defines model for expand.
type Expand []string

// Select defines model for select.
type Select []string

// ListCustomerActivitiesParams defines parameters for ListCustomerActivities.
type ListCustomerActivitiesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListEventTypeActivitiesParams defines parameters for ListEventTypeActivities.
type ListEventTypeActivitiesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListEventActivitiesParams defines parameters for ListEventActivities.
type ListEventActivitiesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListPaymentActivitiesParams defines parameters for ListPaymentActivities.
type ListPaymentActivitiesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateBlockedTimeJSONBody defines parameters for CreateBlockedTime.
type CreateBlockedTimeJSONBody BlockedTimeCreate

// CreateBlockedTimeParams defines parameters for CreateBlockedTime.
type CreateBlockedTimeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteBlockedTimeParams defines parameters for DeleteBlockedTime.
type DeleteBlockedTimeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand                      `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *BlockedTimeDeletionBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
	Date     string                       `form:"date" json:"date"`
}

// GetBlockedTimeParams defines parameters for GetBlockedTime.
type GetBlockedTimeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateBlockedTimeJSONBody defines parameters for UpdateBlockedTime.
type UpdateBlockedTimeJSONBody BlockedTimeUpdate

// UpdateBlockedTimeParams defines parameters for UpdateBlockedTime.
type UpdateBlockedTimeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand                    `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *BlockedTimeUpdateBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
	Date     string                     `form:"date" json:"date"`
}

// GetCompaniesParams defines parameters for GetCompanies.
type GetCompaniesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// CreateCompanyJSONBody defines parameters for CreateCompany.
type CreateCompanyJSONBody Company

// CreateCompanyParams defines parameters for CreateCompany.
type CreateCompanyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetCompanyParams defines parameters for GetCompany.
type GetCompanyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateCompanyJSONBody defines parameters for UpdateCompany.
type UpdateCompanyJSONBody Company

// UpdateCompanyParams defines parameters for UpdateCompany.
type UpdateCompanyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListAllCompanyActivitiesParams defines parameters for ListAllCompanyActivities.
type ListAllCompanyActivitiesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand    `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *AppFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetAppParams defines parameters for GetApp.
type GetAppParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListBlockedTimesParams defines parameters for ListBlockedTimes.
type ListBlockedTimesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// Include blocked times starting on this date
	From time.Time `form:"from" json:"from"`

	// Include blocked times ending before this date
	To     time.Time           `form:"to" json:"to"`
	Filter *CalendarSlotFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListClaimsParams defines parameters for ListClaims.
type ListClaimsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand       `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *ClaimsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListCustomerGroupsParams defines parameters for ListCustomerGroups.
type ListCustomerGroupsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListCustomersParams defines parameters for ListCustomers.
type ListCustomersParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand         `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *CustomerFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`

	// [Search](https://api.noona.is/docs/working-with-the-apis/search)
	Search *Search `form:"search,omitempty" json:"search,omitempty"`
}

// ListEmployeesParams defines parameters for ListEmployees.
type ListEmployeesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Search](https://api.noona.is/docs/working-with-the-apis/search)
	Search *Search `form:"search,omitempty" json:"search,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// DeleteEmployeeParams defines parameters for DeleteEmployee.
type DeleteEmployeeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetEmployeeParams defines parameters for GetEmployee.
type GetEmployeeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateEmployeeJSONBody defines parameters for UpdateEmployee.
type UpdateEmployeeJSONBody Employee

// UpdateEmployeeParams defines parameters for UpdateEmployee.
type UpdateEmployeeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand         `form:"expand,omitempty" json:"expand,omitempty"`
	Unset  *EmployeeFields `form:"unset,omitempty" json:"unset,omitempty"`
}

// ListEventStatusesParams defines parameters for ListEventStatuses.
type ListEventStatusesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListEventTypeCategoriesParams defines parameters for ListEventTypeCategories.
type ListEventTypeCategoriesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListEventTypeCategoryGroupsParams defines parameters for ListEventTypeCategoryGroups.
type ListEventTypeCategoryGroupsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListEventTypeGroupsParams defines parameters for ListEventTypeGroups.
type ListEventTypeGroupsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListEventTypesParams defines parameters for ListEventTypes.
type ListEventTypesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// Use filter instead
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// Use filter instead
	To     *time.Time   `form:"to,omitempty" json:"to,omitempty"`
	Filter *EventFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination       *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
	PhoneNumber      *string     `form:"phone_number,omitempty" json:"phone_number,omitempty"`
	PhoneCountryCode *string     `form:"phone_country_code,omitempty" json:"phone_country_code,omitempty"`
}

// CheckinWithPaymentParams defines parameters for CheckinWithPayment.
type CheckinWithPaymentParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand     *Expand `form:"expand,omitempty" json:"expand,omitempty"`
	TerminalId *string `form:"terminal_id,omitempty" json:"terminal_id,omitempty"`
	VoucherId  *string `form:"voucher_id,omitempty" json:"voucher_id,omitempty"`
}

// ListHolidaysParams defines parameters for ListHolidays.
type ListHolidaysParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand         *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter         HolidaysFilter `form:"filter" json:"filter"`
	AcceptLanguage *string        `json:"Accept-Language,omitempty"`
}

// ListIssuersParams defines parameters for ListIssuers.
type ListIssuersParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *IssuersFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListMemosParams defines parameters for ListMemos.
type ListMemosParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand     `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *MemoFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// GetSalesMetricsParams defines parameters for GetSalesMetrics.
type GetSalesMetricsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteNotificationsParams defines parameters for DeleteNotifications.
type DeleteNotificationsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListNotificationsParams defines parameters for ListNotifications.
type ListNotificationsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListOpeningHoursParams defines parameters for ListOpeningHours.
type ListOpeningHoursParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand            `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *OpeningHourFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListPaymentsParams defines parameters for ListPayments.
type ListPaymentsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *PaymentFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`

	// [Search](https://api.noona.is/docs/working-with-the-apis/search)
	Search *Search `form:"search,omitempty" json:"search,omitempty"`
}

// ListCustomPropertiesParams defines parameters for ListCustomProperties.
type ListCustomPropertiesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListResourceGroupsParams defines parameters for ListResourceGroups.
type ListResourceGroupsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListResourcesParams defines parameters for ListResources.
type ListResourcesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Search](https://api.noona.is/docs/working-with-the-apis/search)
	Search *Search `form:"search,omitempty" json:"search,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination      `form:"pagination,omitempty" json:"pagination,omitempty"`
	Filter     *ResourcesFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListRuleSetTemplatesParams defines parameters for ListRuleSetTemplates.
type ListRuleSetTemplatesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListRuleSetsParams defines parameters for ListRuleSets.
type ListRuleSetsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *RuleSetFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListSalesParams defines parameters for ListSales.
type ListSalesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListSettlementsParams defines parameters for ListSettlements.
type ListSettlementsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand           `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *SettlementFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListSMSMessagesParams defines parameters for ListSMSMessages.
type ListSMSMessagesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
	Filter     *SMSFilter  `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListSpacesParams defines parameters for ListSpaces.
type ListSpacesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Search](https://api.noona.is/docs/working-with-the-apis/search)
	Search *Search `form:"search,omitempty" json:"search,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination   `form:"pagination,omitempty" json:"pagination,omitempty"`
	Filter     *SpacesFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// CreateSubscriptionJSONBody defines parameters for CreateSubscription.
type CreateSubscriptionJSONBody PowerupPostBody

// CreateSubscriptionParams defines parameters for CreateSubscription.
type CreateSubscriptionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetSubscriptionBillingInfoParams defines parameters for GetSubscriptionBillingInfo.
type GetSubscriptionBillingInfoParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateBillingInfoJSONBody defines parameters for UpdateBillingInfo.
type UpdateBillingInfoJSONBody BillingCustomer

// UpdateBillingInfoParams defines parameters for UpdateBillingInfo.
type UpdateBillingInfoParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListBillingInvoicesParams defines parameters for ListBillingInvoices.
type ListBillingInvoicesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand         `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *InvoicesFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// CreatePaymentIntentParams defines parameters for CreatePaymentIntent.
type CreatePaymentIntentParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListTerminalsParams defines parameters for ListTerminals.
type ListTerminalsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand          `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *TerminalsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListTimeSlotReservationsParams defines parameters for ListTimeSlotReservations.
type ListTimeSlotReservationsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand                    `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *TimeSlotReservationFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListTimeSlotsParams defines parameters for ListTimeSlots.
type ListTimeSlotsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand       *Expand   `form:"expand,omitempty" json:"expand,omitempty"`
	EmployeeId   *string   `form:"employee_id,omitempty" json:"employee_id,omitempty"`
	ResourceId   *string   `form:"resource_id,omitempty" json:"resource_id,omitempty"`
	EventTypeIds *[]string `form:"event_type_ids,omitempty" json:"event_type_ids,omitempty"`
	EventId      *string   `form:"event_id,omitempty" json:"event_id,omitempty"`
	StartDate    string    `form:"start_date" json:"start_date"`
	EndDate      string    `form:"end_date" json:"end_date"`
}

// ListTransactionsParams defines parameters for ListTransactions.
type ListTransactionsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand             `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *TransactionsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListVATsParams defines parameters for ListVATs.
type ListVATsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListVoucherTemplatesParams defines parameters for ListVoucherTemplates.
type ListVoucherTemplatesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand                `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *VoucherTemplateFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListVouchersParams defines parameters for ListVouchers.
type ListVouchersParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *VoucherFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListWaitlistEntriesParams defines parameters for ListWaitlistEntries.
type ListWaitlistEntriesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand         `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *WaitlistFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListWebhookInvocationsParams defines parameters for ListWebhookInvocations.
type ListWebhookInvocationsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListWebhooksParams defines parameters for ListWebhooks.
type ListWebhooksParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// CreateCustomerGroupJSONBody defines parameters for CreateCustomerGroup.
type CreateCustomerGroupJSONBody CustomerGroup

// CreateCustomerGroupParams defines parameters for CreateCustomerGroup.
type CreateCustomerGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteCustomerGroupParams defines parameters for DeleteCustomerGroup.
type DeleteCustomerGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetCustomerGroupParams defines parameters for GetCustomerGroup.
type GetCustomerGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateCustomerGroupJSONBody defines parameters for UpdateCustomerGroup.
type UpdateCustomerGroupJSONBody CustomerGroup

// UpdateCustomerGroupParams defines parameters for UpdateCustomerGroup.
type UpdateCustomerGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateCustomerJSONBody defines parameters for CreateCustomer.
type CreateCustomerJSONBody Customer

// CreateCustomerParams defines parameters for CreateCustomer.
type CreateCustomerParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteCustomerParams defines parameters for DeleteCustomer.
type DeleteCustomerParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetCustomerParams defines parameters for GetCustomer.
type GetCustomerParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateCustomerJSONBody defines parameters for UpdateCustomer.
type UpdateCustomerJSONBody Customer

// UpdateCustomerParams defines parameters for UpdateCustomer.
type UpdateCustomerParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateEmployeeJSONBody defines parameters for CreateEmployee.
type CreateEmployeeJSONBody Employee

// CreateEmployeeParams defines parameters for CreateEmployee.
type CreateEmployeeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetEnterpriseParams defines parameters for GetEnterprise.
type GetEnterpriseParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateEnterpriseJSONBody defines parameters for UpdateEnterprise.
type UpdateEnterpriseJSONBody Enterprise

// UpdateEnterpriseParams defines parameters for UpdateEnterprise.
type UpdateEnterpriseParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListEnterpriseCompaniesParams defines parameters for ListEnterpriseCompanies.
type ListEnterpriseCompaniesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListPaymentsLegacyParams defines parameters for ListPaymentsLegacy.
type ListPaymentsLegacyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *PaymentFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`

	// [Search](https://api.noona.is/docs/working-with-the-apis/search)
	Search *Search `form:"search,omitempty" json:"search,omitempty"`
}

// ListEnterpriseSettlementAccountsParams defines parameters for ListEnterpriseSettlementAccounts.
type ListEnterpriseSettlementAccountsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteEnterpriseSettlementAccountParams defines parameters for DeleteEnterpriseSettlementAccount.
type DeleteEnterpriseSettlementAccountParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetEnterpriseSettlementAccountParams defines parameters for GetEnterpriseSettlementAccount.
type GetEnterpriseSettlementAccountParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListSettlementsLegacyParams defines parameters for ListSettlementsLegacy.
type ListSettlementsLegacyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand           `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *SettlementFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// ListVoucherTemplatesLegacyParams defines parameters for ListVoucherTemplatesLegacy.
type ListVoucherTemplatesLegacyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand                `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *VoucherTemplateFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// CreateVoucherTemplateLegacyJSONBody defines parameters for CreateVoucherTemplateLegacy.
type CreateVoucherTemplateLegacyJSONBody VoucherTemplateCreate

// CreateVoucherTemplateLegacyParams defines parameters for CreateVoucherTemplateLegacy.
type CreateVoucherTemplateLegacyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListVouchersLegacyParams defines parameters for ListVouchersLegacy.
type ListVouchersLegacyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *VoucherFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// GetVoucherLegacyParams defines parameters for GetVoucherLegacy.
type GetVoucherLegacyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateVoucherLegacyJSONBody defines parameters for UpdateVoucherLegacy.
type UpdateVoucherLegacyJSONBody Voucher

// UpdateVoucherLegacyParams defines parameters for UpdateVoucherLegacy.
type UpdateVoucherLegacyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateEventStatusJSONBody defines parameters for CreateEventStatus.
type CreateEventStatusJSONBody EventStatus

// CreateEventStatusParams defines parameters for CreateEventStatus.
type CreateEventStatusParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteEventStatusParams defines parameters for DeleteEventStatus.
type DeleteEventStatusParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetEventStatusParams defines parameters for GetEventStatus.
type GetEventStatusParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateEventStatusJSONBody defines parameters for UpdateEventStatus.
type UpdateEventStatusJSONBody EventStatus

// UpdateEventStatusParams defines parameters for UpdateEventStatus.
type UpdateEventStatusParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetEventTypeGroupParams defines parameters for GetEventTypeGroup.
type GetEventTypeGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateEventTypeJSONBody defines parameters for CreateEventType.
type CreateEventTypeJSONBody EventType

// CreateEventTypeParams defines parameters for CreateEventType.
type CreateEventTypeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteEventTypeParams defines parameters for DeleteEventType.
type DeleteEventTypeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetEventTypeParams defines parameters for GetEventType.
type GetEventTypeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateEventTypeJSONBody defines parameters for UpdateEventType.
type UpdateEventTypeJSONBody EventType

// UpdateEventTypeParams defines parameters for UpdateEventType.
type UpdateEventTypeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand          `form:"expand,omitempty" json:"expand,omitempty"`
	Unset  *EventTypeFields `form:"unset,omitempty" json:"unset,omitempty"`
}

// CreateEventJSONBody defines parameters for CreateEvent.
type CreateEventJSONBody Event

// CreateEventParams defines parameters for CreateEvent.
type CreateEventParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand                `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *EventCreationBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// DeleteEventParams defines parameters for DeleteEvent.
type DeleteEventParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand                `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *EventDeletionBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// GetEventParams defines parameters for GetEvent.
type GetEventParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateEventJSONBody defines parameters for UpdateEvent.
type UpdateEventJSONBody Event

// UpdateEventParams defines parameters for UpdateEvent.
type UpdateEventParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand              `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *EventUpdateBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// CreateCheckoutForEventParams defines parameters for CreateCheckoutForEvent.
type CreateCheckoutForEventParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand           `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *CheckoutBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// GetCompanyFiscalizationDataParams defines parameters for GetCompanyFiscalizationData.
type GetCompanyFiscalizationDataParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// UpsertCompanyFiscalizationDataJSONBody defines parameters for UpsertCompanyFiscalizationData.
type UpsertCompanyFiscalizationDataJSONBody FiscalizationOnboarding

// GetFiscalizationReportParams defines parameters for GetFiscalizationReport.
type GetFiscalizationReportParams struct {
	From time.Time `form:"from" json:"from"`
	To   time.Time `form:"to" json:"to"`
}

// FiscalizeTransactionJSONBody defines parameters for FiscalizeTransaction.
type FiscalizeTransactionJSONBody struct {
	// The customer's country code in the tax authority's system.
	//
	// Different between markets but an example is PT in Portugal.
	CountryCode *string `json:"country_code,omitempty"`

	// The customer's identification number in the tax authority's system.
	//
	// Different between markets but an example is NIF in Portugal.
	CustomerTaxId *string `json:"customer_tax_id,omitempty"`
}

// FiscalizeTransactionParams defines parameters for FiscalizeTransaction.
type FiscalizeTransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// SendFiscalizedTransactionPDFJSONBody defines parameters for SendFiscalizedTransactionPDF.
type SendFiscalizedTransactionPDFJSONBody struct {
	// The email address to send the PDF to.
	Email *string `json:"email,omitempty"`
}

// RefundFiscalizedTransactionParams defines parameters for RefundFiscalizedTransaction.
type RefundFiscalizedTransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// AdyenCompanyOnboardingStatusParams defines parameters for AdyenCompanyOnboardingStatus.
type AdyenCompanyOnboardingStatusParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// AdyenCompanyOnboardingJSONBody defines parameters for AdyenCompanyOnboarding.
type AdyenCompanyOnboardingJSONBody AdyenOnboardingRequest

// AdyenCompanyOnboardingParams defines parameters for AdyenCompanyOnboarding.
type AdyenCompanyOnboardingParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// AdyenUserOnboardingStatusParams defines parameters for AdyenUserOnboardingStatus.
type AdyenUserOnboardingStatusParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// AdyenUserOnboardingJSONBody defines parameters for AdyenUserOnboarding.
type AdyenUserOnboardingJSONBody AdyenOnboardingRequest

// AdyenUserOnboardingParams defines parameters for AdyenUserOnboarding.
type AdyenUserOnboardingParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListSaltpayCompaniesParams defines parameters for ListSaltpayCompanies.
type ListSaltpayCompaniesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// LinkSaltpayBankAccountJSONBody defines parameters for LinkSaltpayBankAccount.
type LinkSaltpayBankAccountJSONBody SaltpayBankAccount

// LinkSaltpayBankAccountParams defines parameters for LinkSaltpayBankAccount.
type LinkSaltpayBankAccountParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListSaltpayStoresAtCompanyParams defines parameters for ListSaltpayStoresAtCompany.
type ListSaltpayStoresAtCompanyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListSaltpayStoresParams defines parameters for ListSaltpayStores.
type ListSaltpayStoresParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListSaltpayTerminalsParams defines parameters for ListSaltpayTerminals.
type ListSaltpayTerminalsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateSaltpayTerminalJSONBody defines parameters for UpdateSaltpayTerminal.
type UpdateSaltpayTerminalJSONBody SaltpayTerminal

// UpdateSaltpayTerminalParams defines parameters for UpdateSaltpayTerminal.
type UpdateSaltpayTerminalParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateLineItemJSONBody defines parameters for CreateLineItem.
type CreateLineItemJSONBody LineItem

// CreateLineItemParams defines parameters for CreateLineItem.
type CreateLineItemParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteLineItemParams defines parameters for DeleteLineItem.
type DeleteLineItemParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetLineItemParams defines parameters for GetLineItem.
type GetLineItemParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateLineItemJSONBody defines parameters for UpdateLineItem.
type UpdateLineItemJSONBody LineItem

// UpdateLineItemParams defines parameters for UpdateLineItem.
type UpdateLineItemParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateMemoJSONBody defines parameters for CreateMemo.
type CreateMemoJSONBody MemoCreate

// CreateMemoParams defines parameters for CreateMemo.
type CreateMemoParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteMemoParams defines parameters for DeleteMemo.
type DeleteMemoParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetMemoParams defines parameters for GetMemo.
type GetMemoParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateMemoJSONBody defines parameters for UpdateMemo.
type UpdateMemoJSONBody MemoUpdate

// UpdateMemoParams defines parameters for UpdateMemo.
type UpdateMemoParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateNotificationJSONBody defines parameters for CreateNotification.
type CreateNotificationJSONBody NotificationCreate

// DeleteNotificationParams defines parameters for DeleteNotification.
type DeleteNotificationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetNotificationParams defines parameters for GetNotification.
type GetNotificationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListOAuthApplicationsParams defines parameters for ListOAuthApplications.
type ListOAuthApplicationsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateOAuthApplicationJSONBody defines parameters for CreateOAuthApplication.
type CreateOAuthApplicationJSONBody Application

// CreateOAuthApplicationParams defines parameters for CreateOAuthApplication.
type CreateOAuthApplicationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteOAuthApplicationParams defines parameters for DeleteOAuthApplication.
type DeleteOAuthApplicationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetOAuthApplicationParams defines parameters for GetOAuthApplication.
type GetOAuthApplicationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateOAuthApplicationJSONBody defines parameters for UpdateOAuthApplication.
type UpdateOAuthApplicationJSONBody Application

// UpdateOAuthApplicationParams defines parameters for UpdateOAuthApplication.
type UpdateOAuthApplicationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StartOAuthFlowParams defines parameters for StartOAuthFlow.
type StartOAuthFlowParams struct {
	ClientId     string      `form:"client_id" json:"client_id"`
	RedirectUri  string      `form:"redirect_uri" json:"redirect_uri"`
	ResponseType string      `form:"response_type" json:"response_type"`
	Scope        OAuthScopes `form:"scope" json:"scope"`
	State        *string     `form:"state,omitempty" json:"state,omitempty"`
}

// CreateOAuthConsentJSONBody defines parameters for CreateOAuthConsent.
type CreateOAuthConsentJSONBody OAuthConsent

// GetOAuthPublicKeyParams defines parameters for GetOAuthPublicKey.
type GetOAuthPublicKeyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetOAuthTokenJSONBody defines parameters for GetOAuthToken.
type GetOAuthTokenJSONBody OAuthTokenRequest

// GetOAuthTokenParams defines parameters for GetOAuthToken.
type GetOAuthTokenParams struct {
	ClientId     string `form:"client_id" json:"client_id"`
	ClientSecret string `form:"client_secret" json:"client_secret"`
}

// ListPaymentMethodsParams defines parameters for ListPaymentMethods.
type ListPaymentMethodsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetPaymentParams defines parameters for GetPayment.
type GetPaymentParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdatePaymentJSONBody defines parameters for UpdatePayment.
type UpdatePaymentJSONBody Payment

// UpdatePaymentParams defines parameters for UpdatePayment.
type UpdatePaymentParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DownloadPaymentReceiptParams defines parameters for DownloadPaymentReceipt.
type DownloadPaymentReceiptParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// SendPaymentReceiptJSONBody defines parameters for SendPaymentReceipt.
type SendPaymentReceiptJSONBody PaymentReceiptRecipient

// SendPaymentReceiptParams defines parameters for SendPaymentReceipt.
type SendPaymentReceiptParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListPricingParams defines parameters for ListPricing.
type ListPricingParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CalculatePricingParams defines parameters for CalculatePricing.
type CalculatePricingParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// Country code in Alpha-2.
	CountryCode string `form:"country_code" json:"country_code"`

	// Number of staff.
	Staff float64 `form:"staff" json:"staff"`

	// Number of resources.
	Resources float64 `form:"resources" json:"resources"`
}

// GetPricingByCountryCodeParams defines parameters for GetPricingByCountryCode.
type GetPricingByCountryCodeParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// Can optionally be passed to get single product only.
	Product *GetPricingByCountryCodeParamsProduct `form:"product,omitempty" json:"product,omitempty"`
}

// GetPricingByCountryCodeParamsProduct defines parameters for GetPricingByCountryCode.
type GetPricingByCountryCodeParamsProduct string

// ListProductGroupsParams defines parameters for ListProductGroups.
type ListProductGroupsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`
}

// CreateProductGroupJSONBody defines parameters for CreateProductGroup.
type CreateProductGroupJSONBody ProductGroup

// CreateProductGroupParams defines parameters for CreateProductGroup.
type CreateProductGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListGroupsAndProductsParams defines parameters for ListGroupsAndProducts.
type ListGroupsAndProductsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateProductGroupsOrderJSONBody defines parameters for UpdateProductGroupsOrder.
type UpdateProductGroupsOrderJSONBody ProductGroupsOrder

// UpdateProductGroupsOrderParams defines parameters for UpdateProductGroupsOrder.
type UpdateProductGroupsOrderParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteProductGroupParams defines parameters for DeleteProductGroup.
type DeleteProductGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetProductGroupParams defines parameters for GetProductGroup.
type GetProductGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateProductGroupJSONBody defines parameters for UpdateProductGroup.
type UpdateProductGroupJSONBody ProductGroup

// UpdateProductGroupParams defines parameters for UpdateProductGroup.
type UpdateProductGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListProductsParams defines parameters for ListProducts.
type ListProductsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand        `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *ProductFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// [Sorting](https://api.noona.is/docs/working-with-the-apis/sorting)
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// [Pagination](https://api.noona.is/docs/working-with-the-apis/pagination)
	Pagination *Pagination `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Use filter instead.
	Barcode *string `form:"barcode,omitempty" json:"barcode,omitempty"`
}

// CreateProductJSONBody defines parameters for CreateProduct.
type CreateProductJSONBody Product

// CreateProductParams defines parameters for CreateProduct.
type CreateProductParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteProductParams defines parameters for DeleteProduct.
type DeleteProductParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetProductParams defines parameters for GetProduct.
type GetProductParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateProductJSONBody defines parameters for UpdateProduct.
type UpdateProductJSONBody Product

// UpdateProductParams defines parameters for UpdateProduct.
type UpdateProductParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateCustomPropertyJSONBody defines parameters for CreateCustomProperty.
type CreateCustomPropertyJSONBody CustomProperty

// CreateCustomPropertyParams defines parameters for CreateCustomProperty.
type CreateCustomPropertyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteCustomPropertyParams defines parameters for DeleteCustomProperty.
type DeleteCustomPropertyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateCustomPropertyJSONBody defines parameters for UpdateCustomProperty.
type UpdateCustomPropertyJSONBody CustomProperty

// UpdateCustomPropertyParams defines parameters for UpdateCustomProperty.
type UpdateCustomPropertyParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateResourceGroupJSONBody defines parameters for CreateResourceGroup.
type CreateResourceGroupJSONBody ResourceGroupCreate

// CreateResourceGroupParams defines parameters for CreateResourceGroup.
type CreateResourceGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteResourceGroupParams defines parameters for DeleteResourceGroup.
type DeleteResourceGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetResourceGroupParams defines parameters for GetResourceGroup.
type GetResourceGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateResourceGroupJSONBody defines parameters for UpdateResourceGroup.
type UpdateResourceGroupJSONBody ResourceGroupUpdate

// UpdateResourceGroupParams defines parameters for UpdateResourceGroup.
type UpdateResourceGroupParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateResourceJSONBody defines parameters for CreateResource.
type CreateResourceJSONBody Resource

// CreateResourceParams defines parameters for CreateResource.
type CreateResourceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteResourceParams defines parameters for DeleteResource.
type DeleteResourceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetResourceParams defines parameters for GetResource.
type GetResourceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateResourceJSONBody defines parameters for UpdateResource.
type UpdateResourceJSONBody Resource

// UpdateResourceParams defines parameters for UpdateResource.
type UpdateResourceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateRuleSetTemplateJSONBody defines parameters for CreateRuleSetTemplate.
type CreateRuleSetTemplateJSONBody RuleSetTemplateCreate

// CreateRuleSetTemplateParams defines parameters for CreateRuleSetTemplate.
type CreateRuleSetTemplateParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteRuleSetTemplateParams defines parameters for DeleteRuleSetTemplate.
type DeleteRuleSetTemplateParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetRuleSetTemplateParams defines parameters for GetRuleSetTemplate.
type GetRuleSetTemplateParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateRuleSetTemplateJSONBody defines parameters for UpdateRuleSetTemplate.
type UpdateRuleSetTemplateJSONBody RuleSetTemplateUpdate

// UpdateRuleSetTemplateParams defines parameters for UpdateRuleSetTemplate.
type UpdateRuleSetTemplateParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateRuleSetJSONBody defines parameters for CreateRuleSet.
type CreateRuleSetJSONBody RuleSetCreate

// CreateRuleSetParams defines parameters for CreateRuleSet.
type CreateRuleSetParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteRuleSetParams defines parameters for DeleteRuleSet.
type DeleteRuleSetParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetRuleSetParams defines parameters for GetRuleSet.
type GetRuleSetParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateRuleSetJSONBody defines parameters for UpdateRuleSet.
type UpdateRuleSetJSONBody RuleSetUpdate

// UpdateRuleSetParams defines parameters for UpdateRuleSet.
type UpdateRuleSetParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateSaleJSONBody defines parameters for CreateSale.
type CreateSaleJSONBody Sale

// CreateSaleParams defines parameters for CreateSale.
type CreateSaleParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteSaleParams defines parameters for DeleteSale.
type DeleteSaleParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetSaleParams defines parameters for GetSale.
type GetSaleParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateSaleJSONBody defines parameters for UpdateSale.
type UpdateSaleJSONBody Sale

// UpdateSaleParams defines parameters for UpdateSale.
type UpdateSaleParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// RefundMarketplaceSaleParams defines parameters for RefundMarketplaceSale.
type RefundMarketplaceSaleParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// SendTransactionReceiptJSONBody defines parameters for SendTransactionReceipt.
type SendTransactionReceiptJSONBody struct {
	Email *string `json:"email,omitempty"`
	Phone *struct {
		PhoneCountryCode *string `json:"phone_country_code,omitempty"`
		PhoneNumber      *string `json:"phone_number,omitempty"`
	} `json:"phone,omitempty"`
}

// DeprecatedListSubtransactionsParams defines parameters for DeprecatedListSubtransactions.
type DeprecatedListSubtransactionsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeprecatedGetSubtransactionParams defines parameters for DeprecatedGetSubtransaction.
type DeprecatedGetSubtransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateSpaceJSONBody defines parameters for CreateSpace.
type CreateSpaceJSONBody Space

// CreateSpaceParams defines parameters for CreateSpace.
type CreateSpaceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteSpaceParams defines parameters for DeleteSpace.
type DeleteSpaceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetSpaceParams defines parameters for GetSpace.
type GetSpaceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateSpaceJSONBody defines parameters for UpdateSpace.
type UpdateSpaceJSONBody Space

// UpdateSpaceParams defines parameters for UpdateSpace.
type UpdateSpaceParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamBlockedTimesParams defines parameters for StreamBlockedTimes.
type StreamBlockedTimesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand            `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *BlockedTimeFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// StreamEmployeesParams defines parameters for StreamEmployees.
type StreamEmployeesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamEventTypeGroupsParams defines parameters for StreamEventTypeGroups.
type StreamEventTypeGroupsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamEventTypesParams defines parameters for StreamEventTypes.
type StreamEventTypesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamEventsParams defines parameters for StreamEvents.
type StreamEventsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand      `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *EventFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// StreamSalesMetricsParams defines parameters for StreamSalesMetrics.
type StreamSalesMetricsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamNotificationsParams defines parameters for StreamNotifications.
type StreamNotificationsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamProductGroupsParams defines parameters for StreamProductGroups.
type StreamProductGroupsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamProductsParams defines parameters for StreamProducts.
type StreamProductsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamResourcesParams defines parameters for StreamResources.
type StreamResourcesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamSpacesParams defines parameters for StreamSpaces.
type StreamSpacesParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// StreamTimeSlotReservationsParams defines parameters for StreamTimeSlotReservations.
type StreamTimeSlotReservationsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand                    `form:"expand,omitempty" json:"expand,omitempty"`
	Filter *TimeSlotReservationFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// DeleteSubscriptionParams defines parameters for DeleteSubscription.
type DeleteSubscriptionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetSubscriptionParams defines parameters for GetSubscription.
type GetSubscriptionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateSubtransactionJSONBody defines parameters for CreateSubtransaction.
type CreateSubtransactionJSONBody Subtransaction

// CreateSubtransactionParams defines parameters for CreateSubtransaction.
type CreateSubtransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand                         `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *SubtransactionCreationBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// DeleteSubtransactionParams defines parameters for DeleteSubtransaction.
type DeleteSubtransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetSubtransactionParams defines parameters for GetSubtransaction.
type GetSubtransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteTerminalParams defines parameters for DeleteTerminal.
type DeleteTerminalParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetTerminalParams defines parameters for GetTerminal.
type GetTerminalParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateTerminalJSONBody defines parameters for UpdateTerminal.
type UpdateTerminalJSONBody Terminal

// UpdateTerminalParams defines parameters for UpdateTerminal.
type UpdateTerminalParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetOAuthConsentParams defines parameters for GetOAuthConsent.
type GetOAuthConsentParams struct {
	ClientId     string      `form:"client_id" json:"client_id"`
	RedirectUri  string      `form:"redirect_uri" json:"redirect_uri"`
	State        *string     `form:"state,omitempty" json:"state,omitempty"`
	ResponseType string      `form:"response_type" json:"response_type"`
	Scope        OAuthScopes `form:"scope" json:"scope"`
}

// PostOAuthLoginJSONBody defines parameters for PostOAuthLogin.
type PostOAuthLoginJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
}

// GetTimeSlotReservationParams defines parameters for GetTimeSlotReservation.
type GetTimeSlotReservationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateTokenParams defines parameters for CreateToken.
type CreateTokenParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateTransactionJSONBody defines parameters for CreateTransaction.
type CreateTransactionJSONBody Transaction

// CreateTransactionParams defines parameters for CreateTransaction.
type CreateTransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand   *Expand                      `form:"expand,omitempty" json:"expand,omitempty"`
	Behavior *TransactionCreationBehavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// DeleteTransactionParams defines parameters for DeleteTransaction.
type DeleteTransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetTransactionParams defines parameters for GetTransaction.
type GetTransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateTransactionJSONBody defines parameters for UpdateTransaction.
type UpdateTransactionJSONBody Transaction

// UpdateTransactionParams defines parameters for UpdateTransaction.
type UpdateTransactionParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListLineItemsParams defines parameters for ListLineItems.
type ListLineItemsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListSubtransactionsParams defines parameters for ListSubtransactions.
type ListSubtransactionsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateGoogleCalendarConnectionJSONBody defines parameters for CreateGoogleCalendarConnection.
type CreateGoogleCalendarConnectionJSONBody GoogleCalendarConnection

// UserOAuthParams defines parameters for UserOAuth.
type UserOAuthParams struct {
	Provider UserOAuthParamsProvider `form:"provider" json:"provider"`

	// The URI to redirect to after the OAuth flow is complete.
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`
}

// UserOAuthParamsProvider defines parameters for UserOAuth.
type UserOAuthParamsProvider string

// ListUserSettlementAccountsParams defines parameters for ListUserSettlementAccounts.
type ListUserSettlementAccountsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListUserTerminalsParams defines parameters for ListUserTerminals.
type ListUserTerminalsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteUserTerminalParams defines parameters for DeleteUserTerminal.
type DeleteUserTerminalParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetUserTerminalParams defines parameters for GetUserTerminal.
type GetUserTerminalParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListUserTokensParams defines parameters for ListUserTokens.
type ListUserTokensParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateUserTokenJSONBody defines parameters for CreateUserToken.
type CreateUserTokenJSONBody Token

// CreateUserTokenParams defines parameters for CreateUserToken.
type CreateUserTokenParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteUserTokenParams defines parameters for DeleteUserToken.
type DeleteUserTokenParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetUserTokenParams defines parameters for GetUserToken.
type GetUserTokenParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateVoucherTemplateJSONBody defines parameters for CreateVoucherTemplate.
type CreateVoucherTemplateJSONBody VoucherTemplateCreate

// CreateVoucherTemplateParams defines parameters for CreateVoucherTemplate.
type CreateVoucherTemplateParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteVoucherTemplateParams defines parameters for DeleteVoucherTemplate.
type DeleteVoucherTemplateParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// UpdateVoucherTemplateJSONBody defines parameters for UpdateVoucherTemplate.
type UpdateVoucherTemplateJSONBody VoucherTemplateUpdate

// UpdateVoucherTemplateParams defines parameters for UpdateVoucherTemplate.
type UpdateVoucherTemplateParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// DeleteVoucherParams defines parameters for DeleteVoucher.
type DeleteVoucherParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// GetVoucherParams defines parameters for GetVoucher.
type GetVoucherParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// UpdateVoucherJSONBody defines parameters for UpdateVoucher.
type UpdateVoucherJSONBody Voucher

// UpdateVoucherParams defines parameters for UpdateVoucher.
type UpdateVoucherParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select        `form:"select,omitempty" json:"select,omitempty"`
	Unset  *VoucherFields `form:"unset,omitempty" json:"unset,omitempty"`
}

// CreateVoucherNotificationJSONBody defines parameters for CreateVoucherNotification.
type CreateVoucherNotificationJSONBody VoucherNotification

// CreateVoucherNotificationParams defines parameters for CreateVoucherNotification.
type CreateVoucherNotificationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`
}

// CreateWaitlistEntryJSONBody defines parameters for CreateWaitlistEntry.
type CreateWaitlistEntryJSONBody WaitlistEntryCreate

// CreateWaitlistEntryParams defines parameters for CreateWaitlistEntry.
type CreateWaitlistEntryParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteWaitlistEntryParams defines parameters for DeleteWaitlistEntry.
type DeleteWaitlistEntryParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetWaitlistEntryParams defines parameters for GetWaitlistEntry.
type GetWaitlistEntryParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateWaitlistEntryJSONBody defines parameters for UpdateWaitlistEntry.
type UpdateWaitlistEntryJSONBody WaitlistEntryUpdate

// UpdateWaitlistEntryParams defines parameters for UpdateWaitlistEntry.
type UpdateWaitlistEntryParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand              `form:"expand,omitempty" json:"expand,omitempty"`
	Unset  *WaitlistEntryFields `form:"unset,omitempty" json:"unset,omitempty"`
}

// GetWebhookInvocationParams defines parameters for GetWebhookInvocation.
type GetWebhookInvocationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateWebhookInvocationJSONBody defines parameters for UpdateWebhookInvocation.
type UpdateWebhookInvocationJSONBody WebhookInvocation

// UpdateWebhookInvocationParams defines parameters for UpdateWebhookInvocation.
type UpdateWebhookInvocationParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateWebhookJSONBody defines parameters for CreateWebhook.
type CreateWebhookJSONBody Webhook

// CreateWebhookParams defines parameters for CreateWebhook.
type CreateWebhookParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// ListWebhookEventsParams defines parameters for ListWebhookEvents.
type ListWebhookEventsParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteWebhookParams defines parameters for DeleteWebhook.
type DeleteWebhookParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetWebhookParams defines parameters for GetWebhook.
type GetWebhookParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// UpdateWebhookJSONBody defines parameters for UpdateWebhook.
type UpdateWebhookJSONBody Webhook

// UpdateWebhookParams defines parameters for UpdateWebhook.
type UpdateWebhookParams struct {
	// [Field Selector](https://api.noona.is/docs/working-with-the-apis/select)
	Select *Select `form:"select,omitempty" json:"select,omitempty"`

	// [Expandable attributes](https://api.noona.is/docs/working-with-the-apis/expandable_attributes)
	Expand *Expand `form:"expand,omitempty" json:"expand,omitempty"`
}

// CreateBlockedTimeJSONRequestBody defines body for CreateBlockedTime for application/json ContentType.
type CreateBlockedTimeJSONRequestBody CreateBlockedTimeJSONBody

// UpdateBlockedTimeJSONRequestBody defines body for UpdateBlockedTime for application/json ContentType.
type UpdateBlockedTimeJSONRequestBody UpdateBlockedTimeJSONBody

// CreateCompanyJSONRequestBody defines body for CreateCompany for application/json ContentType.
type CreateCompanyJSONRequestBody CreateCompanyJSONBody

// UpdateCompanyJSONRequestBody defines body for UpdateCompany for application/json ContentType.
type UpdateCompanyJSONRequestBody UpdateCompanyJSONBody

// UpdateEmployeeJSONRequestBody defines body for UpdateEmployee for application/json ContentType.
type UpdateEmployeeJSONRequestBody UpdateEmployeeJSONBody

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody CreateSubscriptionJSONBody

// UpdateBillingInfoJSONRequestBody defines body for UpdateBillingInfo for application/json ContentType.
type UpdateBillingInfoJSONRequestBody UpdateBillingInfoJSONBody

// CreateCustomerGroupJSONRequestBody defines body for CreateCustomerGroup for application/json ContentType.
type CreateCustomerGroupJSONRequestBody CreateCustomerGroupJSONBody

// UpdateCustomerGroupJSONRequestBody defines body for UpdateCustomerGroup for application/json ContentType.
type UpdateCustomerGroupJSONRequestBody UpdateCustomerGroupJSONBody

// CreateCustomerJSONRequestBody defines body for CreateCustomer for application/json ContentType.
type CreateCustomerJSONRequestBody CreateCustomerJSONBody

// UpdateCustomerJSONRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdateCustomerJSONBody

// CreateEmployeeJSONRequestBody defines body for CreateEmployee for application/json ContentType.
type CreateEmployeeJSONRequestBody CreateEmployeeJSONBody

// UpdateEnterpriseJSONRequestBody defines body for UpdateEnterprise for application/json ContentType.
type UpdateEnterpriseJSONRequestBody UpdateEnterpriseJSONBody

// CreateVoucherTemplateLegacyJSONRequestBody defines body for CreateVoucherTemplateLegacy for application/json ContentType.
type CreateVoucherTemplateLegacyJSONRequestBody CreateVoucherTemplateLegacyJSONBody

// UpdateVoucherLegacyJSONRequestBody defines body for UpdateVoucherLegacy for application/json ContentType.
type UpdateVoucherLegacyJSONRequestBody UpdateVoucherLegacyJSONBody

// CreateEventStatusJSONRequestBody defines body for CreateEventStatus for application/json ContentType.
type CreateEventStatusJSONRequestBody CreateEventStatusJSONBody

// UpdateEventStatusJSONRequestBody defines body for UpdateEventStatus for application/json ContentType.
type UpdateEventStatusJSONRequestBody UpdateEventStatusJSONBody

// CreateEventTypeJSONRequestBody defines body for CreateEventType for application/json ContentType.
type CreateEventTypeJSONRequestBody CreateEventTypeJSONBody

// UpdateEventTypeJSONRequestBody defines body for UpdateEventType for application/json ContentType.
type UpdateEventTypeJSONRequestBody UpdateEventTypeJSONBody

// CreateEventJSONRequestBody defines body for CreateEvent for application/json ContentType.
type CreateEventJSONRequestBody CreateEventJSONBody

// UpdateEventJSONRequestBody defines body for UpdateEvent for application/json ContentType.
type UpdateEventJSONRequestBody UpdateEventJSONBody

// UpsertCompanyFiscalizationDataJSONRequestBody defines body for UpsertCompanyFiscalizationData for application/json ContentType.
type UpsertCompanyFiscalizationDataJSONRequestBody UpsertCompanyFiscalizationDataJSONBody

// FiscalizeTransactionJSONRequestBody defines body for FiscalizeTransaction for application/json ContentType.
type FiscalizeTransactionJSONRequestBody FiscalizeTransactionJSONBody

// SendFiscalizedTransactionPDFJSONRequestBody defines body for SendFiscalizedTransactionPDF for application/json ContentType.
type SendFiscalizedTransactionPDFJSONRequestBody SendFiscalizedTransactionPDFJSONBody

// AdyenCompanyOnboardingJSONRequestBody defines body for AdyenCompanyOnboarding for application/json ContentType.
type AdyenCompanyOnboardingJSONRequestBody AdyenCompanyOnboardingJSONBody

// AdyenUserOnboardingJSONRequestBody defines body for AdyenUserOnboarding for application/json ContentType.
type AdyenUserOnboardingJSONRequestBody AdyenUserOnboardingJSONBody

// LinkSaltpayBankAccountJSONRequestBody defines body for LinkSaltpayBankAccount for application/json ContentType.
type LinkSaltpayBankAccountJSONRequestBody LinkSaltpayBankAccountJSONBody

// UpdateSaltpayTerminalJSONRequestBody defines body for UpdateSaltpayTerminal for application/json ContentType.
type UpdateSaltpayTerminalJSONRequestBody UpdateSaltpayTerminalJSONBody

// CreateLineItemJSONRequestBody defines body for CreateLineItem for application/json ContentType.
type CreateLineItemJSONRequestBody CreateLineItemJSONBody

// UpdateLineItemJSONRequestBody defines body for UpdateLineItem for application/json ContentType.
type UpdateLineItemJSONRequestBody UpdateLineItemJSONBody

// CreateMemoJSONRequestBody defines body for CreateMemo for application/json ContentType.
type CreateMemoJSONRequestBody CreateMemoJSONBody

// UpdateMemoJSONRequestBody defines body for UpdateMemo for application/json ContentType.
type UpdateMemoJSONRequestBody UpdateMemoJSONBody

// CreateNotificationJSONRequestBody defines body for CreateNotification for application/json ContentType.
type CreateNotificationJSONRequestBody CreateNotificationJSONBody

// CreateOAuthApplicationJSONRequestBody defines body for CreateOAuthApplication for application/json ContentType.
type CreateOAuthApplicationJSONRequestBody CreateOAuthApplicationJSONBody

// UpdateOAuthApplicationJSONRequestBody defines body for UpdateOAuthApplication for application/json ContentType.
type UpdateOAuthApplicationJSONRequestBody UpdateOAuthApplicationJSONBody

// CreateOAuthConsentJSONRequestBody defines body for CreateOAuthConsent for application/json ContentType.
type CreateOAuthConsentJSONRequestBody CreateOAuthConsentJSONBody

// GetOAuthTokenJSONRequestBody defines body for GetOAuthToken for application/json ContentType.
type GetOAuthTokenJSONRequestBody GetOAuthTokenJSONBody

// UpdatePaymentJSONRequestBody defines body for UpdatePayment for application/json ContentType.
type UpdatePaymentJSONRequestBody UpdatePaymentJSONBody

// SendPaymentReceiptJSONRequestBody defines body for SendPaymentReceipt for application/json ContentType.
type SendPaymentReceiptJSONRequestBody SendPaymentReceiptJSONBody

// CreateProductGroupJSONRequestBody defines body for CreateProductGroup for application/json ContentType.
type CreateProductGroupJSONRequestBody CreateProductGroupJSONBody

// UpdateProductGroupsOrderJSONRequestBody defines body for UpdateProductGroupsOrder for application/json ContentType.
type UpdateProductGroupsOrderJSONRequestBody UpdateProductGroupsOrderJSONBody

// UpdateProductGroupJSONRequestBody defines body for UpdateProductGroup for application/json ContentType.
type UpdateProductGroupJSONRequestBody UpdateProductGroupJSONBody

// CreateProductJSONRequestBody defines body for CreateProduct for application/json ContentType.
type CreateProductJSONRequestBody CreateProductJSONBody

// UpdateProductJSONRequestBody defines body for UpdateProduct for application/json ContentType.
type UpdateProductJSONRequestBody UpdateProductJSONBody

// CreateCustomPropertyJSONRequestBody defines body for CreateCustomProperty for application/json ContentType.
type CreateCustomPropertyJSONRequestBody CreateCustomPropertyJSONBody

// UpdateCustomPropertyJSONRequestBody defines body for UpdateCustomProperty for application/json ContentType.
type UpdateCustomPropertyJSONRequestBody UpdateCustomPropertyJSONBody

// CreateResourceGroupJSONRequestBody defines body for CreateResourceGroup for application/json ContentType.
type CreateResourceGroupJSONRequestBody CreateResourceGroupJSONBody

// UpdateResourceGroupJSONRequestBody defines body for UpdateResourceGroup for application/json ContentType.
type UpdateResourceGroupJSONRequestBody UpdateResourceGroupJSONBody

// CreateResourceJSONRequestBody defines body for CreateResource for application/json ContentType.
type CreateResourceJSONRequestBody CreateResourceJSONBody

// UpdateResourceJSONRequestBody defines body for UpdateResource for application/json ContentType.
type UpdateResourceJSONRequestBody UpdateResourceJSONBody

// CreateRuleSetTemplateJSONRequestBody defines body for CreateRuleSetTemplate for application/json ContentType.
type CreateRuleSetTemplateJSONRequestBody CreateRuleSetTemplateJSONBody

// UpdateRuleSetTemplateJSONRequestBody defines body for UpdateRuleSetTemplate for application/json ContentType.
type UpdateRuleSetTemplateJSONRequestBody UpdateRuleSetTemplateJSONBody

// CreateRuleSetJSONRequestBody defines body for CreateRuleSet for application/json ContentType.
type CreateRuleSetJSONRequestBody CreateRuleSetJSONBody

// UpdateRuleSetJSONRequestBody defines body for UpdateRuleSet for application/json ContentType.
type UpdateRuleSetJSONRequestBody UpdateRuleSetJSONBody

// CreateSaleJSONRequestBody defines body for CreateSale for application/json ContentType.
type CreateSaleJSONRequestBody CreateSaleJSONBody

// UpdateSaleJSONRequestBody defines body for UpdateSale for application/json ContentType.
type UpdateSaleJSONRequestBody UpdateSaleJSONBody

// SendTransactionReceiptJSONRequestBody defines body for SendTransactionReceipt for application/json ContentType.
type SendTransactionReceiptJSONRequestBody SendTransactionReceiptJSONBody

// CreateSpaceJSONRequestBody defines body for CreateSpace for application/json ContentType.
type CreateSpaceJSONRequestBody CreateSpaceJSONBody

// UpdateSpaceJSONRequestBody defines body for UpdateSpace for application/json ContentType.
type UpdateSpaceJSONRequestBody UpdateSpaceJSONBody

// CreateSubtransactionJSONRequestBody defines body for CreateSubtransaction for application/json ContentType.
type CreateSubtransactionJSONRequestBody CreateSubtransactionJSONBody

// UpdateTerminalJSONRequestBody defines body for UpdateTerminal for application/json ContentType.
type UpdateTerminalJSONRequestBody UpdateTerminalJSONBody

// PostOAuthLoginJSONRequestBody defines body for PostOAuthLogin for application/json ContentType.
type PostOAuthLoginJSONRequestBody PostOAuthLoginJSONBody

// CreateTransactionJSONRequestBody defines body for CreateTransaction for application/json ContentType.
type CreateTransactionJSONRequestBody CreateTransactionJSONBody

// UpdateTransactionJSONRequestBody defines body for UpdateTransaction for application/json ContentType.
type UpdateTransactionJSONRequestBody UpdateTransactionJSONBody

// CreateGoogleCalendarConnectionJSONRequestBody defines body for CreateGoogleCalendarConnection for application/json ContentType.
type CreateGoogleCalendarConnectionJSONRequestBody CreateGoogleCalendarConnectionJSONBody

// CreateUserTokenJSONRequestBody defines body for CreateUserToken for application/json ContentType.
type CreateUserTokenJSONRequestBody CreateUserTokenJSONBody

// CreateVoucherTemplateJSONRequestBody defines body for CreateVoucherTemplate for application/json ContentType.
type CreateVoucherTemplateJSONRequestBody CreateVoucherTemplateJSONBody

// UpdateVoucherTemplateJSONRequestBody defines body for UpdateVoucherTemplate for application/json ContentType.
type UpdateVoucherTemplateJSONRequestBody UpdateVoucherTemplateJSONBody

// UpdateVoucherJSONRequestBody defines body for UpdateVoucher for application/json ContentType.
type UpdateVoucherJSONRequestBody UpdateVoucherJSONBody

// CreateVoucherNotificationJSONRequestBody defines body for CreateVoucherNotification for application/json ContentType.
type CreateVoucherNotificationJSONRequestBody CreateVoucherNotificationJSONBody

// CreateWaitlistEntryJSONRequestBody defines body for CreateWaitlistEntry for application/json ContentType.
type CreateWaitlistEntryJSONRequestBody CreateWaitlistEntryJSONBody

// UpdateWaitlistEntryJSONRequestBody defines body for UpdateWaitlistEntry for application/json ContentType.
type UpdateWaitlistEntryJSONRequestBody UpdateWaitlistEntryJSONBody

// UpdateWebhookInvocationJSONRequestBody defines body for UpdateWebhookInvocation for application/json ContentType.
type UpdateWebhookInvocationJSONRequestBody UpdateWebhookInvocationJSONBody

// CreateWebhookJSONRequestBody defines body for CreateWebhook for application/json ContentType.
type CreateWebhookJSONRequestBody CreateWebhookJSONBody

// UpdateWebhookJSONRequestBody defines body for UpdateWebhook for application/json ContentType.
type UpdateWebhookJSONRequestBody UpdateWebhookJSONBody

func (t AdyenTransferInstrument) AsAdyenBankAccount() (AdyenBankAccount, error) {
	var body AdyenBankAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *AdyenTransferInstrument) FromAdyenBankAccount(v AdyenBankAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t AdyenTransferInstrument) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdyenTransferInstrument) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t CallbackData_Data) AsEvent() (Event, error) {
	var body Event
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *CallbackData_Data) FromEvent(v Event) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t CallbackData_Data) AsTransaction() (Transaction, error) {
	var body Transaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *CallbackData_Data) FromTransaction(v Transaction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t CallbackData_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CallbackData_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t CommissionConfig) AsCommissionRates() (CommissionRates, error) {
	var body CommissionRates
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *CommissionConfig) FromCommissionRates(v CommissionRates) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t CommissionConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CommissionConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t Event_Customer) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Event_Customer) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Event_Customer) AsCustomer() (Customer, error) {
	var body Customer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Event_Customer) FromCustomer(v Customer) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Event_Customer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Event_Customer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t Event_RecurringEvent) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Event_RecurringEvent) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Event_RecurringEvent) AsEvent() (Event, error) {
	var body Event
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Event_RecurringEvent) FromEvent(v Event) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Event_RecurringEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Event_RecurringEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t Event_Space) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Event_Space) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Event_Space) AsSpace() (Space, error) {
	var body Space
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Event_Space) FromSpace(v Space) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Event_Space) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Event_Space) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t EventCheckinResult_Customer) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *EventCheckinResult_Customer) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t EventCheckinResult_Customer) AsCustomer() (Customer, error) {
	var body Customer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *EventCheckinResult_Customer) FromCustomer(v Customer) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t EventCheckinResult_Customer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EventCheckinResult_Customer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t EventCheckinResult_RecurringEvent) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *EventCheckinResult_RecurringEvent) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t EventCheckinResult_RecurringEvent) AsEvent() (Event, error) {
	var body Event
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *EventCheckinResult_RecurringEvent) FromEvent(v Event) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t EventCheckinResult_RecurringEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EventCheckinResult_RecurringEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t EventCheckinResult_Space) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *EventCheckinResult_Space) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t EventCheckinResult_Space) AsSpace() (Space, error) {
	var body Space
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *EventCheckinResult_Space) FromSpace(v Space) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t EventCheckinResult_Space) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EventCheckinResult_Space) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableActor) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableActor) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableActor) AsActor() (Actor, error) {
	var body Actor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableActor) FromActor(v Actor) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableActor) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableActor) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableApp) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableApp) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableApp) AsApp() (App, error) {
	var body App
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableApp) FromApp(v App) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableApp) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableApp) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableCompany) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableCompany) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableCompany) AsCompany() (Company, error) {
	var body Company
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableCompany) FromCompany(v Company) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableCompany) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableCompany) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableCustomer) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableCustomer) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableCustomer) AsCustomer() (Customer, error) {
	var body Customer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableCustomer) FromCustomer(v Customer) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableCustomer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableCustomer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableCustomerGroup) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableCustomerGroup) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableCustomerGroup) AsCustomerGroup() (CustomerGroup, error) {
	var body CustomerGroup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableCustomerGroup) FromCustomerGroup(v CustomerGroup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableCustomerGroup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableCustomerGroup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableEmployee) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEmployee) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEmployee) AsEmployee() (Employee, error) {
	var body Employee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEmployee) FromEmployee(v Employee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEmployee) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableEmployee) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableEnterprise) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEnterprise) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEnterprise) AsEnterprise() (Enterprise, error) {
	var body Enterprise
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEnterprise) FromEnterprise(v Enterprise) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEnterprise) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableEnterprise) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableEvent) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEvent) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEvent) AsEvent() (Event, error) {
	var body Event
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEvent) FromEvent(v Event) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableEventType) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventType) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventType) AsEventType() (EventType, error) {
	var body EventType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventType) FromEventType(v EventType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableEventType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableEventTypeCategory) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventTypeCategory) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventTypeCategory) AsEventTypeCategory() (EventTypeCategory, error) {
	var body EventTypeCategory
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventTypeCategory) FromEventTypeCategory(v EventTypeCategory) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventTypeCategory) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableEventTypeCategory) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableEventTypeCategoryGroup) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventTypeCategoryGroup) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventTypeCategoryGroup) AsEventTypeCategoryGroup() (EventTypeCategoryGroup, error) {
	var body EventTypeCategoryGroup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventTypeCategoryGroup) FromEventTypeCategoryGroup(v EventTypeCategoryGroup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventTypeCategoryGroup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableEventTypeCategoryGroup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableEventTypeGroup) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventTypeGroup) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventTypeGroup) AsEventTypeGroup() (EventTypeGroup, error) {
	var body EventTypeGroup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableEventTypeGroup) FromEventTypeGroup(v EventTypeGroup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableEventTypeGroup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableEventTypeGroup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableGoogleCalendarConnection) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableGoogleCalendarConnection) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableGoogleCalendarConnection) AsGoogleCalendarConnection() (GoogleCalendarConnection, error) {
	var body GoogleCalendarConnection
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableGoogleCalendarConnection) FromGoogleCalendarConnection(v GoogleCalendarConnection) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableGoogleCalendarConnection) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableGoogleCalendarConnection) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableIssuer) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableIssuer) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableIssuer) AsIssuer() (Issuer, error) {
	var body Issuer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableIssuer) FromIssuer(v Issuer) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableIssuer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableIssuer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableLineItem) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableLineItem) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableLineItem) AsLineItem() (LineItem, error) {
	var body LineItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableLineItem) FromLineItem(v LineItem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableLineItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableLineItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableMarketplaceUser) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableMarketplaceUser) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableMarketplaceUser) AsMarketplaceUser() (MarketplaceUser, error) {
	var body MarketplaceUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableMarketplaceUser) FromMarketplaceUser(v MarketplaceUser) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableMarketplaceUser) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableMarketplaceUser) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandablePayment) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandablePayment) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandablePayment) AsPayment() (Payment, error) {
	var body Payment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandablePayment) FromPayment(v Payment) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandablePayment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandablePayment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableProduct) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableProduct) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableProduct) AsProduct() (Product, error) {
	var body Product
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableProduct) FromProduct(v Product) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableProduct) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableProduct) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableResource) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableResource) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableResource) AsResource() (Resource, error) {
	var body Resource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableResource) FromResource(v Resource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableResource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableResource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableResourceGroup) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableResourceGroup) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableResourceGroup) AsResourceGroup() (ResourceGroup, error) {
	var body ResourceGroup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableResourceGroup) FromResourceGroup(v ResourceGroup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableResourceGroup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableResourceGroup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableRole) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableRole) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableRole) AsRole() (Role, error) {
	var body Role
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableRole) FromRole(v Role) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableRole) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableRole) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableSale) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSale) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSale) AsSale() (Sale, error) {
	var body Sale
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSale) FromSale(v Sale) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSale) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableSale) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableSettlementAccount) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSettlementAccount) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSettlementAccount) AsSettlementAccount() (SettlementAccount, error) {
	var body SettlementAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSettlementAccount) FromSettlementAccount(v SettlementAccount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSettlementAccount) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableSettlementAccount) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableSpace) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSpace) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSpace) AsSpace() (Space, error) {
	var body Space
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSpace) FromSpace(v Space) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSpace) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableSpace) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableSubtransaction) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSubtransaction) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSubtransaction) AsSubtransaction() (Subtransaction, error) {
	var body Subtransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableSubtransaction) FromSubtransaction(v Subtransaction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableSubtransaction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableSubtransaction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableTransaction) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableTransaction) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableTransaction) AsTransaction() (Transaction, error) {
	var body Transaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableTransaction) FromTransaction(v Transaction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableTransaction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableTransaction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableVAT) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableVAT) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableVAT) AsVAT() (VAT, error) {
	var body VAT
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableVAT) FromVAT(v VAT) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableVAT) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableVAT) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableVoucher) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableVoucher) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableVoucher) AsVoucher() (Voucher, error) {
	var body Voucher
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableVoucher) FromVoucher(v Voucher) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableVoucher) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableVoucher) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableVoucherTemplate) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableVoucherTemplate) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableVoucherTemplate) AsVoucherTemplate() (VoucherTemplate, error) {
	var body VoucherTemplate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableVoucherTemplate) FromVoucherTemplate(v VoucherTemplate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableVoucherTemplate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableVoucherTemplate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t ExpandableWebhook) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableWebhook) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableWebhook) AsWebhook() (Webhook, error) {
	var body Webhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *ExpandableWebhook) FromWebhook(v Webhook) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ExpandableWebhook) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExpandableWebhook) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t FiscalizationOnboardingData) AsFiscalizationOnboardingDataSaltPay() (FiscalizationOnboardingDataSaltPay, error) {
	var body FiscalizationOnboardingDataSaltPay
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *FiscalizationOnboardingData) FromFiscalizationOnboardingDataSaltPay(v FiscalizationOnboardingDataSaltPay) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t FiscalizationOnboardingData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FiscalizationOnboardingData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t FiscalizationRecordData) AsFiscalizationRecordDataSaltPay() (FiscalizationRecordDataSaltPay, error) {
	var body FiscalizationRecordDataSaltPay
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *FiscalizationRecordData) FromFiscalizationRecordDataSaltPay(v FiscalizationRecordDataSaltPay) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t FiscalizationRecordData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FiscalizationRecordData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t LineItemVoucherData) AsLineItemVoucherDataService() (LineItemVoucherDataService, error) {
	var body LineItemVoucherDataService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *LineItemVoucherData) FromLineItemVoucherDataService(v LineItemVoucherDataService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t LineItemVoucherData) AsLineItemVoucherDataAmount() (LineItemVoucherDataAmount, error) {
	var body LineItemVoucherDataAmount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *LineItemVoucherData) FromLineItemVoucherDataAmount(v LineItemVoucherDataAmount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t LineItemVoucherData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LineItemVoucherData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t Notification) AsNotificationLegacy() (NotificationLegacy, error) {
	var body NotificationLegacy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Notification) FromNotificationLegacy(v NotificationLegacy) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Notification) AsNotificationSurvey() (NotificationSurvey, error) {
	var body NotificationSurvey
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Notification) FromNotificationSurvey(v NotificationSurvey) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Notification) AsNotificationGeneric() (NotificationGeneric, error) {
	var body NotificationGeneric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Notification) FromNotificationGeneric(v NotificationGeneric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Notification) AsNotificationEvent() (NotificationEvent, error) {
	var body NotificationEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Notification) FromNotificationEvent(v NotificationEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Notification) AsNotificationWaitlistEntry() (NotificationWaitlistEntry, error) {
	var body NotificationWaitlistEntry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Notification) FromNotificationWaitlistEntry(v NotificationWaitlistEntry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Notification) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Notification) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t Rule) AsAvailabilityRule() (AvailabilityRule, error) {
	var body AvailabilityRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Rule) FromAvailabilityRule(v AvailabilityRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Rule) AsOnlineBookingsRule() (OnlineBookingsRule, error) {
	var body OnlineBookingsRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Rule) FromOnlineBookingsRule(v OnlineBookingsRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Rule) AsMaxTotalPaxRule() (MaxTotalPaxRule, error) {
	var body MaxTotalPaxRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *Rule) FromMaxTotalPaxRule(v MaxTotalPaxRule) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Rule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Rule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t SubtransactionData) AsSubtransactionDataTerminal() (SubtransactionDataTerminal, error) {
	var body SubtransactionDataTerminal
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *SubtransactionData) FromSubtransactionDataTerminal(v SubtransactionDataTerminal) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t SubtransactionData) AsSubtransactionDataVoucher() (SubtransactionDataVoucher, error) {
	var body SubtransactionDataVoucher
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *SubtransactionData) FromSubtransactionDataVoucher(v SubtransactionDataVoucher) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t SubtransactionData) AsSubtransactionDataPrePayment() (SubtransactionDataPrePayment, error) {
	var body SubtransactionDataPrePayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *SubtransactionData) FromSubtransactionDataPrePayment(v SubtransactionDataPrePayment) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t SubtransactionData) AsSubtransactionDataPaylink() (SubtransactionDataPaylink, error) {
	var body SubtransactionDataPaylink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *SubtransactionData) FromSubtransactionDataPaylink(v SubtransactionDataPaylink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t SubtransactionData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubtransactionData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t UnifiedActivity) AsPaymentActivity() (PaymentActivity, error) {
	var body PaymentActivity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *UnifiedActivity) FromPaymentActivity(v PaymentActivity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t UnifiedActivity) AsCustomerActivity() (CustomerActivity, error) {
	var body CustomerActivity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *UnifiedActivity) FromCustomerActivity(v CustomerActivity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t UnifiedActivity) AsEventTypeActivity() (EventTypeActivity, error) {
	var body EventTypeActivity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *UnifiedActivity) FromEventTypeActivity(v EventTypeActivity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t UnifiedActivity) AsEventActivity() (EventActivity, error) {
	var body EventActivity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *UnifiedActivity) FromEventActivity(v EventActivity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t UnifiedActivity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UnifiedActivity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t VoucherData) AsVoucherDataService() (VoucherDataService, error) {
	var body VoucherDataService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *VoucherData) FromVoucherDataService(v VoucherDataService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t VoucherData) AsVoucherDataAmount() (VoucherDataAmount, error) {
	var body VoucherDataAmount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *VoucherData) FromVoucherDataAmount(v VoucherDataAmount) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t VoucherData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VoucherData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t MultiValue) AsString() (String, error) {
	var body String
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *MultiValue) FromString(v String) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t MultiValue) AsInteger() (Integer, error) {
	var body Integer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *MultiValue) FromInteger(v Integer) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t MultiValue) AsDateTime() (DateTime, error) {
	var body DateTime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *MultiValue) FromDateTime(v DateTime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t MultiValue) AsBoolean() (Boolean, error) {
	var body Boolean
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *MultiValue) FromBoolean(v Boolean) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t MultiValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MultiValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListCustomerActivities request
	ListCustomerActivities(ctx context.Context, customerId string, params *ListCustomerActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventTypeActivities request
	ListEventTypeActivities(ctx context.Context, eventTypeId string, params *ListEventTypeActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventActivities request
	ListEventActivities(ctx context.Context, eventId string, params *ListEventActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentActivities request
	ListPaymentActivities(ctx context.Context, paymentId string, params *ListPaymentActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBlockedTime request with any body
	CreateBlockedTimeWithBody(ctx context.Context, params *CreateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBlockedTime(ctx context.Context, params *CreateBlockedTimeParams, body CreateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBlockedTime request
	DeleteBlockedTime(ctx context.Context, blockedTimeId string, params *DeleteBlockedTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockedTime request
	GetBlockedTime(ctx context.Context, blockedTimeId string, params *GetBlockedTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBlockedTime request with any body
	UpdateBlockedTimeWithBody(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBlockedTime(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, body UpdateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanies request
	GetCompanies(ctx context.Context, params *GetCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCompany request with any body
	CreateCompanyWithBody(ctx context.Context, params *CreateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCompany(ctx context.Context, params *CreateCompanyParams, body CreateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompany request
	GetCompany(ctx context.Context, companyId string, params *GetCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCompany request with any body
	UpdateCompanyWithBody(ctx context.Context, companyId string, params *UpdateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCompany(ctx context.Context, companyId string, params *UpdateCompanyParams, body UpdateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllCompanyActivities request
	ListAllCompanyActivities(ctx context.Context, companyId string, params *ListAllCompanyActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, companyId string, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, companyId string, appId string, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableApp request
	DisableApp(ctx context.Context, companyId string, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBlockedTimes request
	ListBlockedTimes(ctx context.Context, companyId string, params *ListBlockedTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClaims request
	ListClaims(ctx context.Context, companyId string, params *ListClaimsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomerGroups request
	ListCustomerGroups(ctx context.Context, companyId string, params *ListCustomerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomers request
	ListCustomers(ctx context.Context, companyId string, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEmployees request
	ListEmployees(ctx context.Context, companyId string, params *ListEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEmployee request
	DeleteEmployee(ctx context.Context, companyId string, employeeId string, params *DeleteEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmployee request
	GetEmployee(ctx context.Context, companyId string, employeeId string, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEmployee request with any body
	UpdateEmployeeWithBody(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEmployee(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventStatuses request
	ListEventStatuses(ctx context.Context, companyId string, params *ListEventStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventTypeCategories request
	ListEventTypeCategories(ctx context.Context, companyId string, params *ListEventTypeCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventTypeCategoryGroups request
	ListEventTypeCategoryGroups(ctx context.Context, companyId string, params *ListEventTypeCategoryGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventTypeGroups request
	ListEventTypeGroups(ctx context.Context, companyId string, params *ListEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEventTypes request
	ListEventTypes(ctx context.Context, companyId string, params *ListEventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvents request
	ListEvents(ctx context.Context, companyId string, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckinWithPayment request
	CheckinWithPayment(ctx context.Context, companyId string, id string, params *CheckinWithPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHolidays request
	ListHolidays(ctx context.Context, companyId string, params *ListHolidaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIssuers request
	ListIssuers(ctx context.Context, companyId string, params *ListIssuersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMemos request
	ListMemos(ctx context.Context, companyId string, params *ListMemosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSalesMetrics request
	GetSalesMetrics(ctx context.Context, companyId string, params *GetSalesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotifications request
	DeleteNotifications(ctx context.Context, companyId string, params *DeleteNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNotifications request
	ListNotifications(ctx context.Context, companyId string, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOpeningHours request
	ListOpeningHours(ctx context.Context, companyId string, params *ListOpeningHoursParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPayments request
	ListPayments(ctx context.Context, companyId string, params *ListPaymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomProperties request
	ListCustomProperties(ctx context.Context, companyId string, params *ListCustomPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceGroups request
	ListResourceGroups(ctx context.Context, companyId string, params *ListResourceGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResources request
	ListResources(ctx context.Context, companyId string, params *ListResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuleSetTemplates request
	ListRuleSetTemplates(ctx context.Context, companyId string, params *ListRuleSetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuleSets request
	ListRuleSets(ctx context.Context, companyId string, params *ListRuleSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSales request
	ListSales(ctx context.Context, companyId string, params *ListSalesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSettlements request
	ListSettlements(ctx context.Context, companyId string, params *ListSettlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSMSMessages request
	ListSMSMessages(ctx context.Context, companyId string, params *ListSMSMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpaces request
	ListSpaces(ctx context.Context, companyId string, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscription request with any body
	CreateSubscriptionWithBody(ctx context.Context, companyId string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscription(ctx context.Context, companyId string, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionBillingInfo request
	GetSubscriptionBillingInfo(ctx context.Context, companyId string, params *GetSubscriptionBillingInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBillingInfo request with any body
	UpdateBillingInfoWithBody(ctx context.Context, companyId string, params *UpdateBillingInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBillingInfo(ctx context.Context, companyId string, params *UpdateBillingInfoParams, body UpdateBillingInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingInvoices request
	ListBillingInvoices(ctx context.Context, companyId string, params *ListBillingInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePaymentIntent request
	CreatePaymentIntent(ctx context.Context, companyId string, params *CreatePaymentIntentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTerminals request
	ListTerminals(ctx context.Context, companyId string, params *ListTerminalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTimeSlotReservations request
	ListTimeSlotReservations(ctx context.Context, companyId string, params *ListTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTimeSlots request
	ListTimeSlots(ctx context.Context, companyId string, params *ListTimeSlotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTransactions request
	ListTransactions(ctx context.Context, companyId string, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVATs request
	ListVATs(ctx context.Context, companyId string, params *ListVATsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVoucherTemplates request
	ListVoucherTemplates(ctx context.Context, companyId string, params *ListVoucherTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVouchers request
	ListVouchers(ctx context.Context, companyId string, params *ListVouchersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWaitlistEntries request
	ListWaitlistEntries(ctx context.Context, companyId string, params *ListWaitlistEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhookInvocations request
	ListWebhookInvocations(ctx context.Context, companyId string, params *ListWebhookInvocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhooks request
	ListWebhooks(ctx context.Context, companyId string, params *ListWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomerGroup request with any body
	CreateCustomerGroupWithBody(ctx context.Context, params *CreateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomerGroup(ctx context.Context, params *CreateCustomerGroupParams, body CreateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomerGroup request
	DeleteCustomerGroup(ctx context.Context, customerGroupId string, params *DeleteCustomerGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerGroup request
	GetCustomerGroup(ctx context.Context, customerGroupId string, params *GetCustomerGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomerGroup request with any body
	UpdateCustomerGroupWithBody(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomerGroup(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, body UpdateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomer request with any body
	CreateCustomerWithBody(ctx context.Context, params *CreateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomer(ctx context.Context, params *CreateCustomerParams, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomer request
	DeleteCustomer(ctx context.Context, customerId string, params *DeleteCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomer request
	GetCustomer(ctx context.Context, customerId string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomer request with any body
	UpdateCustomerWithBody(ctx context.Context, customerId string, params *UpdateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomer(ctx context.Context, customerId string, params *UpdateCustomerParams, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEmployee request with any body
	CreateEmployeeWithBody(ctx context.Context, params *CreateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEmployee(ctx context.Context, params *CreateEmployeeParams, body CreateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterprise request
	GetEnterprise(ctx context.Context, params *GetEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnterprise request with any body
	UpdateEnterpriseWithBody(ctx context.Context, params *UpdateEnterpriseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnterprise(ctx context.Context, params *UpdateEnterpriseParams, body UpdateEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnterpriseCompanies request
	ListEnterpriseCompanies(ctx context.Context, enterpriseId string, params *ListEnterpriseCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentsLegacy request
	ListPaymentsLegacy(ctx context.Context, enterpriseId string, params *ListPaymentsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEnterpriseSettlementAccounts request
	ListEnterpriseSettlementAccounts(ctx context.Context, enterpriseId string, params *ListEnterpriseSettlementAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnterpriseSettlementAccount request
	DeleteEnterpriseSettlementAccount(ctx context.Context, enterpriseId string, settlementAccountId string, params *DeleteEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnterpriseSettlementAccount request
	GetEnterpriseSettlementAccount(ctx context.Context, enterpriseId string, settlementAccountId string, params *GetEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSettlementsLegacy request
	ListSettlementsLegacy(ctx context.Context, enterpriseId string, params *ListSettlementsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVoucherTemplatesLegacy request
	ListVoucherTemplatesLegacy(ctx context.Context, enterpriseId string, params *ListVoucherTemplatesLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVoucherTemplateLegacy request with any body
	CreateVoucherTemplateLegacyWithBody(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVoucherTemplateLegacy(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, body CreateVoucherTemplateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVouchersLegacy request
	ListVouchersLegacy(ctx context.Context, enterpriseId string, params *ListVouchersLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoucherLegacy request
	GetVoucherLegacy(ctx context.Context, enterpriseId string, voucherId string, params *GetVoucherLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVoucherLegacy request with any body
	UpdateVoucherLegacyWithBody(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVoucherLegacy(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, body UpdateVoucherLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEventStatus request with any body
	CreateEventStatusWithBody(ctx context.Context, params *CreateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEventStatus(ctx context.Context, params *CreateEventStatusParams, body CreateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEventStatus request
	DeleteEventStatus(ctx context.Context, eventStatusId string, params *DeleteEventStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventStatus request
	GetEventStatus(ctx context.Context, eventStatusId string, params *GetEventStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEventStatus request with any body
	UpdateEventStatusWithBody(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEventStatus(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, body UpdateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventTypeGroup request
	GetEventTypeGroup(ctx context.Context, eventTypeGroupId string, params *GetEventTypeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEventType request with any body
	CreateEventTypeWithBody(ctx context.Context, params *CreateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEventType(ctx context.Context, params *CreateEventTypeParams, body CreateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEventType request
	DeleteEventType(ctx context.Context, eventTypeId string, params *DeleteEventTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventType request
	GetEventType(ctx context.Context, eventTypeId string, params *GetEventTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEventType request with any body
	UpdateEventTypeWithBody(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEventType(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, body UpdateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEvent request with any body
	CreateEventWithBody(ctx context.Context, params *CreateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEvent(ctx context.Context, params *CreateEventParams, body CreateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEvent request
	DeleteEvent(ctx context.Context, eventId string, params *DeleteEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvent request
	GetEvent(ctx context.Context, eventId string, params *GetEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEvent request with any body
	UpdateEventWithBody(ctx context.Context, eventId string, params *UpdateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEvent(ctx context.Context, eventId string, params *UpdateEventParams, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCheckoutForEvent request
	CreateCheckoutForEvent(ctx context.Context, eventId string, params *CreateCheckoutForEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCompanyFiscalizationData request
	DeleteCompanyFiscalizationData(ctx context.Context, companyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompanyFiscalizationData request
	GetCompanyFiscalizationData(ctx context.Context, companyId string, params *GetCompanyFiscalizationDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertCompanyFiscalizationData request with any body
	UpsertCompanyFiscalizationDataWithBody(ctx context.Context, companyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertCompanyFiscalizationData(ctx context.Context, companyId string, body UpsertCompanyFiscalizationDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFiscalizationReport request
	GetFiscalizationReport(ctx context.Context, companyId string, params *GetFiscalizationReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FiscalizeTransaction request with any body
	FiscalizeTransactionWithBody(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FiscalizeTransaction(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, body FiscalizeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendFiscalizedTransactionPDF request with any body
	SendFiscalizedTransactionPDFWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendFiscalizedTransactionPDF(ctx context.Context, transactionId string, body SendFiscalizedTransactionPDFJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFiscalizedTransactionPDF request
	GetFiscalizedTransactionPDF(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefundFiscalizedTransaction request
	RefundFiscalizedTransaction(ctx context.Context, transactionId string, params *RefundFiscalizedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdyenCompanyOnboardingStatus request
	AdyenCompanyOnboardingStatus(ctx context.Context, companyId string, params *AdyenCompanyOnboardingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdyenCompanyOnboarding request with any body
	AdyenCompanyOnboardingWithBody(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdyenCompanyOnboarding(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, body AdyenCompanyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdyenUserOnboardingStatus request
	AdyenUserOnboardingStatus(ctx context.Context, userId string, params *AdyenUserOnboardingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdyenUserOnboarding request with any body
	AdyenUserOnboardingWithBody(ctx context.Context, userId string, params *AdyenUserOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdyenUserOnboarding(ctx context.Context, userId string, params *AdyenUserOnboardingParams, body AdyenUserOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSaltpayCompanies request
	ListSaltpayCompanies(ctx context.Context, params *ListSaltpayCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkSaltpayBankAccount request with any body
	LinkSaltpayBankAccountWithBody(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkSaltpayBankAccount(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, body LinkSaltpayBankAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSaltpayStoresAtCompany request
	ListSaltpayStoresAtCompany(ctx context.Context, companyId string, params *ListSaltpayStoresAtCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSaltpayStores request
	ListSaltpayStores(ctx context.Context, params *ListSaltpayStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSaltpayTerminals request
	ListSaltpayTerminals(ctx context.Context, storeId string, params *ListSaltpayTerminalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSaltpayTerminal request with any body
	UpdateSaltpayTerminalWithBody(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSaltpayTerminal(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, body UpdateSaltpayTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLineItem request with any body
	CreateLineItemWithBody(ctx context.Context, params *CreateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLineItem(ctx context.Context, params *CreateLineItemParams, body CreateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLineItem request
	DeleteLineItem(ctx context.Context, lineItemId string, params *DeleteLineItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLineItem request
	GetLineItem(ctx context.Context, lineItemId string, params *GetLineItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLineItem request with any body
	UpdateLineItemWithBody(ctx context.Context, lineItemId string, params *UpdateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLineItem(ctx context.Context, lineItemId string, params *UpdateLineItemParams, body UpdateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMemo request with any body
	CreateMemoWithBody(ctx context.Context, params *CreateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMemo(ctx context.Context, params *CreateMemoParams, body CreateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMemo request
	DeleteMemo(ctx context.Context, memoId string, params *DeleteMemoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMemo request
	GetMemo(ctx context.Context, memoId string, params *GetMemoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMemo request with any body
	UpdateMemoWithBody(ctx context.Context, memoId string, params *UpdateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMemo(ctx context.Context, memoId string, params *UpdateMemoParams, body UpdateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotification request with any body
	CreateNotificationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotification(ctx context.Context, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotification request
	DeleteNotification(ctx context.Context, notificationId string, params *DeleteNotificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotification request
	GetNotification(ctx context.Context, notificationId string, params *GetNotificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOAuthApplications request
	ListOAuthApplications(ctx context.Context, params *ListOAuthApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOAuthApplication request with any body
	CreateOAuthApplicationWithBody(ctx context.Context, params *CreateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOAuthApplication(ctx context.Context, params *CreateOAuthApplicationParams, body CreateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOAuthApplication request
	DeleteOAuthApplication(ctx context.Context, applicationId string, params *DeleteOAuthApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthApplication request
	GetOAuthApplication(ctx context.Context, applicationId string, params *GetOAuthApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOAuthApplication request with any body
	UpdateOAuthApplicationWithBody(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOAuthApplication(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, body UpdateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartOAuthFlow request
	StartOAuthFlow(ctx context.Context, params *StartOAuthFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOAuthConsent request with any body
	CreateOAuthConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOAuthConsent(ctx context.Context, body CreateOAuthConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthPublicKey request
	GetOAuthPublicKey(ctx context.Context, params *GetOAuthPublicKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOAuthScopes request
	ListOAuthScopes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOAuthToken(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaymentMethods request
	ListPaymentMethods(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayment request
	GetPayment(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePayment request with any body
	UpdatePaymentWithBody(ctx context.Context, paymentId string, params *UpdatePaymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePayment(ctx context.Context, paymentId string, params *UpdatePaymentParams, body UpdatePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadPaymentReceipt request
	DownloadPaymentReceipt(ctx context.Context, paymentId string, params *DownloadPaymentReceiptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendPaymentReceipt request with any body
	SendPaymentReceiptWithBody(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendPaymentReceipt(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, body SendPaymentReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPricing request
	ListPricing(ctx context.Context, params *ListPricingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculatePricing request
	CalculatePricing(ctx context.Context, params *CalculatePricingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPricingByCountryCode request
	GetPricingByCountryCode(ctx context.Context, countryCode string, params *GetPricingByCountryCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProductGroups request
	ListProductGroups(ctx context.Context, params *ListProductGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProductGroup request with any body
	CreateProductGroupWithBody(ctx context.Context, params *CreateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProductGroup(ctx context.Context, params *CreateProductGroupParams, body CreateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupsAndProducts request
	ListGroupsAndProducts(ctx context.Context, params *ListGroupsAndProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductGroupsOrder request with any body
	UpdateProductGroupsOrderWithBody(ctx context.Context, params *UpdateProductGroupsOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProductGroupsOrder(ctx context.Context, params *UpdateProductGroupsOrderParams, body UpdateProductGroupsOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductGroup request
	DeleteProductGroup(ctx context.Context, id string, params *DeleteProductGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductGroup request
	GetProductGroup(ctx context.Context, id string, params *GetProductGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductGroup request with any body
	UpdateProductGroupWithBody(ctx context.Context, id string, params *UpdateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProductGroup(ctx context.Context, id string, params *UpdateProductGroupParams, body UpdateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProducts request
	ListProducts(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProduct request with any body
	CreateProductWithBody(ctx context.Context, params *CreateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProduct(ctx context.Context, params *CreateProductParams, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProduct request
	DeleteProduct(ctx context.Context, id string, params *DeleteProductParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProduct request
	GetProduct(ctx context.Context, id string, params *GetProductParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProduct request with any body
	UpdateProductWithBody(ctx context.Context, id string, params *UpdateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProduct(ctx context.Context, id string, params *UpdateProductParams, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomProperty request with any body
	CreateCustomPropertyWithBody(ctx context.Context, params *CreateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomProperty(ctx context.Context, params *CreateCustomPropertyParams, body CreateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomProperty request
	DeleteCustomProperty(ctx context.Context, propertyId string, params *DeleteCustomPropertyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomProperty request with any body
	UpdateCustomPropertyWithBody(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomProperty(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, body UpdateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResourceGroup request with any body
	CreateResourceGroupWithBody(ctx context.Context, params *CreateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResourceGroup(ctx context.Context, params *CreateResourceGroupParams, body CreateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceGroup request
	DeleteResourceGroup(ctx context.Context, resourceGroupId string, params *DeleteResourceGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceGroup request
	GetResourceGroup(ctx context.Context, resourceGroupId string, params *GetResourceGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceGroup request with any body
	UpdateResourceGroupWithBody(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourceGroup(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, body UpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResource request with any body
	CreateResourceWithBody(ctx context.Context, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResource(ctx context.Context, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResource request
	DeleteResource(ctx context.Context, resourceId string, params *DeleteResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, resourceId string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResource request with any body
	UpdateResourceWithBody(ctx context.Context, resourceId string, params *UpdateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResource(ctx context.Context, resourceId string, params *UpdateResourceParams, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleSetTemplate request with any body
	CreateRuleSetTemplateWithBody(ctx context.Context, params *CreateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRuleSetTemplate(ctx context.Context, params *CreateRuleSetTemplateParams, body CreateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuleSetTemplate request
	DeleteRuleSetTemplate(ctx context.Context, ruleSetTemplateId string, params *DeleteRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleSetTemplate request
	GetRuleSetTemplate(ctx context.Context, ruleSetTemplateId string, params *GetRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleSetTemplate request with any body
	UpdateRuleSetTemplateWithBody(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleSetTemplate(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, body UpdateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleSet request with any body
	CreateRuleSetWithBody(ctx context.Context, params *CreateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRuleSet(ctx context.Context, params *CreateRuleSetParams, body CreateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuleSet request
	DeleteRuleSet(ctx context.Context, ruleSetId string, params *DeleteRuleSetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleSet request
	GetRuleSet(ctx context.Context, ruleSetId string, params *GetRuleSetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleSet request with any body
	UpdateRuleSetWithBody(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleSet(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, body UpdateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSale request with any body
	CreateSaleWithBody(ctx context.Context, params *CreateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSale(ctx context.Context, params *CreateSaleParams, body CreateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSale request
	DeleteSale(ctx context.Context, saleId string, params *DeleteSaleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSale request
	GetSale(ctx context.Context, saleId string, params *GetSaleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSale request with any body
	UpdateSaleWithBody(ctx context.Context, saleId string, params *UpdateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSale(ctx context.Context, saleId string, params *UpdateSaleParams, body UpdateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefundMarketplaceSale request
	RefundMarketplaceSale(ctx context.Context, saleId string, params *RefundMarketplaceSaleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendTransactionReceipt request with any body
	SendTransactionReceiptWithBody(ctx context.Context, saleId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendTransactionReceipt(ctx context.Context, saleId string, transactionId string, body SendTransactionReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeprecatedListSubtransactions request
	DeprecatedListSubtransactions(ctx context.Context, saleId string, transactionId string, params *DeprecatedListSubtransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeprecatedGetSubtransaction request
	DeprecatedGetSubtransaction(ctx context.Context, saleId string, transactionId string, id string, params *DeprecatedGetSubtransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpace request with any body
	CreateSpaceWithBody(ctx context.Context, params *CreateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpace(ctx context.Context, params *CreateSpaceParams, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpace request
	DeleteSpace(ctx context.Context, spaceId string, params *DeleteSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpace request
	GetSpace(ctx context.Context, spaceId string, params *GetSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpace request with any body
	UpdateSpaceWithBody(ctx context.Context, spaceId string, params *UpdateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpace(ctx context.Context, spaceId string, params *UpdateSpaceParams, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamBlockedTimes request
	StreamBlockedTimes(ctx context.Context, companyId string, params *StreamBlockedTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamEmployees request
	StreamEmployees(ctx context.Context, companyId string, params *StreamEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamEventTypeGroups request
	StreamEventTypeGroups(ctx context.Context, companyId string, params *StreamEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamEventTypes request
	StreamEventTypes(ctx context.Context, companyId string, params *StreamEventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamEvents request
	StreamEvents(ctx context.Context, companyId string, params *StreamEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamSalesMetrics request
	StreamSalesMetrics(ctx context.Context, companyId string, params *StreamSalesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamNotifications request
	StreamNotifications(ctx context.Context, companyId string, params *StreamNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamProductGroups request
	StreamProductGroups(ctx context.Context, companyId string, params *StreamProductGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamProducts request
	StreamProducts(ctx context.Context, companyId string, params *StreamProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamResources request
	StreamResources(ctx context.Context, companyId string, params *StreamResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamSpaces request
	StreamSpaces(ctx context.Context, companyId string, params *StreamSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamTimeSlotReservations request
	StreamTimeSlotReservations(ctx context.Context, companyId string, params *StreamTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingInvoice request
	GetBillingInvoice(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, subscriptionId string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscription request
	GetSubscription(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubtransaction request with any body
	CreateSubtransactionWithBody(ctx context.Context, params *CreateSubtransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubtransaction(ctx context.Context, params *CreateSubtransactionParams, body CreateSubtransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubtransaction request
	DeleteSubtransaction(ctx context.Context, subtransactionId string, params *DeleteSubtransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubtransaction request
	GetSubtransaction(ctx context.Context, subtransactionId string, params *GetSubtransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTerminal request
	DeleteTerminal(ctx context.Context, terminalId string, params *DeleteTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTerminal request
	GetTerminal(ctx context.Context, terminalId string, params *GetTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTerminal request with any body
	UpdateTerminalWithBody(ctx context.Context, terminalId string, params *UpdateTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTerminal(ctx context.Context, terminalId string, params *UpdateTerminalParams, body UpdateTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthConsent request
	GetOAuthConsent(ctx context.Context, params *GetOAuthConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOAuthLogin request
	GetOAuthLogin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOAuthLogin request with any body
	PostOAuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOAuthLogin(ctx context.Context, body PostOAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimeSlotReservation request
	GetTimeSlotReservation(ctx context.Context, timeSlotReservationId string, params *GetTimeSlotReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateToken request
	CreateToken(ctx context.Context, params *CreateTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTransaction request with any body
	CreateTransactionWithBody(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTransaction(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransaction request
	DeleteTransaction(ctx context.Context, transactionId string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, transactionId string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTransaction request with any body
	UpdateTransactionWithBody(ctx context.Context, transactionId string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransaction(ctx context.Context, transactionId string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLineItems request
	ListLineItems(ctx context.Context, transactionId string, params *ListLineItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubtransactions request
	ListSubtransactions(ctx context.Context, transactionId string, params *ListSubtransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGoogleCalendarConnection request
	DeleteGoogleCalendarConnection(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoogleCalendarConnection request
	GetGoogleCalendarConnection(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGoogleCalendarConnection request with any body
	CreateGoogleCalendarConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGoogleCalendarConnection(ctx context.Context, body CreateGoogleCalendarConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserOAuth request
	UserOAuth(ctx context.Context, params *UserOAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserSettlementAccounts request
	ListUserSettlementAccounts(ctx context.Context, params *ListUserSettlementAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserTerminals request
	ListUserTerminals(ctx context.Context, params *ListUserTerminalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserTerminal request
	DeleteUserTerminal(ctx context.Context, terminalId string, params *DeleteUserTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserTerminal request
	GetUserTerminal(ctx context.Context, terminalId string, params *GetUserTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserTokens request
	ListUserTokens(ctx context.Context, params *ListUserTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserToken request with any body
	CreateUserTokenWithBody(ctx context.Context, params *CreateUserTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserToken(ctx context.Context, params *CreateUserTokenParams, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserToken request
	DeleteUserToken(ctx context.Context, tokenId string, params *DeleteUserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserToken request
	GetUserToken(ctx context.Context, tokenId string, params *GetUserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVoucherTemplate request with any body
	CreateVoucherTemplateWithBody(ctx context.Context, params *CreateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVoucherTemplate(ctx context.Context, params *CreateVoucherTemplateParams, body CreateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVoucherTemplate request
	DeleteVoucherTemplate(ctx context.Context, voucherTemplateId string, params *DeleteVoucherTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVoucherTemplate request with any body
	UpdateVoucherTemplateWithBody(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVoucherTemplate(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, body UpdateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVoucher request
	DeleteVoucher(ctx context.Context, voucherId string, params *DeleteVoucherParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoucher request
	GetVoucher(ctx context.Context, voucherId string, params *GetVoucherParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVoucher request with any body
	UpdateVoucherWithBody(ctx context.Context, voucherId string, params *UpdateVoucherParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVoucher(ctx context.Context, voucherId string, params *UpdateVoucherParams, body UpdateVoucherJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVoucherNotification request with any body
	CreateVoucherNotificationWithBody(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVoucherNotification(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, body CreateVoucherNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWaitlistEntry request with any body
	CreateWaitlistEntryWithBody(ctx context.Context, params *CreateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWaitlistEntry(ctx context.Context, params *CreateWaitlistEntryParams, body CreateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWaitlistEntry request
	DeleteWaitlistEntry(ctx context.Context, waitlistEntryId string, params *DeleteWaitlistEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWaitlistEntry request
	GetWaitlistEntry(ctx context.Context, waitlistEntryId string, params *GetWaitlistEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWaitlistEntry request with any body
	UpdateWaitlistEntryWithBody(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWaitlistEntry(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, body UpdateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookInvocation request
	GetWebhookInvocation(ctx context.Context, webhookInvocationId string, params *GetWebhookInvocationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookInvocation request with any body
	UpdateWebhookInvocationWithBody(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhookInvocation(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, body UpdateWebhookInvocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhook request with any body
	CreateWebhookWithBody(ctx context.Context, params *CreateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhook(ctx context.Context, params *CreateWebhookParams, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWebhookEvents request
	ListWebhookEvents(ctx context.Context, params *ListWebhookEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, webhookId string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhook request with any body
	UpdateWebhookWithBody(ctx context.Context, webhookId string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhook(ctx context.Context, webhookId string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListCustomerActivities(ctx context.Context, customerId string, params *ListCustomerActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomerActivitiesRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventTypeActivities(ctx context.Context, eventTypeId string, params *ListEventTypeActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventTypeActivitiesRequest(c.Server, eventTypeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventActivities(ctx context.Context, eventId string, params *ListEventActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventActivitiesRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentActivities(ctx context.Context, paymentId string, params *ListPaymentActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentActivitiesRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlockedTimeWithBody(ctx context.Context, params *CreateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlockedTimeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlockedTime(ctx context.Context, params *CreateBlockedTimeParams, body CreateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlockedTimeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBlockedTime(ctx context.Context, blockedTimeId string, params *DeleteBlockedTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBlockedTimeRequest(c.Server, blockedTimeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockedTime(ctx context.Context, blockedTimeId string, params *GetBlockedTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockedTimeRequest(c.Server, blockedTimeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBlockedTimeWithBody(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBlockedTimeRequestWithBody(c.Server, blockedTimeId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBlockedTime(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, body UpdateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBlockedTimeRequest(c.Server, blockedTimeId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompanies(ctx context.Context, params *GetCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompaniesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCompanyWithBody(ctx context.Context, params *CreateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCompanyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCompany(ctx context.Context, params *CreateCompanyParams, body CreateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCompanyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompany(ctx context.Context, companyId string, params *GetCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCompanyWithBody(ctx context.Context, companyId string, params *UpdateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCompanyRequestWithBody(c.Server, companyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCompany(ctx context.Context, companyId string, params *UpdateCompanyParams, body UpdateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCompanyRequest(c.Server, companyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllCompanyActivities(ctx context.Context, companyId string, params *ListAllCompanyActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllCompanyActivitiesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, companyId string, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, companyId string, appId string, params *GetAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, companyId, appId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableApp(ctx context.Context, companyId string, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableAppRequest(c.Server, companyId, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBlockedTimes(ctx context.Context, companyId string, params *ListBlockedTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBlockedTimesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClaims(ctx context.Context, companyId string, params *ListClaimsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClaimsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomerGroups(ctx context.Context, companyId string, params *ListCustomerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomerGroupsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomers(ctx context.Context, companyId string, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomersRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEmployees(ctx context.Context, companyId string, params *ListEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEmployeesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEmployee(ctx context.Context, companyId string, employeeId string, params *DeleteEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEmployeeRequest(c.Server, companyId, employeeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployee(ctx context.Context, companyId string, employeeId string, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmployeeRequest(c.Server, companyId, employeeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmployeeWithBody(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmployeeRequestWithBody(c.Server, companyId, employeeId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEmployee(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEmployeeRequest(c.Server, companyId, employeeId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventStatuses(ctx context.Context, companyId string, params *ListEventStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventStatusesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventTypeCategories(ctx context.Context, companyId string, params *ListEventTypeCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventTypeCategoriesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventTypeCategoryGroups(ctx context.Context, companyId string, params *ListEventTypeCategoryGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventTypeCategoryGroupsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventTypeGroups(ctx context.Context, companyId string, params *ListEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventTypeGroupsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEventTypes(ctx context.Context, companyId string, params *ListEventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventTypesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEvents(ctx context.Context, companyId string, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckinWithPayment(ctx context.Context, companyId string, id string, params *CheckinWithPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckinWithPaymentRequest(c.Server, companyId, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHolidays(ctx context.Context, companyId string, params *ListHolidaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHolidaysRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIssuers(ctx context.Context, companyId string, params *ListIssuersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIssuersRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMemos(ctx context.Context, companyId string, params *ListMemosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMemosRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSalesMetrics(ctx context.Context, companyId string, params *GetSalesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSalesMetricsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotifications(ctx context.Context, companyId string, params *DeleteNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNotifications(ctx context.Context, companyId string, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNotificationsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOpeningHours(ctx context.Context, companyId string, params *ListOpeningHoursParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOpeningHoursRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPayments(ctx context.Context, companyId string, params *ListPaymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomProperties(ctx context.Context, companyId string, params *ListCustomPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomPropertiesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceGroups(ctx context.Context, companyId string, params *ListResourceGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceGroupsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResources(ctx context.Context, companyId string, params *ListResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourcesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuleSetTemplates(ctx context.Context, companyId string, params *ListRuleSetTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleSetTemplatesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuleSets(ctx context.Context, companyId string, params *ListRuleSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleSetsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSales(ctx context.Context, companyId string, params *ListSalesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSalesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSettlements(ctx context.Context, companyId string, params *ListSettlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSettlementsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSMSMessages(ctx context.Context, companyId string, params *ListSMSMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSMSMessagesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpaces(ctx context.Context, companyId string, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, companyId string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, companyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscription(ctx context.Context, companyId string, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequest(c.Server, companyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionBillingInfo(ctx context.Context, companyId string, params *GetSubscriptionBillingInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionBillingInfoRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingInfoWithBody(ctx context.Context, companyId string, params *UpdateBillingInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingInfoRequestWithBody(c.Server, companyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingInfo(ctx context.Context, companyId string, params *UpdateBillingInfoParams, body UpdateBillingInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingInfoRequest(c.Server, companyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingInvoices(ctx context.Context, companyId string, params *ListBillingInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingInvoicesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePaymentIntent(ctx context.Context, companyId string, params *CreatePaymentIntentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentIntentRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTerminals(ctx context.Context, companyId string, params *ListTerminalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTerminalsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTimeSlotReservations(ctx context.Context, companyId string, params *ListTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTimeSlotReservationsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTimeSlots(ctx context.Context, companyId string, params *ListTimeSlotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTimeSlotsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTransactions(ctx context.Context, companyId string, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTransactionsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVATs(ctx context.Context, companyId string, params *ListVATsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVATsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVoucherTemplates(ctx context.Context, companyId string, params *ListVoucherTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVoucherTemplatesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVouchers(ctx context.Context, companyId string, params *ListVouchersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVouchersRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWaitlistEntries(ctx context.Context, companyId string, params *ListWaitlistEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWaitlistEntriesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhookInvocations(ctx context.Context, companyId string, params *ListWebhookInvocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhookInvocationsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhooks(ctx context.Context, companyId string, params *ListWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhooksRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerGroupWithBody(ctx context.Context, params *CreateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerGroup(ctx context.Context, params *CreateCustomerGroupParams, body CreateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomerGroup(ctx context.Context, customerGroupId string, params *DeleteCustomerGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerGroupRequest(c.Server, customerGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerGroup(ctx context.Context, customerGroupId string, params *GetCustomerGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerGroupRequest(c.Server, customerGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerGroupWithBody(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerGroupRequestWithBody(c.Server, customerGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerGroup(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, body UpdateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerGroupRequest(c.Server, customerGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerWithBody(ctx context.Context, params *CreateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomer(ctx context.Context, params *CreateCustomerParams, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomer(ctx context.Context, customerId string, params *DeleteCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomer(ctx context.Context, customerId string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerWithBody(ctx context.Context, customerId string, params *UpdateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequestWithBody(c.Server, customerId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomer(ctx context.Context, customerId string, params *UpdateCustomerParams, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequest(c.Server, customerId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmployeeWithBody(ctx context.Context, params *CreateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmployeeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmployee(ctx context.Context, params *CreateEmployeeParams, body CreateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmployeeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterprise(ctx context.Context, params *GetEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnterpriseWithBody(ctx context.Context, params *UpdateEnterpriseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnterpriseRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnterprise(ctx context.Context, params *UpdateEnterpriseParams, body UpdateEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnterpriseRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnterpriseCompanies(ctx context.Context, enterpriseId string, params *ListEnterpriseCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnterpriseCompaniesRequest(c.Server, enterpriseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentsLegacy(ctx context.Context, enterpriseId string, params *ListPaymentsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentsLegacyRequest(c.Server, enterpriseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEnterpriseSettlementAccounts(ctx context.Context, enterpriseId string, params *ListEnterpriseSettlementAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEnterpriseSettlementAccountsRequest(c.Server, enterpriseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnterpriseSettlementAccount(ctx context.Context, enterpriseId string, settlementAccountId string, params *DeleteEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnterpriseSettlementAccountRequest(c.Server, enterpriseId, settlementAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnterpriseSettlementAccount(ctx context.Context, enterpriseId string, settlementAccountId string, params *GetEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnterpriseSettlementAccountRequest(c.Server, enterpriseId, settlementAccountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSettlementsLegacy(ctx context.Context, enterpriseId string, params *ListSettlementsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSettlementsLegacyRequest(c.Server, enterpriseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVoucherTemplatesLegacy(ctx context.Context, enterpriseId string, params *ListVoucherTemplatesLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVoucherTemplatesLegacyRequest(c.Server, enterpriseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVoucherTemplateLegacyWithBody(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVoucherTemplateLegacyRequestWithBody(c.Server, enterpriseId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVoucherTemplateLegacy(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, body CreateVoucherTemplateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVoucherTemplateLegacyRequest(c.Server, enterpriseId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVouchersLegacy(ctx context.Context, enterpriseId string, params *ListVouchersLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVouchersLegacyRequest(c.Server, enterpriseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoucherLegacy(ctx context.Context, enterpriseId string, voucherId string, params *GetVoucherLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoucherLegacyRequest(c.Server, enterpriseId, voucherId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVoucherLegacyWithBody(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVoucherLegacyRequestWithBody(c.Server, enterpriseId, voucherId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVoucherLegacy(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, body UpdateVoucherLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVoucherLegacyRequest(c.Server, enterpriseId, voucherId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventStatusWithBody(ctx context.Context, params *CreateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventStatusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventStatus(ctx context.Context, params *CreateEventStatusParams, body CreateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventStatusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEventStatus(ctx context.Context, eventStatusId string, params *DeleteEventStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEventStatusRequest(c.Server, eventStatusId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventStatus(ctx context.Context, eventStatusId string, params *GetEventStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventStatusRequest(c.Server, eventStatusId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEventStatusWithBody(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventStatusRequestWithBody(c.Server, eventStatusId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEventStatus(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, body UpdateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventStatusRequest(c.Server, eventStatusId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventTypeGroup(ctx context.Context, eventTypeGroupId string, params *GetEventTypeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventTypeGroupRequest(c.Server, eventTypeGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventTypeWithBody(ctx context.Context, params *CreateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventTypeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventType(ctx context.Context, params *CreateEventTypeParams, body CreateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventTypeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEventType(ctx context.Context, eventTypeId string, params *DeleteEventTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEventTypeRequest(c.Server, eventTypeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventType(ctx context.Context, eventTypeId string, params *GetEventTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventTypeRequest(c.Server, eventTypeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEventTypeWithBody(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventTypeRequestWithBody(c.Server, eventTypeId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEventType(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, body UpdateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventTypeRequest(c.Server, eventTypeId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventWithBody(ctx context.Context, params *CreateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEvent(ctx context.Context, params *CreateEventParams, body CreateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEvent(ctx context.Context, eventId string, params *DeleteEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEventRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEvent(ctx context.Context, eventId string, params *GetEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEventWithBody(ctx context.Context, eventId string, params *UpdateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventRequestWithBody(c.Server, eventId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEvent(ctx context.Context, eventId string, params *UpdateEventParams, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEventRequest(c.Server, eventId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCheckoutForEvent(ctx context.Context, eventId string, params *CreateCheckoutForEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCheckoutForEventRequest(c.Server, eventId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCompanyFiscalizationData(ctx context.Context, companyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCompanyFiscalizationDataRequest(c.Server, companyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompanyFiscalizationData(ctx context.Context, companyId string, params *GetCompanyFiscalizationDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompanyFiscalizationDataRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCompanyFiscalizationDataWithBody(ctx context.Context, companyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCompanyFiscalizationDataRequestWithBody(c.Server, companyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertCompanyFiscalizationData(ctx context.Context, companyId string, body UpsertCompanyFiscalizationDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertCompanyFiscalizationDataRequest(c.Server, companyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFiscalizationReport(ctx context.Context, companyId string, params *GetFiscalizationReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFiscalizationReportRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiscalizeTransactionWithBody(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiscalizeTransactionRequestWithBody(c.Server, transactionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FiscalizeTransaction(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, body FiscalizeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFiscalizeTransactionRequest(c.Server, transactionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendFiscalizedTransactionPDFWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendFiscalizedTransactionPDFRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendFiscalizedTransactionPDF(ctx context.Context, transactionId string, body SendFiscalizedTransactionPDFJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendFiscalizedTransactionPDFRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFiscalizedTransactionPDF(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFiscalizedTransactionPDFRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefundFiscalizedTransaction(ctx context.Context, transactionId string, params *RefundFiscalizedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefundFiscalizedTransactionRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdyenCompanyOnboardingStatus(ctx context.Context, companyId string, params *AdyenCompanyOnboardingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdyenCompanyOnboardingStatusRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdyenCompanyOnboardingWithBody(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdyenCompanyOnboardingRequestWithBody(c.Server, companyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdyenCompanyOnboarding(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, body AdyenCompanyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdyenCompanyOnboardingRequest(c.Server, companyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdyenUserOnboardingStatus(ctx context.Context, userId string, params *AdyenUserOnboardingStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdyenUserOnboardingStatusRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdyenUserOnboardingWithBody(ctx context.Context, userId string, params *AdyenUserOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdyenUserOnboardingRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdyenUserOnboarding(ctx context.Context, userId string, params *AdyenUserOnboardingParams, body AdyenUserOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdyenUserOnboardingRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSaltpayCompanies(ctx context.Context, params *ListSaltpayCompaniesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSaltpayCompaniesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkSaltpayBankAccountWithBody(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkSaltpayBankAccountRequestWithBody(c.Server, companyId, bankAccountId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkSaltpayBankAccount(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, body LinkSaltpayBankAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkSaltpayBankAccountRequest(c.Server, companyId, bankAccountId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSaltpayStoresAtCompany(ctx context.Context, companyId string, params *ListSaltpayStoresAtCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSaltpayStoresAtCompanyRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSaltpayStores(ctx context.Context, params *ListSaltpayStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSaltpayStoresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSaltpayTerminals(ctx context.Context, storeId string, params *ListSaltpayTerminalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSaltpayTerminalsRequest(c.Server, storeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSaltpayTerminalWithBody(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSaltpayTerminalRequestWithBody(c.Server, storeId, terminalId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSaltpayTerminal(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, body UpdateSaltpayTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSaltpayTerminalRequest(c.Server, storeId, terminalId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLineItemWithBody(ctx context.Context, params *CreateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLineItemRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLineItem(ctx context.Context, params *CreateLineItemParams, body CreateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLineItemRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLineItem(ctx context.Context, lineItemId string, params *DeleteLineItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLineItemRequest(c.Server, lineItemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLineItem(ctx context.Context, lineItemId string, params *GetLineItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLineItemRequest(c.Server, lineItemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLineItemWithBody(ctx context.Context, lineItemId string, params *UpdateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLineItemRequestWithBody(c.Server, lineItemId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLineItem(ctx context.Context, lineItemId string, params *UpdateLineItemParams, body UpdateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLineItemRequest(c.Server, lineItemId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMemoWithBody(ctx context.Context, params *CreateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMemoRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMemo(ctx context.Context, params *CreateMemoParams, body CreateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMemoRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMemo(ctx context.Context, memoId string, params *DeleteMemoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMemoRequest(c.Server, memoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMemo(ctx context.Context, memoId string, params *GetMemoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMemoRequest(c.Server, memoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMemoWithBody(ctx context.Context, memoId string, params *UpdateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMemoRequestWithBody(c.Server, memoId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMemo(ctx context.Context, memoId string, params *UpdateMemoParams, body UpdateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMemoRequest(c.Server, memoId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotification(ctx context.Context, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotification(ctx context.Context, notificationId string, params *DeleteNotificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationRequest(c.Server, notificationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotification(ctx context.Context, notificationId string, params *GetNotificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationRequest(c.Server, notificationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOAuthApplications(ctx context.Context, params *ListOAuthApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOAuthApplicationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthApplicationWithBody(ctx context.Context, params *CreateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthApplicationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthApplication(ctx context.Context, params *CreateOAuthApplicationParams, body CreateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthApplicationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOAuthApplication(ctx context.Context, applicationId string, params *DeleteOAuthApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOAuthApplicationRequest(c.Server, applicationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthApplication(ctx context.Context, applicationId string, params *GetOAuthApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthApplicationRequest(c.Server, applicationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOAuthApplicationWithBody(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOAuthApplicationRequestWithBody(c.Server, applicationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOAuthApplication(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, body UpdateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOAuthApplicationRequest(c.Server, applicationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartOAuthFlow(ctx context.Context, params *StartOAuthFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartOAuthFlowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOAuthConsent(ctx context.Context, body CreateOAuthConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOAuthConsentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthPublicKey(ctx context.Context, params *GetOAuthPublicKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthPublicKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOAuthScopes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOAuthScopesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthTokenWithBody(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthToken(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaymentMethods(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaymentMethodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayment(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePaymentWithBody(ctx context.Context, paymentId string, params *UpdatePaymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentRequestWithBody(c.Server, paymentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePayment(ctx context.Context, paymentId string, params *UpdatePaymentParams, body UpdatePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePaymentRequest(c.Server, paymentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPaymentReceipt(ctx context.Context, paymentId string, params *DownloadPaymentReceiptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPaymentReceiptRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPaymentReceiptWithBody(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPaymentReceiptRequestWithBody(c.Server, paymentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendPaymentReceipt(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, body SendPaymentReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendPaymentReceiptRequest(c.Server, paymentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPricing(ctx context.Context, params *ListPricingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPricingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculatePricing(ctx context.Context, params *CalculatePricingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculatePricingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPricingByCountryCode(ctx context.Context, countryCode string, params *GetPricingByCountryCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricingByCountryCodeRequest(c.Server, countryCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProductGroups(ctx context.Context, params *ListProductGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProductGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProductGroupWithBody(ctx context.Context, params *CreateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProductGroup(ctx context.Context, params *CreateProductGroupParams, body CreateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupsAndProducts(ctx context.Context, params *ListGroupsAndProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsAndProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductGroupsOrderWithBody(ctx context.Context, params *UpdateProductGroupsOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductGroupsOrderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductGroupsOrder(ctx context.Context, params *UpdateProductGroupsOrderParams, body UpdateProductGroupsOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductGroupsOrderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductGroup(ctx context.Context, id string, params *DeleteProductGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductGroup(ctx context.Context, id string, params *GetProductGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductGroupWithBody(ctx context.Context, id string, params *UpdateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductGroupRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductGroup(ctx context.Context, id string, params *UpdateProductGroupParams, body UpdateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductGroupRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProducts(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProductWithBody(ctx context.Context, params *CreateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProduct(ctx context.Context, params *CreateProductParams, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProduct(ctx context.Context, id string, params *DeleteProductParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProduct(ctx context.Context, id string, params *GetProductParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductWithBody(ctx context.Context, id string, params *UpdateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProduct(ctx context.Context, id string, params *UpdateProductParams, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomPropertyWithBody(ctx context.Context, params *CreateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomPropertyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomProperty(ctx context.Context, params *CreateCustomPropertyParams, body CreateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomPropertyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomProperty(ctx context.Context, propertyId string, params *DeleteCustomPropertyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomPropertyRequest(c.Server, propertyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomPropertyWithBody(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomPropertyRequestWithBody(c.Server, propertyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomProperty(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, body UpdateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomPropertyRequest(c.Server, propertyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceGroupWithBody(ctx context.Context, params *CreateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceGroup(ctx context.Context, params *CreateResourceGroupParams, body CreateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceGroup(ctx context.Context, resourceGroupId string, params *DeleteResourceGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceGroupRequest(c.Server, resourceGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceGroup(ctx context.Context, resourceGroupId string, params *GetResourceGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceGroupRequest(c.Server, resourceGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceGroupWithBody(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceGroupRequestWithBody(c.Server, resourceGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceGroup(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, body UpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceGroupRequest(c.Server, resourceGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceWithBody(ctx context.Context, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResource(ctx context.Context, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, resourceId string, params *DeleteResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, resourceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, resourceId string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, resourceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceWithBody(ctx context.Context, resourceId string, params *UpdateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequestWithBody(c.Server, resourceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResource(ctx context.Context, resourceId string, params *UpdateResourceParams, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequest(c.Server, resourceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleSetTemplateWithBody(ctx context.Context, params *CreateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleSetTemplateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleSetTemplate(ctx context.Context, params *CreateRuleSetTemplateParams, body CreateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleSetTemplateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuleSetTemplate(ctx context.Context, ruleSetTemplateId string, params *DeleteRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleSetTemplateRequest(c.Server, ruleSetTemplateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleSetTemplate(ctx context.Context, ruleSetTemplateId string, params *GetRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleSetTemplateRequest(c.Server, ruleSetTemplateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleSetTemplateWithBody(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleSetTemplateRequestWithBody(c.Server, ruleSetTemplateId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleSetTemplate(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, body UpdateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleSetTemplateRequest(c.Server, ruleSetTemplateId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleSetWithBody(ctx context.Context, params *CreateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleSetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleSet(ctx context.Context, params *CreateRuleSetParams, body CreateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleSetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuleSet(ctx context.Context, ruleSetId string, params *DeleteRuleSetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleSetRequest(c.Server, ruleSetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleSet(ctx context.Context, ruleSetId string, params *GetRuleSetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleSetRequest(c.Server, ruleSetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleSetWithBody(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleSetRequestWithBody(c.Server, ruleSetId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleSet(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, body UpdateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleSetRequest(c.Server, ruleSetId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSaleWithBody(ctx context.Context, params *CreateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSaleRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSale(ctx context.Context, params *CreateSaleParams, body CreateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSaleRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSale(ctx context.Context, saleId string, params *DeleteSaleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSaleRequest(c.Server, saleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSale(ctx context.Context, saleId string, params *GetSaleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSaleRequest(c.Server, saleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSaleWithBody(ctx context.Context, saleId string, params *UpdateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSaleRequestWithBody(c.Server, saleId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSale(ctx context.Context, saleId string, params *UpdateSaleParams, body UpdateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSaleRequest(c.Server, saleId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefundMarketplaceSale(ctx context.Context, saleId string, params *RefundMarketplaceSaleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefundMarketplaceSaleRequest(c.Server, saleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendTransactionReceiptWithBody(ctx context.Context, saleId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendTransactionReceiptRequestWithBody(c.Server, saleId, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendTransactionReceipt(ctx context.Context, saleId string, transactionId string, body SendTransactionReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendTransactionReceiptRequest(c.Server, saleId, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeprecatedListSubtransactions(ctx context.Context, saleId string, transactionId string, params *DeprecatedListSubtransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeprecatedListSubtransactionsRequest(c.Server, saleId, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeprecatedGetSubtransaction(ctx context.Context, saleId string, transactionId string, id string, params *DeprecatedGetSubtransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeprecatedGetSubtransactionRequest(c.Server, saleId, transactionId, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceWithBody(ctx context.Context, params *CreateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpace(ctx context.Context, params *CreateSpaceParams, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpace(ctx context.Context, spaceId string, params *DeleteSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpace(ctx context.Context, spaceId string, params *GetSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpaceWithBody(ctx context.Context, spaceId string, params *UpdateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequestWithBody(c.Server, spaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpace(ctx context.Context, spaceId string, params *UpdateSpaceParams, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequest(c.Server, spaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamBlockedTimes(ctx context.Context, companyId string, params *StreamBlockedTimesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamBlockedTimesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamEmployees(ctx context.Context, companyId string, params *StreamEmployeesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamEmployeesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamEventTypeGroups(ctx context.Context, companyId string, params *StreamEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamEventTypeGroupsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamEventTypes(ctx context.Context, companyId string, params *StreamEventTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamEventTypesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamEvents(ctx context.Context, companyId string, params *StreamEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamEventsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamSalesMetrics(ctx context.Context, companyId string, params *StreamSalesMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamSalesMetricsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamNotifications(ctx context.Context, companyId string, params *StreamNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamNotificationsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamProductGroups(ctx context.Context, companyId string, params *StreamProductGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamProductGroupsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamProducts(ctx context.Context, companyId string, params *StreamProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamProductsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamResources(ctx context.Context, companyId string, params *StreamResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamResourcesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamSpaces(ctx context.Context, companyId string, params *StreamSpacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamSpacesRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamTimeSlotReservations(ctx context.Context, companyId string, params *StreamTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamTimeSlotReservationsRequest(c.Server, companyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingInvoice(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingInvoiceRequest(c.Server, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, subscriptionId string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, subscriptionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscription(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionRequest(c.Server, subscriptionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubtransactionWithBody(ctx context.Context, params *CreateSubtransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubtransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubtransaction(ctx context.Context, params *CreateSubtransactionParams, body CreateSubtransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubtransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubtransaction(ctx context.Context, subtransactionId string, params *DeleteSubtransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubtransactionRequest(c.Server, subtransactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubtransaction(ctx context.Context, subtransactionId string, params *GetSubtransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubtransactionRequest(c.Server, subtransactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTerminal(ctx context.Context, terminalId string, params *DeleteTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTerminalRequest(c.Server, terminalId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTerminal(ctx context.Context, terminalId string, params *GetTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTerminalRequest(c.Server, terminalId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTerminalWithBody(ctx context.Context, terminalId string, params *UpdateTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTerminalRequestWithBody(c.Server, terminalId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTerminal(ctx context.Context, terminalId string, params *UpdateTerminalParams, body UpdateTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTerminalRequest(c.Server, terminalId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthConsent(ctx context.Context, params *GetOAuthConsentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthConsentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOAuthLogin(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOAuthLoginRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOAuthLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOAuthLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOAuthLogin(ctx context.Context, body PostOAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOAuthLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimeSlotReservation(ctx context.Context, timeSlotReservationId string, params *GetTimeSlotReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimeSlotReservationRequest(c.Server, timeSlotReservationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, params *CreateTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTransactionWithBody(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTransaction(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransaction(ctx context.Context, transactionId string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, transactionId string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionWithBody(ctx context.Context, transactionId string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionRequestWithBody(c.Server, transactionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransaction(ctx context.Context, transactionId string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionRequest(c.Server, transactionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLineItems(ctx context.Context, transactionId string, params *ListLineItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLineItemsRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubtransactions(ctx context.Context, transactionId string, params *ListSubtransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubtransactionsRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGoogleCalendarConnection(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGoogleCalendarConnectionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoogleCalendarConnection(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoogleCalendarConnectionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGoogleCalendarConnectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGoogleCalendarConnectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGoogleCalendarConnection(ctx context.Context, body CreateGoogleCalendarConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGoogleCalendarConnectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserOAuth(ctx context.Context, params *UserOAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserOAuthRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserSettlementAccounts(ctx context.Context, params *ListUserSettlementAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserSettlementAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserTerminals(ctx context.Context, params *ListUserTerminalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserTerminalsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserTerminal(ctx context.Context, terminalId string, params *DeleteUserTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserTerminalRequest(c.Server, terminalId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserTerminal(ctx context.Context, terminalId string, params *GetUserTerminalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTerminalRequest(c.Server, terminalId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserTokens(ctx context.Context, params *ListUserTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserTokenWithBody(ctx context.Context, params *CreateUserTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserToken(ctx context.Context, params *CreateUserTokenParams, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserTokenRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserToken(ctx context.Context, tokenId string, params *DeleteUserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserTokenRequest(c.Server, tokenId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserToken(ctx context.Context, tokenId string, params *GetUserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserTokenRequest(c.Server, tokenId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVoucherTemplateWithBody(ctx context.Context, params *CreateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVoucherTemplateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVoucherTemplate(ctx context.Context, params *CreateVoucherTemplateParams, body CreateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVoucherTemplateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVoucherTemplate(ctx context.Context, voucherTemplateId string, params *DeleteVoucherTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVoucherTemplateRequest(c.Server, voucherTemplateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVoucherTemplateWithBody(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVoucherTemplateRequestWithBody(c.Server, voucherTemplateId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVoucherTemplate(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, body UpdateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVoucherTemplateRequest(c.Server, voucherTemplateId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVoucher(ctx context.Context, voucherId string, params *DeleteVoucherParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVoucherRequest(c.Server, voucherId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoucher(ctx context.Context, voucherId string, params *GetVoucherParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoucherRequest(c.Server, voucherId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVoucherWithBody(ctx context.Context, voucherId string, params *UpdateVoucherParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVoucherRequestWithBody(c.Server, voucherId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVoucher(ctx context.Context, voucherId string, params *UpdateVoucherParams, body UpdateVoucherJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVoucherRequest(c.Server, voucherId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVoucherNotificationWithBody(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVoucherNotificationRequestWithBody(c.Server, voucherId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVoucherNotification(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, body CreateVoucherNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVoucherNotificationRequest(c.Server, voucherId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWaitlistEntryWithBody(ctx context.Context, params *CreateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWaitlistEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWaitlistEntry(ctx context.Context, params *CreateWaitlistEntryParams, body CreateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWaitlistEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWaitlistEntry(ctx context.Context, waitlistEntryId string, params *DeleteWaitlistEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWaitlistEntryRequest(c.Server, waitlistEntryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWaitlistEntry(ctx context.Context, waitlistEntryId string, params *GetWaitlistEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWaitlistEntryRequest(c.Server, waitlistEntryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWaitlistEntryWithBody(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWaitlistEntryRequestWithBody(c.Server, waitlistEntryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWaitlistEntry(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, body UpdateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWaitlistEntryRequest(c.Server, waitlistEntryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookInvocation(ctx context.Context, webhookInvocationId string, params *GetWebhookInvocationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookInvocationRequest(c.Server, webhookInvocationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookInvocationWithBody(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookInvocationRequestWithBody(c.Server, webhookInvocationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookInvocation(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, body UpdateWebhookInvocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookInvocationRequest(c.Server, webhookInvocationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookWithBody(ctx context.Context, params *CreateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhook(ctx context.Context, params *CreateWebhookParams, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWebhookEvents(ctx context.Context, params *ListWebhookEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWebhookEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, webhookId string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookWithBody(ctx context.Context, webhookId string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequestWithBody(c.Server, webhookId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhook(ctx context.Context, webhookId string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequest(c.Server, webhookId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListCustomerActivitiesRequest generates requests for ListCustomerActivities
func NewListCustomerActivitiesRequest(server string, customerId string, params *ListCustomerActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/activities/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventTypeActivitiesRequest generates requests for ListEventTypeActivities
func NewListEventTypeActivitiesRequest(server string, eventTypeId string, params *ListEventTypeActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_type_id", runtime.ParamLocationPath, eventTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/activities/event_types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventActivitiesRequest generates requests for ListEventActivities
func NewListEventActivitiesRequest(server string, eventId string, params *ListEventActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/activities/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentActivitiesRequest generates requests for ListPaymentActivities
func NewListPaymentActivitiesRequest(server string, paymentId string, params *ListPaymentActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_id", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/activities/payments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBlockedTimeRequest calls the generic CreateBlockedTime builder with application/json body
func NewCreateBlockedTimeRequest(server string, params *CreateBlockedTimeParams, body CreateBlockedTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBlockedTimeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBlockedTimeRequestWithBody generates requests for CreateBlockedTime with any type of body
func NewCreateBlockedTimeRequestWithBody(server string, params *CreateBlockedTimeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/blocked_times")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBlockedTimeRequest generates requests for DeleteBlockedTime
func NewDeleteBlockedTimeRequest(server string, blockedTimeId string, params *DeleteBlockedTimeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blocked_time_id", runtime.ParamLocationPath, blockedTimeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/blocked_times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockedTimeRequest generates requests for GetBlockedTime
func NewGetBlockedTimeRequest(server string, blockedTimeId string, params *GetBlockedTimeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blocked_time_id", runtime.ParamLocationPath, blockedTimeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/blocked_times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBlockedTimeRequest calls the generic UpdateBlockedTime builder with application/json body
func NewUpdateBlockedTimeRequest(server string, blockedTimeId string, params *UpdateBlockedTimeParams, body UpdateBlockedTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBlockedTimeRequestWithBody(server, blockedTimeId, params, "application/json", bodyReader)
}

// NewUpdateBlockedTimeRequestWithBody generates requests for UpdateBlockedTime with any type of body
func NewUpdateBlockedTimeRequestWithBody(server string, blockedTimeId string, params *UpdateBlockedTimeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blocked_time_id", runtime.ParamLocationPath, blockedTimeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/blocked_times/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompaniesRequest generates requests for GetCompanies
func NewGetCompaniesRequest(server string, params *GetCompaniesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCompanyRequest calls the generic CreateCompany builder with application/json body
func NewCreateCompanyRequest(server string, params *CreateCompanyParams, body CreateCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCompanyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCompanyRequestWithBody generates requests for CreateCompany with any type of body
func NewCreateCompanyRequestWithBody(server string, params *CreateCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompanyRequest generates requests for GetCompany
func NewGetCompanyRequest(server string, companyId string, params *GetCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCompanyRequest calls the generic UpdateCompany builder with application/json body
func NewUpdateCompanyRequest(server string, companyId string, params *UpdateCompanyParams, body UpdateCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCompanyRequestWithBody(server, companyId, params, "application/json", bodyReader)
}

// NewUpdateCompanyRequestWithBody generates requests for UpdateCompany with any type of body
func NewUpdateCompanyRequestWithBody(server string, companyId string, params *UpdateCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCompanyActivitiesRequest generates requests for ListAllCompanyActivities
func NewListAllCompanyActivitiesRequest(server string, companyId string, params *ListAllCompanyActivitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/activities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, companyId string, params *ListAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, companyId string, appId string, params *GetAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableAppRequest generates requests for DisableApp
func NewDisableAppRequest(server string, companyId string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/apps/%s/disable", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBlockedTimesRequest generates requests for ListBlockedTimes
func NewListBlockedTimesRequest(server string, companyId string, params *ListBlockedTimesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/blocked_times", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClaimsRequest generates requests for ListClaims
func NewListClaimsRequest(server string, companyId string, params *ListClaimsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/claims", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomerGroupsRequest generates requests for ListCustomerGroups
func NewListCustomerGroupsRequest(server string, companyId string, params *ListCustomerGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/customer_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomersRequest generates requests for ListCustomers
func NewListCustomersRequest(server string, companyId string, params *ListCustomersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/customers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEmployeesRequest generates requests for ListEmployees
func NewListEmployeesRequest(server string, companyId string, params *ListEmployeesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/employees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEmployeeRequest generates requests for DeleteEmployee
func NewDeleteEmployeeRequest(server string, companyId string, employeeId string, params *DeleteEmployeeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "employee_id", runtime.ParamLocationPath, employeeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/employees/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmployeeRequest generates requests for GetEmployee
func NewGetEmployeeRequest(server string, companyId string, employeeId string, params *GetEmployeeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "employee_id", runtime.ParamLocationPath, employeeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/employees/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEmployeeRequest calls the generic UpdateEmployee builder with application/json body
func NewUpdateEmployeeRequest(server string, companyId string, employeeId string, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEmployeeRequestWithBody(server, companyId, employeeId, params, "application/json", bodyReader)
}

// NewUpdateEmployeeRequestWithBody generates requests for UpdateEmployee with any type of body
func NewUpdateEmployeeRequestWithBody(server string, companyId string, employeeId string, params *UpdateEmployeeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "employee_id", runtime.ParamLocationPath, employeeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/employees/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Unset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unset", runtime.ParamLocationQuery, *params.Unset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEventStatusesRequest generates requests for ListEventStatuses
func NewListEventStatusesRequest(server string, companyId string, params *ListEventStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/event_statuses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventTypeCategoriesRequest generates requests for ListEventTypeCategories
func NewListEventTypeCategoriesRequest(server string, companyId string, params *ListEventTypeCategoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/event_type_categories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventTypeCategoryGroupsRequest generates requests for ListEventTypeCategoryGroups
func NewListEventTypeCategoryGroupsRequest(server string, companyId string, params *ListEventTypeCategoryGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/event_type_category_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventTypeGroupsRequest generates requests for ListEventTypeGroups
func NewListEventTypeGroupsRequest(server string, companyId string, params *ListEventTypeGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/event_type_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventTypesRequest generates requests for ListEventTypes
func NewListEventTypesRequest(server string, companyId string, params *ListEventTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/event_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsRequest generates requests for ListEvents
func NewListEventsRequest(server string, companyId string, params *ListEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.From != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.To != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.PhoneNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phone_number", runtime.ParamLocationQuery, *params.PhoneNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PhoneCountryCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phone_country_code", runtime.ParamLocationQuery, *params.PhoneCountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckinWithPaymentRequest generates requests for CheckinWithPayment
func NewCheckinWithPaymentRequest(server string, companyId string, id string, params *CheckinWithPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/events/%s/checkin", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TerminalId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "terminal_id", runtime.ParamLocationQuery, *params.TerminalId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VoucherId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "voucher_id", runtime.ParamLocationQuery, *params.VoucherId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHolidaysRequest generates requests for ListHolidays
func NewListHolidaysRequest(server string, companyId string, params *ListHolidaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/holidays", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryParamBuf, err := json.Marshal(params.Filter); err != nil {
		return nil, err
	} else {
		queryValues.Add("filter", string(queryParamBuf))
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.AcceptLanguage != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept-Language", headerParam0)
	}

	return req, nil
}

// NewListIssuersRequest generates requests for ListIssuers
func NewListIssuersRequest(server string, companyId string, params *ListIssuersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/issuers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMemosRequest generates requests for ListMemos
func NewListMemosRequest(server string, companyId string, params *ListMemosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/memos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSalesMetricsRequest generates requests for GetSalesMetrics
func NewGetSalesMetricsRequest(server string, companyId string, params *GetSalesMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/metrics/sales", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNotificationsRequest generates requests for DeleteNotifications
func NewDeleteNotificationsRequest(server string, companyId string, params *DeleteNotificationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/notifications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNotificationsRequest generates requests for ListNotifications
func NewListNotificationsRequest(server string, companyId string, params *ListNotificationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/notifications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOpeningHoursRequest generates requests for ListOpeningHours
func NewListOpeningHoursRequest(server string, companyId string, params *ListOpeningHoursParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/opening_hours", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentsRequest generates requests for ListPayments
func NewListPaymentsRequest(server string, companyId string, params *ListPaymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/payments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomPropertiesRequest generates requests for ListCustomProperties
func NewListCustomPropertiesRequest(server string, companyId string, params *ListCustomPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/properties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceGroupsRequest generates requests for ListResourceGroups
func NewListResourceGroupsRequest(server string, companyId string, params *ListResourceGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/resource_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourcesRequest generates requests for ListResources
func NewListResourcesRequest(server string, companyId string, params *ListResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRuleSetTemplatesRequest generates requests for ListRuleSetTemplates
func NewListRuleSetTemplatesRequest(server string, companyId string, params *ListRuleSetTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/rule_set_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRuleSetsRequest generates requests for ListRuleSets
func NewListRuleSetsRequest(server string, companyId string, params *ListRuleSetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/rule_sets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSalesRequest generates requests for ListSales
func NewListSalesRequest(server string, companyId string, params *ListSalesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/sales", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSettlementsRequest generates requests for ListSettlements
func NewListSettlementsRequest(server string, companyId string, params *ListSettlementsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/settlements", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSMSMessagesRequest generates requests for ListSMSMessages
func NewListSMSMessagesRequest(server string, companyId string, params *ListSMSMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/sms_messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesRequest generates requests for ListSpaces
func NewListSpacesRequest(server string, companyId string, params *ListSpacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionRequest calls the generic CreateSubscription builder with application/json body
func NewCreateSubscriptionRequest(server string, companyId string, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionRequestWithBody(server, companyId, params, "application/json", bodyReader)
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, companyId string, params *CreateSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/subscriptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionBillingInfoRequest generates requests for GetSubscriptionBillingInfo
func NewGetSubscriptionBillingInfoRequest(server string, companyId string, params *GetSubscriptionBillingInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/subscriptions/billing_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBillingInfoRequest calls the generic UpdateBillingInfo builder with application/json body
func NewUpdateBillingInfoRequest(server string, companyId string, params *UpdateBillingInfoParams, body UpdateBillingInfoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBillingInfoRequestWithBody(server, companyId, params, "application/json", bodyReader)
}

// NewUpdateBillingInfoRequestWithBody generates requests for UpdateBillingInfo with any type of body
func NewUpdateBillingInfoRequestWithBody(server string, companyId string, params *UpdateBillingInfoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/subscriptions/billing_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBillingInvoicesRequest generates requests for ListBillingInvoices
func NewListBillingInvoicesRequest(server string, companyId string, params *ListBillingInvoicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/subscriptions/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePaymentIntentRequest generates requests for CreatePaymentIntent
func NewCreatePaymentIntentRequest(server string, companyId string, params *CreatePaymentIntentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/subscriptions/payment_intent", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTerminalsRequest generates requests for ListTerminals
func NewListTerminalsRequest(server string, companyId string, params *ListTerminalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/terminals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTimeSlotReservationsRequest generates requests for ListTimeSlotReservations
func NewListTimeSlotReservationsRequest(server string, companyId string, params *ListTimeSlotReservationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/time_slot_reservations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTimeSlotsRequest generates requests for ListTimeSlots
func NewListTimeSlotsRequest(server string, companyId string, params *ListTimeSlotsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/time_slots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EmployeeId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "employee_id", runtime.ParamLocationQuery, *params.EmployeeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ResourceId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_id", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EventTypeIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type_ids", runtime.ParamLocationQuery, *params.EventTypeIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EventId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_id", runtime.ParamLocationQuery, *params.EventId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, params.StartDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, params.EndDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTransactionsRequest generates requests for ListTransactions
func NewListTransactionsRequest(server string, companyId string, params *ListTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVATsRequest generates requests for ListVATs
func NewListVATsRequest(server string, companyId string, params *ListVATsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/vats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVoucherTemplatesRequest generates requests for ListVoucherTemplates
func NewListVoucherTemplatesRequest(server string, companyId string, params *ListVoucherTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/voucher_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVouchersRequest generates requests for ListVouchers
func NewListVouchersRequest(server string, companyId string, params *ListVouchersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/vouchers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWaitlistEntriesRequest generates requests for ListWaitlistEntries
func NewListWaitlistEntriesRequest(server string, companyId string, params *ListWaitlistEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/waitlist_entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWebhookInvocationsRequest generates requests for ListWebhookInvocations
func NewListWebhookInvocationsRequest(server string, companyId string, params *ListWebhookInvocationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/webhook_invocations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWebhooksRequest generates requests for ListWebhooks
func NewListWebhooksRequest(server string, companyId string, params *ListWebhooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/companies/%s/webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomerGroupRequest calls the generic CreateCustomerGroup builder with application/json body
func NewCreateCustomerGroupRequest(server string, params *CreateCustomerGroupParams, body CreateCustomerGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomerGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCustomerGroupRequestWithBody generates requests for CreateCustomerGroup with any type of body
func NewCreateCustomerGroupRequestWithBody(server string, params *CreateCustomerGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customer_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomerGroupRequest generates requests for DeleteCustomerGroup
func NewDeleteCustomerGroupRequest(server string, customerGroupId string, params *DeleteCustomerGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_group_id", runtime.ParamLocationPath, customerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customer_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerGroupRequest generates requests for GetCustomerGroup
func NewGetCustomerGroupRequest(server string, customerGroupId string, params *GetCustomerGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_group_id", runtime.ParamLocationPath, customerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customer_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomerGroupRequest calls the generic UpdateCustomerGroup builder with application/json body
func NewUpdateCustomerGroupRequest(server string, customerGroupId string, params *UpdateCustomerGroupParams, body UpdateCustomerGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerGroupRequestWithBody(server, customerGroupId, params, "application/json", bodyReader)
}

// NewUpdateCustomerGroupRequestWithBody generates requests for UpdateCustomerGroup with any type of body
func NewUpdateCustomerGroupRequestWithBody(server string, customerGroupId string, params *UpdateCustomerGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_group_id", runtime.ParamLocationPath, customerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customer_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCustomerRequest calls the generic CreateCustomer builder with application/json body
func NewCreateCustomerRequest(server string, params *CreateCustomerParams, body CreateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCustomerRequestWithBody generates requests for CreateCustomer with any type of body
func NewCreateCustomerRequestWithBody(server string, params *CreateCustomerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomerRequest generates requests for DeleteCustomer
func NewDeleteCustomerRequest(server string, customerId string, params *DeleteCustomerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, customerId string, params *GetCustomerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomerRequest calls the generic UpdateCustomer builder with application/json body
func NewUpdateCustomerRequest(server string, customerId string, params *UpdateCustomerParams, body UpdateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerRequestWithBody(server, customerId, params, "application/json", bodyReader)
}

// NewUpdateCustomerRequestWithBody generates requests for UpdateCustomer with any type of body
func NewUpdateCustomerRequestWithBody(server string, customerId string, params *UpdateCustomerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEmployeeRequest calls the generic CreateEmployee builder with application/json body
func NewCreateEmployeeRequest(server string, params *CreateEmployeeParams, body CreateEmployeeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEmployeeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEmployeeRequestWithBody generates requests for CreateEmployee with any type of body
func NewCreateEmployeeRequestWithBody(server string, params *CreateEmployeeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/employees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnterpriseRequest generates requests for GetEnterprise
func NewGetEnterpriseRequest(server string, params *GetEnterpriseParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterpise")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEnterpriseRequest calls the generic UpdateEnterprise builder with application/json body
func NewUpdateEnterpriseRequest(server string, params *UpdateEnterpriseParams, body UpdateEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnterpriseRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateEnterpriseRequestWithBody generates requests for UpdateEnterprise with any type of body
func NewUpdateEnterpriseRequestWithBody(server string, params *UpdateEnterpriseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterpise")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEnterpriseCompaniesRequest generates requests for ListEnterpriseCompanies
func NewListEnterpriseCompaniesRequest(server string, enterpriseId string, params *ListEnterpriseCompaniesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/companies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaymentsLegacyRequest generates requests for ListPaymentsLegacy
func NewListPaymentsLegacyRequest(server string, enterpriseId string, params *ListPaymentsLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/payments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.Search != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEnterpriseSettlementAccountsRequest generates requests for ListEnterpriseSettlementAccounts
func NewListEnterpriseSettlementAccountsRequest(server string, enterpriseId string, params *ListEnterpriseSettlementAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/settlement_accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEnterpriseSettlementAccountRequest generates requests for DeleteEnterpriseSettlementAccount
func NewDeleteEnterpriseSettlementAccountRequest(server string, enterpriseId string, settlementAccountId string, params *DeleteEnterpriseSettlementAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "settlement_account_id", runtime.ParamLocationPath, settlementAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/settlement_accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnterpriseSettlementAccountRequest generates requests for GetEnterpriseSettlementAccount
func NewGetEnterpriseSettlementAccountRequest(server string, enterpriseId string, settlementAccountId string, params *GetEnterpriseSettlementAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "settlement_account_id", runtime.ParamLocationPath, settlementAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/settlement_accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSettlementsLegacyRequest generates requests for ListSettlementsLegacy
func NewListSettlementsLegacyRequest(server string, enterpriseId string, params *ListSettlementsLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/settlements", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVoucherTemplatesLegacyRequest generates requests for ListVoucherTemplatesLegacy
func NewListVoucherTemplatesLegacyRequest(server string, enterpriseId string, params *ListVoucherTemplatesLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/voucher_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVoucherTemplateLegacyRequest calls the generic CreateVoucherTemplateLegacy builder with application/json body
func NewCreateVoucherTemplateLegacyRequest(server string, enterpriseId string, params *CreateVoucherTemplateLegacyParams, body CreateVoucherTemplateLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVoucherTemplateLegacyRequestWithBody(server, enterpriseId, params, "application/json", bodyReader)
}

// NewCreateVoucherTemplateLegacyRequestWithBody generates requests for CreateVoucherTemplateLegacy with any type of body
func NewCreateVoucherTemplateLegacyRequestWithBody(server string, enterpriseId string, params *CreateVoucherTemplateLegacyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/voucher_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVouchersLegacyRequest generates requests for ListVouchersLegacy
func NewListVouchersLegacyRequest(server string, enterpriseId string, params *ListVouchersLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/vouchers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoucherLegacyRequest generates requests for GetVoucherLegacy
func NewGetVoucherLegacyRequest(server string, enterpriseId string, voucherId string, params *GetVoucherLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "voucher_id", runtime.ParamLocationPath, voucherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/vouchers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVoucherLegacyRequest calls the generic UpdateVoucherLegacy builder with application/json body
func NewUpdateVoucherLegacyRequest(server string, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, body UpdateVoucherLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVoucherLegacyRequestWithBody(server, enterpriseId, voucherId, params, "application/json", bodyReader)
}

// NewUpdateVoucherLegacyRequestWithBody generates requests for UpdateVoucherLegacy with any type of body
func NewUpdateVoucherLegacyRequestWithBody(server string, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_id", runtime.ParamLocationPath, enterpriseId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "voucher_id", runtime.ParamLocationPath, voucherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/enterprise/%s/vouchers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEventStatusRequest calls the generic CreateEventStatus builder with application/json body
func NewCreateEventStatusRequest(server string, params *CreateEventStatusParams, body CreateEventStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEventStatusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEventStatusRequestWithBody generates requests for CreateEventStatus with any type of body
func NewCreateEventStatusRequestWithBody(server string, params *CreateEventStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_statuses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEventStatusRequest generates requests for DeleteEventStatus
func NewDeleteEventStatusRequest(server string, eventStatusId string, params *DeleteEventStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_status_id", runtime.ParamLocationPath, eventStatusId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_statuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventStatusRequest generates requests for GetEventStatus
func NewGetEventStatusRequest(server string, eventStatusId string, params *GetEventStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_status_id", runtime.ParamLocationPath, eventStatusId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_statuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEventStatusRequest calls the generic UpdateEventStatus builder with application/json body
func NewUpdateEventStatusRequest(server string, eventStatusId string, params *UpdateEventStatusParams, body UpdateEventStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEventStatusRequestWithBody(server, eventStatusId, params, "application/json", bodyReader)
}

// NewUpdateEventStatusRequestWithBody generates requests for UpdateEventStatus with any type of body
func NewUpdateEventStatusRequestWithBody(server string, eventStatusId string, params *UpdateEventStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_status_id", runtime.ParamLocationPath, eventStatusId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_statuses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEventTypeGroupRequest generates requests for GetEventTypeGroup
func NewGetEventTypeGroupRequest(server string, eventTypeGroupId string, params *GetEventTypeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_type_group_id", runtime.ParamLocationPath, eventTypeGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_type_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEventTypeRequest calls the generic CreateEventType builder with application/json body
func NewCreateEventTypeRequest(server string, params *CreateEventTypeParams, body CreateEventTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEventTypeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEventTypeRequestWithBody generates requests for CreateEventType with any type of body
func NewCreateEventTypeRequestWithBody(server string, params *CreateEventTypeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEventTypeRequest generates requests for DeleteEventType
func NewDeleteEventTypeRequest(server string, eventTypeId string, params *DeleteEventTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_type_id", runtime.ParamLocationPath, eventTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventTypeRequest generates requests for GetEventType
func NewGetEventTypeRequest(server string, eventTypeId string, params *GetEventTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_type_id", runtime.ParamLocationPath, eventTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEventTypeRequest calls the generic UpdateEventType builder with application/json body
func NewUpdateEventTypeRequest(server string, eventTypeId string, params *UpdateEventTypeParams, body UpdateEventTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEventTypeRequestWithBody(server, eventTypeId, params, "application/json", bodyReader)
}

// NewUpdateEventTypeRequestWithBody generates requests for UpdateEventType with any type of body
func NewUpdateEventTypeRequestWithBody(server string, eventTypeId string, params *UpdateEventTypeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_type_id", runtime.ParamLocationPath, eventTypeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/event_types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Unset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unset", runtime.ParamLocationQuery, *params.Unset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEventRequest calls the generic CreateEvent builder with application/json body
func NewCreateEventRequest(server string, params *CreateEventParams, body CreateEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEventRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEventRequestWithBody generates requests for CreateEvent with any type of body
func NewCreateEventRequestWithBody(server string, params *CreateEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEventRequest generates requests for DeleteEvent
func NewDeleteEventRequest(server string, eventId string, params *DeleteEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventRequest generates requests for GetEvent
func NewGetEventRequest(server string, eventId string, params *GetEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEventRequest calls the generic UpdateEvent builder with application/json body
func NewUpdateEventRequest(server string, eventId string, params *UpdateEventParams, body UpdateEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEventRequestWithBody(server, eventId, params, "application/json", bodyReader)
}

// NewUpdateEventRequestWithBody generates requests for UpdateEvent with any type of body
func NewUpdateEventRequestWithBody(server string, eventId string, params *UpdateEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCheckoutForEventRequest generates requests for CreateCheckoutForEvent
func NewCreateCheckoutForEventRequest(server string, eventId string, params *CreateCheckoutForEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/events/%s/checkout", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCompanyFiscalizationDataRequest generates requests for DeleteCompanyFiscalizationData
func NewDeleteCompanyFiscalizationDataRequest(server string, companyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/companies/%s/onboarding", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompanyFiscalizationDataRequest generates requests for GetCompanyFiscalizationData
func NewGetCompanyFiscalizationDataRequest(server string, companyId string, params *GetCompanyFiscalizationDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/companies/%s/onboarding", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertCompanyFiscalizationDataRequest calls the generic UpsertCompanyFiscalizationData builder with application/json body
func NewUpsertCompanyFiscalizationDataRequest(server string, companyId string, body UpsertCompanyFiscalizationDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertCompanyFiscalizationDataRequestWithBody(server, companyId, "application/json", bodyReader)
}

// NewUpsertCompanyFiscalizationDataRequestWithBody generates requests for UpsertCompanyFiscalizationData with any type of body
func NewUpsertCompanyFiscalizationDataRequestWithBody(server string, companyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/companies/%s/onboarding", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFiscalizationReportRequest generates requests for GetFiscalizationReport
func NewGetFiscalizationReportRequest(server string, companyId string, params *GetFiscalizationReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/companies/%s/report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFiscalizeTransactionRequest calls the generic FiscalizeTransaction builder with application/json body
func NewFiscalizeTransactionRequest(server string, transactionId string, params *FiscalizeTransactionParams, body FiscalizeTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFiscalizeTransactionRequestWithBody(server, transactionId, params, "application/json", bodyReader)
}

// NewFiscalizeTransactionRequestWithBody generates requests for FiscalizeTransaction with any type of body
func NewFiscalizeTransactionRequestWithBody(server string, transactionId string, params *FiscalizeTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendFiscalizedTransactionPDFRequest calls the generic SendFiscalizedTransactionPDF builder with application/json body
func NewSendFiscalizedTransactionPDFRequest(server string, transactionId string, body SendFiscalizedTransactionPDFJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendFiscalizedTransactionPDFRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewSendFiscalizedTransactionPDFRequestWithBody generates requests for SendFiscalizedTransactionPDF with any type of body
func NewSendFiscalizedTransactionPDFRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/transactions/%s/email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFiscalizedTransactionPDFRequest generates requests for GetFiscalizedTransactionPDF
func NewGetFiscalizedTransactionPDFRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/transactions/%s/pdf", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefundFiscalizedTransactionRequest generates requests for RefundFiscalizedTransaction
func NewRefundFiscalizedTransactionRequest(server string, transactionId string, params *RefundFiscalizedTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/fiscalizations/transactions/%s/refund", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdyenCompanyOnboardingStatusRequest generates requests for AdyenCompanyOnboardingStatus
func NewAdyenCompanyOnboardingStatusRequest(server string, companyId string, params *AdyenCompanyOnboardingStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/adyen/companies/%s/onboarding", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdyenCompanyOnboardingRequest calls the generic AdyenCompanyOnboarding builder with application/json body
func NewAdyenCompanyOnboardingRequest(server string, companyId string, params *AdyenCompanyOnboardingParams, body AdyenCompanyOnboardingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdyenCompanyOnboardingRequestWithBody(server, companyId, params, "application/json", bodyReader)
}

// NewAdyenCompanyOnboardingRequestWithBody generates requests for AdyenCompanyOnboarding with any type of body
func NewAdyenCompanyOnboardingRequestWithBody(server string, companyId string, params *AdyenCompanyOnboardingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/adyen/companies/%s/onboarding", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAdyenUserOnboardingStatusRequest generates requests for AdyenUserOnboardingStatus
func NewAdyenUserOnboardingStatusRequest(server string, userId string, params *AdyenUserOnboardingStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/adyen/users/%s/onboarding", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdyenUserOnboardingRequest calls the generic AdyenUserOnboarding builder with application/json body
func NewAdyenUserOnboardingRequest(server string, userId string, params *AdyenUserOnboardingParams, body AdyenUserOnboardingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdyenUserOnboardingRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewAdyenUserOnboardingRequestWithBody generates requests for AdyenUserOnboarding with any type of body
func NewAdyenUserOnboardingRequestWithBody(server string, userId string, params *AdyenUserOnboardingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/adyen/users/%s/onboarding", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSaltpayCompaniesRequest generates requests for ListSaltpayCompanies
func NewListSaltpayCompaniesRequest(server string, params *ListSaltpayCompaniesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/saltpay/companies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkSaltpayBankAccountRequest calls the generic LinkSaltpayBankAccount builder with application/json body
func NewLinkSaltpayBankAccountRequest(server string, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, body LinkSaltpayBankAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkSaltpayBankAccountRequestWithBody(server, companyId, bankAccountId, params, "application/json", bodyReader)
}

// NewLinkSaltpayBankAccountRequestWithBody generates requests for LinkSaltpayBankAccount with any type of body
func NewLinkSaltpayBankAccountRequestWithBody(server string, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "bank_account_id", runtime.ParamLocationPath, bankAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/saltpay/companies/%s/bank_accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSaltpayStoresAtCompanyRequest generates requests for ListSaltpayStoresAtCompany
func NewListSaltpayStoresAtCompanyRequest(server string, companyId string, params *ListSaltpayStoresAtCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/saltpay/companies/%s/stores", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSaltpayStoresRequest generates requests for ListSaltpayStores
func NewListSaltpayStoresRequest(server string, params *ListSaltpayStoresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/saltpay/stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSaltpayTerminalsRequest generates requests for ListSaltpayTerminals
func NewListSaltpayTerminalsRequest(server string, storeId string, params *ListSaltpayTerminalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "store_id", runtime.ParamLocationPath, storeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/saltpay/stores/%s/terminals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSaltpayTerminalRequest calls the generic UpdateSaltpayTerminal builder with application/json body
func NewUpdateSaltpayTerminalRequest(server string, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, body UpdateSaltpayTerminalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSaltpayTerminalRequestWithBody(server, storeId, terminalId, params, "application/json", bodyReader)
}

// NewUpdateSaltpayTerminalRequestWithBody generates requests for UpdateSaltpayTerminal with any type of body
func NewUpdateSaltpayTerminalRequestWithBody(server string, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "store_id", runtime.ParamLocationPath, storeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "terminal_id", runtime.ParamLocationPath, terminalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/integrations/saltpay/stores/%s/terminals/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLineItemRequest calls the generic CreateLineItem builder with application/json body
func NewCreateLineItemRequest(server string, params *CreateLineItemParams, body CreateLineItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLineItemRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLineItemRequestWithBody generates requests for CreateLineItem with any type of body
func NewCreateLineItemRequestWithBody(server string, params *CreateLineItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/line_items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLineItemRequest generates requests for DeleteLineItem
func NewDeleteLineItemRequest(server string, lineItemId string, params *DeleteLineItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "line_item_id", runtime.ParamLocationPath, lineItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/line_items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLineItemRequest generates requests for GetLineItem
func NewGetLineItemRequest(server string, lineItemId string, params *GetLineItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "line_item_id", runtime.ParamLocationPath, lineItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/line_items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLineItemRequest calls the generic UpdateLineItem builder with application/json body
func NewUpdateLineItemRequest(server string, lineItemId string, params *UpdateLineItemParams, body UpdateLineItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLineItemRequestWithBody(server, lineItemId, params, "application/json", bodyReader)
}

// NewUpdateLineItemRequestWithBody generates requests for UpdateLineItem with any type of body
func NewUpdateLineItemRequestWithBody(server string, lineItemId string, params *UpdateLineItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "line_item_id", runtime.ParamLocationPath, lineItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/line_items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateMemoRequest calls the generic CreateMemo builder with application/json body
func NewCreateMemoRequest(server string, params *CreateMemoParams, body CreateMemoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMemoRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMemoRequestWithBody generates requests for CreateMemo with any type of body
func NewCreateMemoRequestWithBody(server string, params *CreateMemoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/memos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMemoRequest generates requests for DeleteMemo
func NewDeleteMemoRequest(server string, memoId string, params *DeleteMemoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "memo_id", runtime.ParamLocationPath, memoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/memos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMemoRequest generates requests for GetMemo
func NewGetMemoRequest(server string, memoId string, params *GetMemoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "memo_id", runtime.ParamLocationPath, memoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/memos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMemoRequest calls the generic UpdateMemo builder with application/json body
func NewUpdateMemoRequest(server string, memoId string, params *UpdateMemoParams, body UpdateMemoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMemoRequestWithBody(server, memoId, params, "application/json", bodyReader)
}

// NewUpdateMemoRequestWithBody generates requests for UpdateMemo with any type of body
func NewUpdateMemoRequestWithBody(server string, memoId string, params *UpdateMemoParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "memo_id", runtime.ParamLocationPath, memoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/memos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateNotificationRequest calls the generic CreateNotification builder with application/json body
func NewCreateNotificationRequest(server string, body CreateNotificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationRequestWithBody generates requests for CreateNotification with any type of body
func NewCreateNotificationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationRequest generates requests for DeleteNotification
func NewDeleteNotificationRequest(server string, notificationId string, params *DeleteNotificationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notification_id", runtime.ParamLocationPath, notificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/notifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationRequest generates requests for GetNotification
func NewGetNotificationRequest(server string, notificationId string, params *GetNotificationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notification_id", runtime.ParamLocationPath, notificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/notifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOAuthApplicationsRequest generates requests for ListOAuthApplications
func NewListOAuthApplicationsRequest(server string, params *ListOAuthApplicationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/applications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOAuthApplicationRequest calls the generic CreateOAuthApplication builder with application/json body
func NewCreateOAuthApplicationRequest(server string, params *CreateOAuthApplicationParams, body CreateOAuthApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOAuthApplicationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOAuthApplicationRequestWithBody generates requests for CreateOAuthApplication with any type of body
func NewCreateOAuthApplicationRequestWithBody(server string, params *CreateOAuthApplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/applications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOAuthApplicationRequest generates requests for DeleteOAuthApplication
func NewDeleteOAuthApplicationRequest(server string, applicationId string, params *DeleteOAuthApplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "application_id", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthApplicationRequest generates requests for GetOAuthApplication
func NewGetOAuthApplicationRequest(server string, applicationId string, params *GetOAuthApplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "application_id", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOAuthApplicationRequest calls the generic UpdateOAuthApplication builder with application/json body
func NewUpdateOAuthApplicationRequest(server string, applicationId string, params *UpdateOAuthApplicationParams, body UpdateOAuthApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOAuthApplicationRequestWithBody(server, applicationId, params, "application/json", bodyReader)
}

// NewUpdateOAuthApplicationRequestWithBody generates requests for UpdateOAuthApplication with any type of body
func NewUpdateOAuthApplicationRequestWithBody(server string, applicationId string, params *UpdateOAuthApplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "application_id", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartOAuthFlowRequest generates requests for StartOAuthFlow
func NewStartOAuthFlowRequest(server string, params *StartOAuthFlowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOAuthConsentRequest calls the generic CreateOAuthConsent builder with application/json body
func NewCreateOAuthConsentRequest(server string, body CreateOAuthConsentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOAuthConsentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOAuthConsentRequestWithBody generates requests for CreateOAuthConsent with any type of body
func NewCreateOAuthConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOAuthPublicKeyRequest generates requests for GetOAuthPublicKey
func NewGetOAuthPublicKeyRequest(server string, params *GetOAuthPublicKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/publickey")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOAuthScopesRequest generates requests for ListOAuthScopes
func NewListOAuthScopesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/scopes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthTokenRequest calls the generic GetOAuthToken builder with application/json body
func NewGetOAuthTokenRequest(server string, params *GetOAuthTokenParams, body GetOAuthTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOAuthTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetOAuthTokenRequestWithBody generates requests for GetOAuthToken with any type of body
func NewGetOAuthTokenRequestWithBody(server string, params *GetOAuthTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/oauth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_secret", runtime.ParamLocationQuery, params.ClientSecret); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPaymentMethodsRequest generates requests for ListPaymentMethods
func NewListPaymentMethodsRequest(server string, params *ListPaymentMethodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/payment_methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentRequest generates requests for GetPayment
func NewGetPaymentRequest(server string, paymentId string, params *GetPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_id", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/payments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePaymentRequest calls the generic UpdatePayment builder with application/json body
func NewUpdatePaymentRequest(server string, paymentId string, params *UpdatePaymentParams, body UpdatePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePaymentRequestWithBody(server, paymentId, params, "application/json", bodyReader)
}

// NewUpdatePaymentRequestWithBody generates requests for UpdatePayment with any type of body
func NewUpdatePaymentRequestWithBody(server string, paymentId string, params *UpdatePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_id", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/payments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadPaymentReceiptRequest generates requests for DownloadPaymentReceipt
func NewDownloadPaymentReceiptRequest(server string, paymentId string, params *DownloadPaymentReceiptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_id", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/payments/%s/receipt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendPaymentReceiptRequest calls the generic SendPaymentReceipt builder with application/json body
func NewSendPaymentReceiptRequest(server string, paymentId string, params *SendPaymentReceiptParams, body SendPaymentReceiptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendPaymentReceiptRequestWithBody(server, paymentId, params, "application/json", bodyReader)
}

// NewSendPaymentReceiptRequestWithBody generates requests for SendPaymentReceipt with any type of body
func NewSendPaymentReceiptRequestWithBody(server string, paymentId string, params *SendPaymentReceiptParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payment_id", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/payments/%s/receipt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPricingRequest generates requests for ListPricing
func NewListPricingRequest(server string, params *ListPricingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/pricing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCalculatePricingRequest generates requests for CalculatePricing
func NewCalculatePricingRequest(server string, params *CalculatePricingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/pricing/calculator")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country_code", runtime.ParamLocationQuery, params.CountryCode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "staff", runtime.ParamLocationQuery, params.Staff); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resources", runtime.ParamLocationQuery, params.Resources); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPricingByCountryCodeRequest generates requests for GetPricingByCountryCode
func NewGetPricingByCountryCodeRequest(server string, countryCode string, params *GetPricingByCountryCodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "country_code", runtime.ParamLocationPath, countryCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/pricing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Product != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product", runtime.ParamLocationQuery, *params.Product); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProductGroupsRequest generates requests for ListProductGroups
func NewListProductGroupsRequest(server string, params *ListProductGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/product_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProductGroupRequest calls the generic CreateProductGroup builder with application/json body
func NewCreateProductGroupRequest(server string, params *CreateProductGroupParams, body CreateProductGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProductGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateProductGroupRequestWithBody generates requests for CreateProductGroup with any type of body
func NewCreateProductGroupRequestWithBody(server string, params *CreateProductGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/product_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupsAndProductsRequest generates requests for ListGroupsAndProducts
func NewListGroupsAndProductsRequest(server string, params *ListGroupsAndProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/product_groups/expanded")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProductGroupsOrderRequest calls the generic UpdateProductGroupsOrder builder with application/json body
func NewUpdateProductGroupsOrderRequest(server string, params *UpdateProductGroupsOrderParams, body UpdateProductGroupsOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductGroupsOrderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateProductGroupsOrderRequestWithBody generates requests for UpdateProductGroupsOrder with any type of body
func NewUpdateProductGroupsOrderRequestWithBody(server string, params *UpdateProductGroupsOrderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/product_groups/order")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductGroupRequest generates requests for DeleteProductGroup
func NewDeleteProductGroupRequest(server string, id string, params *DeleteProductGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/product_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductGroupRequest generates requests for GetProductGroup
func NewGetProductGroupRequest(server string, id string, params *GetProductGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/product_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProductGroupRequest calls the generic UpdateProductGroup builder with application/json body
func NewUpdateProductGroupRequest(server string, id string, params *UpdateProductGroupParams, body UpdateProductGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductGroupRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateProductGroupRequestWithBody generates requests for UpdateProductGroup with any type of body
func NewUpdateProductGroupRequestWithBody(server string, id string, params *UpdateProductGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/product_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProductsRequest generates requests for ListProducts
func NewListProductsRequest(server string, params *ListProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	if params.Sort != nil {

		if queryParamBuf, err := json.Marshal(*params.Sort); err != nil {
			return nil, err
		} else {
			queryValues.Add("sort", string(queryParamBuf))
		}

	}

	if params.Pagination != nil {

		if queryParamBuf, err := json.Marshal(*params.Pagination); err != nil {
			return nil, err
		} else {
			queryValues.Add("pagination", string(queryParamBuf))
		}

	}

	if params.Barcode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcode", runtime.ParamLocationQuery, *params.Barcode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProductRequest calls the generic CreateProduct builder with application/json body
func NewCreateProductRequest(server string, params *CreateProductParams, body CreateProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProductRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateProductRequestWithBody generates requests for CreateProduct with any type of body
func NewCreateProductRequestWithBody(server string, params *CreateProductParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductRequest generates requests for DeleteProduct
func NewDeleteProductRequest(server string, id string, params *DeleteProductParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductRequest generates requests for GetProduct
func NewGetProductRequest(server string, id string, params *GetProductParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProductRequest calls the generic UpdateProduct builder with application/json body
func NewUpdateProductRequest(server string, id string, params *UpdateProductParams, body UpdateProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateProductRequestWithBody generates requests for UpdateProduct with any type of body
func NewUpdateProductRequestWithBody(server string, id string, params *UpdateProductParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCustomPropertyRequest calls the generic CreateCustomProperty builder with application/json body
func NewCreateCustomPropertyRequest(server string, params *CreateCustomPropertyParams, body CreateCustomPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomPropertyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCustomPropertyRequestWithBody generates requests for CreateCustomProperty with any type of body
func NewCreateCustomPropertyRequestWithBody(server string, params *CreateCustomPropertyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/properties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomPropertyRequest generates requests for DeleteCustomProperty
func NewDeleteCustomPropertyRequest(server string, propertyId string, params *DeleteCustomPropertyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property_id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/properties/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomPropertyRequest calls the generic UpdateCustomProperty builder with application/json body
func NewUpdateCustomPropertyRequest(server string, propertyId string, params *UpdateCustomPropertyParams, body UpdateCustomPropertyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomPropertyRequestWithBody(server, propertyId, params, "application/json", bodyReader)
}

// NewUpdateCustomPropertyRequestWithBody generates requests for UpdateCustomProperty with any type of body
func NewUpdateCustomPropertyRequestWithBody(server string, propertyId string, params *UpdateCustomPropertyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property_id", runtime.ParamLocationPath, propertyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/properties/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateResourceGroupRequest calls the generic CreateResourceGroup builder with application/json body
func NewCreateResourceGroupRequest(server string, params *CreateResourceGroupParams, body CreateResourceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateResourceGroupRequestWithBody generates requests for CreateResourceGroup with any type of body
func NewCreateResourceGroupRequestWithBody(server string, params *CreateResourceGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resource_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceGroupRequest generates requests for DeleteResourceGroup
func NewDeleteResourceGroupRequest(server string, resourceGroupId string, params *DeleteResourceGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resource_group_id", runtime.ParamLocationPath, resourceGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resource_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceGroupRequest generates requests for GetResourceGroup
func NewGetResourceGroupRequest(server string, resourceGroupId string, params *GetResourceGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resource_group_id", runtime.ParamLocationPath, resourceGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resource_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourceGroupRequest calls the generic UpdateResourceGroup builder with application/json body
func NewUpdateResourceGroupRequest(server string, resourceGroupId string, params *UpdateResourceGroupParams, body UpdateResourceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceGroupRequestWithBody(server, resourceGroupId, params, "application/json", bodyReader)
}

// NewUpdateResourceGroupRequestWithBody generates requests for UpdateResourceGroup with any type of body
func NewUpdateResourceGroupRequestWithBody(server string, resourceGroupId string, params *UpdateResourceGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resource_group_id", runtime.ParamLocationPath, resourceGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resource_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateResourceRequest calls the generic CreateResource builder with application/json body
func NewCreateResourceRequest(server string, params *CreateResourceParams, body CreateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateResourceRequestWithBody generates requests for CreateResource with any type of body
func NewCreateResourceRequestWithBody(server string, params *CreateResourceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceRequest generates requests for DeleteResource
func NewDeleteResourceRequest(server string, resourceId string, params *DeleteResourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resource_id", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, resourceId string, params *GetResourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resource_id", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourceRequest calls the generic UpdateResource builder with application/json body
func NewUpdateResourceRequest(server string, resourceId string, params *UpdateResourceParams, body UpdateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceRequestWithBody(server, resourceId, params, "application/json", bodyReader)
}

// NewUpdateResourceRequestWithBody generates requests for UpdateResource with any type of body
func NewUpdateResourceRequestWithBody(server string, resourceId string, params *UpdateResourceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resource_id", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRuleSetTemplateRequest calls the generic CreateRuleSetTemplate builder with application/json body
func NewCreateRuleSetTemplateRequest(server string, params *CreateRuleSetTemplateParams, body CreateRuleSetTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleSetTemplateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRuleSetTemplateRequestWithBody generates requests for CreateRuleSetTemplate with any type of body
func NewCreateRuleSetTemplateRequestWithBody(server string, params *CreateRuleSetTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_set_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuleSetTemplateRequest generates requests for DeleteRuleSetTemplate
func NewDeleteRuleSetTemplateRequest(server string, ruleSetTemplateId string, params *DeleteRuleSetTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_set_template_id", runtime.ParamLocationPath, ruleSetTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_set_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleSetTemplateRequest generates requests for GetRuleSetTemplate
func NewGetRuleSetTemplateRequest(server string, ruleSetTemplateId string, params *GetRuleSetTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_set_template_id", runtime.ParamLocationPath, ruleSetTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_set_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleSetTemplateRequest calls the generic UpdateRuleSetTemplate builder with application/json body
func NewUpdateRuleSetTemplateRequest(server string, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, body UpdateRuleSetTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleSetTemplateRequestWithBody(server, ruleSetTemplateId, params, "application/json", bodyReader)
}

// NewUpdateRuleSetTemplateRequestWithBody generates requests for UpdateRuleSetTemplate with any type of body
func NewUpdateRuleSetTemplateRequestWithBody(server string, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_set_template_id", runtime.ParamLocationPath, ruleSetTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_set_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRuleSetRequest calls the generic CreateRuleSet builder with application/json body
func NewCreateRuleSetRequest(server string, params *CreateRuleSetParams, body CreateRuleSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleSetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRuleSetRequestWithBody generates requests for CreateRuleSet with any type of body
func NewCreateRuleSetRequestWithBody(server string, params *CreateRuleSetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_sets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuleSetRequest generates requests for DeleteRuleSet
func NewDeleteRuleSetRequest(server string, ruleSetId string, params *DeleteRuleSetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_set_id", runtime.ParamLocationPath, ruleSetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleSetRequest generates requests for GetRuleSet
func NewGetRuleSetRequest(server string, ruleSetId string, params *GetRuleSetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_set_id", runtime.ParamLocationPath, ruleSetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleSetRequest calls the generic UpdateRuleSet builder with application/json body
func NewUpdateRuleSetRequest(server string, ruleSetId string, params *UpdateRuleSetParams, body UpdateRuleSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleSetRequestWithBody(server, ruleSetId, params, "application/json", bodyReader)
}

// NewUpdateRuleSetRequestWithBody generates requests for UpdateRuleSet with any type of body
func NewUpdateRuleSetRequestWithBody(server string, ruleSetId string, params *UpdateRuleSetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_set_id", runtime.ParamLocationPath, ruleSetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/rule_sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSaleRequest calls the generic CreateSale builder with application/json body
func NewCreateSaleRequest(server string, params *CreateSaleParams, body CreateSaleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSaleRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSaleRequestWithBody generates requests for CreateSale with any type of body
func NewCreateSaleRequestWithBody(server string, params *CreateSaleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSaleRequest generates requests for DeleteSale
func NewDeleteSaleRequest(server string, saleId string, params *DeleteSaleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sale_id", runtime.ParamLocationPath, saleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSaleRequest generates requests for GetSale
func NewGetSaleRequest(server string, saleId string, params *GetSaleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sale_id", runtime.ParamLocationPath, saleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSaleRequest calls the generic UpdateSale builder with application/json body
func NewUpdateSaleRequest(server string, saleId string, params *UpdateSaleParams, body UpdateSaleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSaleRequestWithBody(server, saleId, params, "application/json", bodyReader)
}

// NewUpdateSaleRequestWithBody generates requests for UpdateSale with any type of body
func NewUpdateSaleRequestWithBody(server string, saleId string, params *UpdateSaleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sale_id", runtime.ParamLocationPath, saleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefundMarketplaceSaleRequest generates requests for RefundMarketplaceSale
func NewRefundMarketplaceSaleRequest(server string, saleId string, params *RefundMarketplaceSaleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sale_id", runtime.ParamLocationPath, saleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales/%s/refund", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendTransactionReceiptRequest calls the generic SendTransactionReceipt builder with application/json body
func NewSendTransactionReceiptRequest(server string, saleId string, transactionId string, body SendTransactionReceiptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendTransactionReceiptRequestWithBody(server, saleId, transactionId, "application/json", bodyReader)
}

// NewSendTransactionReceiptRequestWithBody generates requests for SendTransactionReceipt with any type of body
func NewSendTransactionReceiptRequestWithBody(server string, saleId string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sale_id", runtime.ParamLocationPath, saleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales/%s/transactions/%s/send_receipt", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeprecatedListSubtransactionsRequest generates requests for DeprecatedListSubtransactions
func NewDeprecatedListSubtransactionsRequest(server string, saleId string, transactionId string, params *DeprecatedListSubtransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sale_id", runtime.ParamLocationPath, saleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales/%s/transactions/%s/subtransactions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeprecatedGetSubtransactionRequest generates requests for DeprecatedGetSubtransaction
func NewDeprecatedGetSubtransactionRequest(server string, saleId string, transactionId string, id string, params *DeprecatedGetSubtransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sale_id", runtime.ParamLocationPath, saleId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/sales/%s/transactions/%s/subtransactions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpaceRequest calls the generic CreateSpace builder with application/json body
func NewCreateSpaceRequest(server string, params *CreateSpaceParams, body CreateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpaceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSpaceRequestWithBody generates requests for CreateSpace with any type of body
func NewCreateSpaceRequestWithBody(server string, params *CreateSpaceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/spaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpaceRequest generates requests for DeleteSpace
func NewDeleteSpaceRequest(server string, spaceId string, params *DeleteSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/spaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceRequest generates requests for GetSpace
func NewGetSpaceRequest(server string, spaceId string, params *GetSpaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/spaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSpaceRequest calls the generic UpdateSpace builder with application/json body
func NewUpdateSpaceRequest(server string, spaceId string, params *UpdateSpaceParams, body UpdateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpaceRequestWithBody(server, spaceId, params, "application/json", bodyReader)
}

// NewUpdateSpaceRequestWithBody generates requests for UpdateSpace with any type of body
func NewUpdateSpaceRequestWithBody(server string, spaceId string, params *UpdateSpaceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/spaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamBlockedTimesRequest generates requests for StreamBlockedTimes
func NewStreamBlockedTimesRequest(server string, companyId string, params *StreamBlockedTimesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/blocked_times", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamEmployeesRequest generates requests for StreamEmployees
func NewStreamEmployeesRequest(server string, companyId string, params *StreamEmployeesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/employees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamEventTypeGroupsRequest generates requests for StreamEventTypeGroups
func NewStreamEventTypeGroupsRequest(server string, companyId string, params *StreamEventTypeGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/event_type_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamEventTypesRequest generates requests for StreamEventTypes
func NewStreamEventTypesRequest(server string, companyId string, params *StreamEventTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/event_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamEventsRequest generates requests for StreamEvents
func NewStreamEventsRequest(server string, companyId string, params *StreamEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamSalesMetricsRequest generates requests for StreamSalesMetrics
func NewStreamSalesMetricsRequest(server string, companyId string, params *StreamSalesMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/metrics/sales", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamNotificationsRequest generates requests for StreamNotifications
func NewStreamNotificationsRequest(server string, companyId string, params *StreamNotificationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/notifications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamProductGroupsRequest generates requests for StreamProductGroups
func NewStreamProductGroupsRequest(server string, companyId string, params *StreamProductGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/product_groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamProductsRequest generates requests for StreamProducts
func NewStreamProductsRequest(server string, companyId string, params *StreamProductsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamResourcesRequest generates requests for StreamResources
func NewStreamResourcesRequest(server string, companyId string, params *StreamResourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/resource", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamSpacesRequest generates requests for StreamSpaces
func NewStreamSpacesRequest(server string, companyId string, params *StreamSpacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/spaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamTimeSlotReservationsRequest generates requests for StreamTimeSlotReservations
func NewStreamTimeSlotReservationsRequest(server string, companyId string, params *StreamTimeSlotReservationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "company_id", runtime.ParamLocationPath, companyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/stream/companies/%s/time_slot_reservations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryParamBuf, err := json.Marshal(*params.Filter); err != nil {
			return nil, err
		} else {
			queryValues.Add("filter", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingInvoiceRequest generates requests for GetBillingInvoice
func NewGetBillingInvoiceRequest(server string, invoiceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoice_id", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/subscriptions/invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, subscriptionId string, params *DeleteSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscription_id", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionRequest generates requests for GetSubscription
func NewGetSubscriptionRequest(server string, subscriptionId string, params *GetSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscription_id", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubtransactionRequest calls the generic CreateSubtransaction builder with application/json body
func NewCreateSubtransactionRequest(server string, params *CreateSubtransactionParams, body CreateSubtransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubtransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSubtransactionRequestWithBody generates requests for CreateSubtransaction with any type of body
func NewCreateSubtransactionRequestWithBody(server string, params *CreateSubtransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/subtransactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubtransactionRequest generates requests for DeleteSubtransaction
func NewDeleteSubtransactionRequest(server string, subtransactionId string, params *DeleteSubtransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subtransaction_id", runtime.ParamLocationPath, subtransactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/subtransactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubtransactionRequest generates requests for GetSubtransaction
func NewGetSubtransactionRequest(server string, subtransactionId string, params *GetSubtransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subtransaction_id", runtime.ParamLocationPath, subtransactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/subtransactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTerminalRequest generates requests for DeleteTerminal
func NewDeleteTerminalRequest(server string, terminalId string, params *DeleteTerminalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "terminal_id", runtime.ParamLocationPath, terminalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/terminals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTerminalRequest generates requests for GetTerminal
func NewGetTerminalRequest(server string, terminalId string, params *GetTerminalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "terminal_id", runtime.ParamLocationPath, terminalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/terminals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTerminalRequest calls the generic UpdateTerminal builder with application/json body
func NewUpdateTerminalRequest(server string, terminalId string, params *UpdateTerminalParams, body UpdateTerminalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTerminalRequestWithBody(server, terminalId, params, "application/json", bodyReader)
}

// NewUpdateTerminalRequestWithBody generates requests for UpdateTerminal with any type of body
func NewUpdateTerminalRequestWithBody(server string, terminalId string, params *UpdateTerminalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "terminal_id", runtime.ParamLocationPath, terminalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/terminals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOAuthConsentRequest generates requests for GetOAuthConsent
func NewGetOAuthConsentRequest(server string, params *GetOAuthConsentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/testing/consent")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, params.Scope); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOAuthLoginRequest generates requests for GetOAuthLogin
func NewGetOAuthLoginRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/testing/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOAuthLoginRequest calls the generic PostOAuthLogin builder with application/json body
func NewPostOAuthLoginRequest(server string, body PostOAuthLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOAuthLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewPostOAuthLoginRequestWithBody generates requests for PostOAuthLogin with any type of body
func NewPostOAuthLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/testing/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTimeSlotReservationRequest generates requests for GetTimeSlotReservation
func NewGetTimeSlotReservationRequest(server string, timeSlotReservationId string, params *GetTimeSlotReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "time_slot_reservation_id", runtime.ParamLocationPath, timeSlotReservationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/time_slot_reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest generates requests for CreateToken
func NewCreateTokenRequest(server string, params *CreateTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTransactionRequest calls the generic CreateTransaction builder with application/json body
func NewCreateTransactionRequest(server string, params *CreateTransactionParams, body CreateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTransactionRequestWithBody generates requests for CreateTransaction with any type of body
func NewCreateTransactionRequestWithBody(server string, params *CreateTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Behavior != nil {

		if queryParamBuf, err := json.Marshal(*params.Behavior); err != nil {
			return nil, err
		} else {
			queryValues.Add("behavior", string(queryParamBuf))
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTransactionRequest generates requests for DeleteTransaction
func NewDeleteTransactionRequest(server string, transactionId string, params *DeleteTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, transactionId string, params *GetTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTransactionRequest calls the generic UpdateTransaction builder with application/json body
func NewUpdateTransactionRequest(server string, transactionId string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTransactionRequestWithBody(server, transactionId, params, "application/json", bodyReader)
}

// NewUpdateTransactionRequestWithBody generates requests for UpdateTransaction with any type of body
func NewUpdateTransactionRequestWithBody(server string, transactionId string, params *UpdateTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListLineItemsRequest generates requests for ListLineItems
func NewListLineItemsRequest(server string, transactionId string, params *ListLineItemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/transactions/%s/line_items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSubtransactionsRequest generates requests for ListSubtransactions
func NewListSubtransactionsRequest(server string, transactionId string, params *ListSubtransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/transactions/%s/subtransactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, params *GetUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGoogleCalendarConnectionRequest generates requests for DeleteGoogleCalendarConnection
func NewDeleteGoogleCalendarConnectionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/google_calendar_connection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGoogleCalendarConnectionRequest generates requests for GetGoogleCalendarConnection
func NewGetGoogleCalendarConnectionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/google_calendar_connection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGoogleCalendarConnectionRequest calls the generic CreateGoogleCalendarConnection builder with application/json body
func NewCreateGoogleCalendarConnectionRequest(server string, body CreateGoogleCalendarConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGoogleCalendarConnectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGoogleCalendarConnectionRequestWithBody generates requests for CreateGoogleCalendarConnection with any type of body
func NewCreateGoogleCalendarConnectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/google_calendar_connection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserOAuthRequest generates requests for UserOAuth
func NewUserOAuthRequest(server string, params *UserOAuthParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/oauth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, params.Provider); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.RedirectUri != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, *params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserSettlementAccountsRequest generates requests for ListUserSettlementAccounts
func NewListUserSettlementAccountsRequest(server string, params *ListUserSettlementAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/settlement_accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserTerminalsRequest generates requests for ListUserTerminals
func NewListUserTerminalsRequest(server string, params *ListUserTerminalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/terminals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserTerminalRequest generates requests for DeleteUserTerminal
func NewDeleteUserTerminalRequest(server string, terminalId string, params *DeleteUserTerminalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "terminal_id", runtime.ParamLocationPath, terminalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/terminals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserTerminalRequest generates requests for GetUserTerminal
func NewGetUserTerminalRequest(server string, terminalId string, params *GetUserTerminalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "terminal_id", runtime.ParamLocationPath, terminalId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/terminals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserTokensRequest generates requests for ListUserTokens
func NewListUserTokensRequest(server string, params *ListUserTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserTokenRequest calls the generic CreateUserToken builder with application/json body
func NewCreateUserTokenRequest(server string, params *CreateUserTokenParams, body CreateUserTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserTokenRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserTokenRequestWithBody generates requests for CreateUserToken with any type of body
func NewCreateUserTokenRequestWithBody(server string, params *CreateUserTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserTokenRequest generates requests for DeleteUserToken
func NewDeleteUserTokenRequest(server string, tokenId string, params *DeleteUserTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserTokenRequest generates requests for GetUserToken
func NewGetUserTokenRequest(server string, tokenId string, params *GetUserTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/user/tokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVoucherTemplateRequest calls the generic CreateVoucherTemplate builder with application/json body
func NewCreateVoucherTemplateRequest(server string, params *CreateVoucherTemplateParams, body CreateVoucherTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVoucherTemplateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVoucherTemplateRequestWithBody generates requests for CreateVoucherTemplate with any type of body
func NewCreateVoucherTemplateRequestWithBody(server string, params *CreateVoucherTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/voucher_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVoucherTemplateRequest generates requests for DeleteVoucherTemplate
func NewDeleteVoucherTemplateRequest(server string, voucherTemplateId string, params *DeleteVoucherTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "voucher_template_id", runtime.ParamLocationPath, voucherTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/voucher_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVoucherTemplateRequest calls the generic UpdateVoucherTemplate builder with application/json body
func NewUpdateVoucherTemplateRequest(server string, voucherTemplateId string, params *UpdateVoucherTemplateParams, body UpdateVoucherTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVoucherTemplateRequestWithBody(server, voucherTemplateId, params, "application/json", bodyReader)
}

// NewUpdateVoucherTemplateRequestWithBody generates requests for UpdateVoucherTemplate with any type of body
func NewUpdateVoucherTemplateRequestWithBody(server string, voucherTemplateId string, params *UpdateVoucherTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "voucher_template_id", runtime.ParamLocationPath, voucherTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/voucher_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVoucherRequest generates requests for DeleteVoucher
func NewDeleteVoucherRequest(server string, voucherId string, params *DeleteVoucherParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "voucher_id", runtime.ParamLocationPath, voucherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/vouchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVoucherRequest generates requests for GetVoucher
func NewGetVoucherRequest(server string, voucherId string, params *GetVoucherParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "voucher_id", runtime.ParamLocationPath, voucherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/vouchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVoucherRequest calls the generic UpdateVoucher builder with application/json body
func NewUpdateVoucherRequest(server string, voucherId string, params *UpdateVoucherParams, body UpdateVoucherJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVoucherRequestWithBody(server, voucherId, params, "application/json", bodyReader)
}

// NewUpdateVoucherRequestWithBody generates requests for UpdateVoucher with any type of body
func NewUpdateVoucherRequestWithBody(server string, voucherId string, params *UpdateVoucherParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "voucher_id", runtime.ParamLocationPath, voucherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/vouchers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Unset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unset", runtime.ParamLocationQuery, *params.Unset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateVoucherNotificationRequest calls the generic CreateVoucherNotification builder with application/json body
func NewCreateVoucherNotificationRequest(server string, voucherId string, params *CreateVoucherNotificationParams, body CreateVoucherNotificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVoucherNotificationRequestWithBody(server, voucherId, params, "application/json", bodyReader)
}

// NewCreateVoucherNotificationRequestWithBody generates requests for CreateVoucherNotification with any type of body
func NewCreateVoucherNotificationRequestWithBody(server string, voucherId string, params *CreateVoucherNotificationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "voucher_id", runtime.ParamLocationPath, voucherId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/vouchers/%s/notification", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWaitlistEntryRequest calls the generic CreateWaitlistEntry builder with application/json body
func NewCreateWaitlistEntryRequest(server string, params *CreateWaitlistEntryParams, body CreateWaitlistEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWaitlistEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateWaitlistEntryRequestWithBody generates requests for CreateWaitlistEntry with any type of body
func NewCreateWaitlistEntryRequestWithBody(server string, params *CreateWaitlistEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/waitlist_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWaitlistEntryRequest generates requests for DeleteWaitlistEntry
func NewDeleteWaitlistEntryRequest(server string, waitlistEntryId string, params *DeleteWaitlistEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "waitlist_entry_id", runtime.ParamLocationPath, waitlistEntryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/waitlist_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWaitlistEntryRequest generates requests for GetWaitlistEntry
func NewGetWaitlistEntryRequest(server string, waitlistEntryId string, params *GetWaitlistEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "waitlist_entry_id", runtime.ParamLocationPath, waitlistEntryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/waitlist_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWaitlistEntryRequest calls the generic UpdateWaitlistEntry builder with application/json body
func NewUpdateWaitlistEntryRequest(server string, waitlistEntryId string, params *UpdateWaitlistEntryParams, body UpdateWaitlistEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWaitlistEntryRequestWithBody(server, waitlistEntryId, params, "application/json", bodyReader)
}

// NewUpdateWaitlistEntryRequestWithBody generates requests for UpdateWaitlistEntry with any type of body
func NewUpdateWaitlistEntryRequestWithBody(server string, waitlistEntryId string, params *UpdateWaitlistEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "waitlist_entry_id", runtime.ParamLocationPath, waitlistEntryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/waitlist_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Unset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unset", runtime.ParamLocationQuery, *params.Unset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWebhookInvocationRequest generates requests for GetWebhookInvocation
func NewGetWebhookInvocationRequest(server string, webhookInvocationId string, params *GetWebhookInvocationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook_invocation_id", runtime.ParamLocationPath, webhookInvocationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/webhook_invocations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookInvocationRequest calls the generic UpdateWebhookInvocation builder with application/json body
func NewUpdateWebhookInvocationRequest(server string, webhookInvocationId string, params *UpdateWebhookInvocationParams, body UpdateWebhookInvocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookInvocationRequestWithBody(server, webhookInvocationId, params, "application/json", bodyReader)
}

// NewUpdateWebhookInvocationRequestWithBody generates requests for UpdateWebhookInvocation with any type of body
func NewUpdateWebhookInvocationRequestWithBody(server string, webhookInvocationId string, params *UpdateWebhookInvocationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook_invocation_id", runtime.ParamLocationPath, webhookInvocationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/webhook_invocations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWebhookRequest calls the generic CreateWebhook builder with application/json body
func NewCreateWebhookRequest(server string, params *CreateWebhookParams, body CreateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateWebhookRequestWithBody generates requests for CreateWebhook with any type of body
func NewCreateWebhookRequestWithBody(server string, params *CreateWebhookParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWebhookEventsRequest generates requests for ListWebhookEvents
func NewListWebhookEventsRequest(server string, params *ListWebhookEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/webhooks/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, webhookId string, params *DeleteWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook_id", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, webhookId string, params *GetWebhookParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook_id", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookRequest calls the generic UpdateWebhook builder with application/json body
func NewUpdateWebhookRequest(server string, webhookId string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookRequestWithBody(server, webhookId, params, "application/json", bodyReader)
}

// NewUpdateWebhookRequestWithBody generates requests for UpdateWebhook with any type of body
func NewUpdateWebhookRequestWithBody(server string, webhookId string, params *UpdateWebhookParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhook_id", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hq/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Select != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "select", runtime.ParamLocationQuery, *params.Select); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Expand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListCustomerActivities request
	ListCustomerActivitiesWithResponse(ctx context.Context, customerId string, params *ListCustomerActivitiesParams, reqEditors ...RequestEditorFn) (*ListCustomerActivitiesResponse, error)

	// ListEventTypeActivities request
	ListEventTypeActivitiesWithResponse(ctx context.Context, eventTypeId string, params *ListEventTypeActivitiesParams, reqEditors ...RequestEditorFn) (*ListEventTypeActivitiesResponse, error)

	// ListEventActivities request
	ListEventActivitiesWithResponse(ctx context.Context, eventId string, params *ListEventActivitiesParams, reqEditors ...RequestEditorFn) (*ListEventActivitiesResponse, error)

	// ListPaymentActivities request
	ListPaymentActivitiesWithResponse(ctx context.Context, paymentId string, params *ListPaymentActivitiesParams, reqEditors ...RequestEditorFn) (*ListPaymentActivitiesResponse, error)

	// CreateBlockedTime request with any body
	CreateBlockedTimeWithBodyWithResponse(ctx context.Context, params *CreateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlockedTimeResponse, error)

	CreateBlockedTimeWithResponse(ctx context.Context, params *CreateBlockedTimeParams, body CreateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlockedTimeResponse, error)

	// DeleteBlockedTime request
	DeleteBlockedTimeWithResponse(ctx context.Context, blockedTimeId string, params *DeleteBlockedTimeParams, reqEditors ...RequestEditorFn) (*DeleteBlockedTimeResponse, error)

	// GetBlockedTime request
	GetBlockedTimeWithResponse(ctx context.Context, blockedTimeId string, params *GetBlockedTimeParams, reqEditors ...RequestEditorFn) (*GetBlockedTimeResponse, error)

	// UpdateBlockedTime request with any body
	UpdateBlockedTimeWithBodyWithResponse(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBlockedTimeResponse, error)

	UpdateBlockedTimeWithResponse(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, body UpdateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBlockedTimeResponse, error)

	// GetCompanies request
	GetCompaniesWithResponse(ctx context.Context, params *GetCompaniesParams, reqEditors ...RequestEditorFn) (*GetCompaniesResponse, error)

	// CreateCompany request with any body
	CreateCompanyWithBodyWithResponse(ctx context.Context, params *CreateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCompanyResponse, error)

	CreateCompanyWithResponse(ctx context.Context, params *CreateCompanyParams, body CreateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCompanyResponse, error)

	// GetCompany request
	GetCompanyWithResponse(ctx context.Context, companyId string, params *GetCompanyParams, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error)

	// UpdateCompany request with any body
	UpdateCompanyWithBodyWithResponse(ctx context.Context, companyId string, params *UpdateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCompanyResponse, error)

	UpdateCompanyWithResponse(ctx context.Context, companyId string, params *UpdateCompanyParams, body UpdateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCompanyResponse, error)

	// ListAllCompanyActivities request
	ListAllCompanyActivitiesWithResponse(ctx context.Context, companyId string, params *ListAllCompanyActivitiesParams, reqEditors ...RequestEditorFn) (*ListAllCompanyActivitiesResponse, error)

	// ListApps request
	ListAppsWithResponse(ctx context.Context, companyId string, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// GetApp request
	GetAppWithResponse(ctx context.Context, companyId string, appId string, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// DisableApp request
	DisableAppWithResponse(ctx context.Context, companyId string, appId string, reqEditors ...RequestEditorFn) (*DisableAppResponse, error)

	// ListBlockedTimes request
	ListBlockedTimesWithResponse(ctx context.Context, companyId string, params *ListBlockedTimesParams, reqEditors ...RequestEditorFn) (*ListBlockedTimesResponse, error)

	// ListClaims request
	ListClaimsWithResponse(ctx context.Context, companyId string, params *ListClaimsParams, reqEditors ...RequestEditorFn) (*ListClaimsResponse, error)

	// ListCustomerGroups request
	ListCustomerGroupsWithResponse(ctx context.Context, companyId string, params *ListCustomerGroupsParams, reqEditors ...RequestEditorFn) (*ListCustomerGroupsResponse, error)

	// ListCustomers request
	ListCustomersWithResponse(ctx context.Context, companyId string, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error)

	// ListEmployees request
	ListEmployeesWithResponse(ctx context.Context, companyId string, params *ListEmployeesParams, reqEditors ...RequestEditorFn) (*ListEmployeesResponse, error)

	// DeleteEmployee request
	DeleteEmployeeWithResponse(ctx context.Context, companyId string, employeeId string, params *DeleteEmployeeParams, reqEditors ...RequestEditorFn) (*DeleteEmployeeResponse, error)

	// GetEmployee request
	GetEmployeeWithResponse(ctx context.Context, companyId string, employeeId string, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*GetEmployeeResponse, error)

	// UpdateEmployee request with any body
	UpdateEmployeeWithBodyWithResponse(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error)

	UpdateEmployeeWithResponse(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error)

	// ListEventStatuses request
	ListEventStatusesWithResponse(ctx context.Context, companyId string, params *ListEventStatusesParams, reqEditors ...RequestEditorFn) (*ListEventStatusesResponse, error)

	// ListEventTypeCategories request
	ListEventTypeCategoriesWithResponse(ctx context.Context, companyId string, params *ListEventTypeCategoriesParams, reqEditors ...RequestEditorFn) (*ListEventTypeCategoriesResponse, error)

	// ListEventTypeCategoryGroups request
	ListEventTypeCategoryGroupsWithResponse(ctx context.Context, companyId string, params *ListEventTypeCategoryGroupsParams, reqEditors ...RequestEditorFn) (*ListEventTypeCategoryGroupsResponse, error)

	// ListEventTypeGroups request
	ListEventTypeGroupsWithResponse(ctx context.Context, companyId string, params *ListEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*ListEventTypeGroupsResponse, error)

	// ListEventTypes request
	ListEventTypesWithResponse(ctx context.Context, companyId string, params *ListEventTypesParams, reqEditors ...RequestEditorFn) (*ListEventTypesResponse, error)

	// ListEvents request
	ListEventsWithResponse(ctx context.Context, companyId string, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error)

	// CheckinWithPayment request
	CheckinWithPaymentWithResponse(ctx context.Context, companyId string, id string, params *CheckinWithPaymentParams, reqEditors ...RequestEditorFn) (*CheckinWithPaymentResponse, error)

	// ListHolidays request
	ListHolidaysWithResponse(ctx context.Context, companyId string, params *ListHolidaysParams, reqEditors ...RequestEditorFn) (*ListHolidaysResponse, error)

	// ListIssuers request
	ListIssuersWithResponse(ctx context.Context, companyId string, params *ListIssuersParams, reqEditors ...RequestEditorFn) (*ListIssuersResponse, error)

	// ListMemos request
	ListMemosWithResponse(ctx context.Context, companyId string, params *ListMemosParams, reqEditors ...RequestEditorFn) (*ListMemosResponse, error)

	// GetSalesMetrics request
	GetSalesMetricsWithResponse(ctx context.Context, companyId string, params *GetSalesMetricsParams, reqEditors ...RequestEditorFn) (*GetSalesMetricsResponse, error)

	// DeleteNotifications request
	DeleteNotificationsWithResponse(ctx context.Context, companyId string, params *DeleteNotificationsParams, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error)

	// ListNotifications request
	ListNotificationsWithResponse(ctx context.Context, companyId string, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*ListNotificationsResponse, error)

	// ListOpeningHours request
	ListOpeningHoursWithResponse(ctx context.Context, companyId string, params *ListOpeningHoursParams, reqEditors ...RequestEditorFn) (*ListOpeningHoursResponse, error)

	// ListPayments request
	ListPaymentsWithResponse(ctx context.Context, companyId string, params *ListPaymentsParams, reqEditors ...RequestEditorFn) (*ListPaymentsResponse, error)

	// ListCustomProperties request
	ListCustomPropertiesWithResponse(ctx context.Context, companyId string, params *ListCustomPropertiesParams, reqEditors ...RequestEditorFn) (*ListCustomPropertiesResponse, error)

	// ListResourceGroups request
	ListResourceGroupsWithResponse(ctx context.Context, companyId string, params *ListResourceGroupsParams, reqEditors ...RequestEditorFn) (*ListResourceGroupsResponse, error)

	// ListResources request
	ListResourcesWithResponse(ctx context.Context, companyId string, params *ListResourcesParams, reqEditors ...RequestEditorFn) (*ListResourcesResponse, error)

	// ListRuleSetTemplates request
	ListRuleSetTemplatesWithResponse(ctx context.Context, companyId string, params *ListRuleSetTemplatesParams, reqEditors ...RequestEditorFn) (*ListRuleSetTemplatesResponse, error)

	// ListRuleSets request
	ListRuleSetsWithResponse(ctx context.Context, companyId string, params *ListRuleSetsParams, reqEditors ...RequestEditorFn) (*ListRuleSetsResponse, error)

	// ListSales request
	ListSalesWithResponse(ctx context.Context, companyId string, params *ListSalesParams, reqEditors ...RequestEditorFn) (*ListSalesResponse, error)

	// ListSettlements request
	ListSettlementsWithResponse(ctx context.Context, companyId string, params *ListSettlementsParams, reqEditors ...RequestEditorFn) (*ListSettlementsResponse, error)

	// ListSMSMessages request
	ListSMSMessagesWithResponse(ctx context.Context, companyId string, params *ListSMSMessagesParams, reqEditors ...RequestEditorFn) (*ListSMSMessagesResponse, error)

	// ListSpaces request
	ListSpacesWithResponse(ctx context.Context, companyId string, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error)

	// CreateSubscription request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, companyId string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	CreateSubscriptionWithResponse(ctx context.Context, companyId string, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// GetSubscriptionBillingInfo request
	GetSubscriptionBillingInfoWithResponse(ctx context.Context, companyId string, params *GetSubscriptionBillingInfoParams, reqEditors ...RequestEditorFn) (*GetSubscriptionBillingInfoResponse, error)

	// UpdateBillingInfo request with any body
	UpdateBillingInfoWithBodyWithResponse(ctx context.Context, companyId string, params *UpdateBillingInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingInfoResponse, error)

	UpdateBillingInfoWithResponse(ctx context.Context, companyId string, params *UpdateBillingInfoParams, body UpdateBillingInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingInfoResponse, error)

	// ListBillingInvoices request
	ListBillingInvoicesWithResponse(ctx context.Context, companyId string, params *ListBillingInvoicesParams, reqEditors ...RequestEditorFn) (*ListBillingInvoicesResponse, error)

	// CreatePaymentIntent request
	CreatePaymentIntentWithResponse(ctx context.Context, companyId string, params *CreatePaymentIntentParams, reqEditors ...RequestEditorFn) (*CreatePaymentIntentResponse, error)

	// ListTerminals request
	ListTerminalsWithResponse(ctx context.Context, companyId string, params *ListTerminalsParams, reqEditors ...RequestEditorFn) (*ListTerminalsResponse, error)

	// ListTimeSlotReservations request
	ListTimeSlotReservationsWithResponse(ctx context.Context, companyId string, params *ListTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*ListTimeSlotReservationsResponse, error)

	// ListTimeSlots request
	ListTimeSlotsWithResponse(ctx context.Context, companyId string, params *ListTimeSlotsParams, reqEditors ...RequestEditorFn) (*ListTimeSlotsResponse, error)

	// ListTransactions request
	ListTransactionsWithResponse(ctx context.Context, companyId string, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error)

	// ListVATs request
	ListVATsWithResponse(ctx context.Context, companyId string, params *ListVATsParams, reqEditors ...RequestEditorFn) (*ListVATsResponse, error)

	// ListVoucherTemplates request
	ListVoucherTemplatesWithResponse(ctx context.Context, companyId string, params *ListVoucherTemplatesParams, reqEditors ...RequestEditorFn) (*ListVoucherTemplatesResponse, error)

	// ListVouchers request
	ListVouchersWithResponse(ctx context.Context, companyId string, params *ListVouchersParams, reqEditors ...RequestEditorFn) (*ListVouchersResponse, error)

	// ListWaitlistEntries request
	ListWaitlistEntriesWithResponse(ctx context.Context, companyId string, params *ListWaitlistEntriesParams, reqEditors ...RequestEditorFn) (*ListWaitlistEntriesResponse, error)

	// ListWebhookInvocations request
	ListWebhookInvocationsWithResponse(ctx context.Context, companyId string, params *ListWebhookInvocationsParams, reqEditors ...RequestEditorFn) (*ListWebhookInvocationsResponse, error)

	// ListWebhooks request
	ListWebhooksWithResponse(ctx context.Context, companyId string, params *ListWebhooksParams, reqEditors ...RequestEditorFn) (*ListWebhooksResponse, error)

	// CreateCustomerGroup request with any body
	CreateCustomerGroupWithBodyWithResponse(ctx context.Context, params *CreateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerGroupResponse, error)

	CreateCustomerGroupWithResponse(ctx context.Context, params *CreateCustomerGroupParams, body CreateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerGroupResponse, error)

	// DeleteCustomerGroup request
	DeleteCustomerGroupWithResponse(ctx context.Context, customerGroupId string, params *DeleteCustomerGroupParams, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupResponse, error)

	// GetCustomerGroup request
	GetCustomerGroupWithResponse(ctx context.Context, customerGroupId string, params *GetCustomerGroupParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupResponse, error)

	// UpdateCustomerGroup request with any body
	UpdateCustomerGroupWithBodyWithResponse(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerGroupResponse, error)

	UpdateCustomerGroupWithResponse(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, body UpdateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerGroupResponse, error)

	// CreateCustomer request with any body
	CreateCustomerWithBodyWithResponse(ctx context.Context, params *CreateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	CreateCustomerWithResponse(ctx context.Context, params *CreateCustomerParams, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	// DeleteCustomer request
	DeleteCustomerWithResponse(ctx context.Context, customerId string, params *DeleteCustomerParams, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error)

	// GetCustomer request
	GetCustomerWithResponse(ctx context.Context, customerId string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

	// UpdateCustomer request with any body
	UpdateCustomerWithBodyWithResponse(ctx context.Context, customerId string, params *UpdateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	UpdateCustomerWithResponse(ctx context.Context, customerId string, params *UpdateCustomerParams, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	// CreateEmployee request with any body
	CreateEmployeeWithBodyWithResponse(ctx context.Context, params *CreateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmployeeResponse, error)

	CreateEmployeeWithResponse(ctx context.Context, params *CreateEmployeeParams, body CreateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmployeeResponse, error)

	// GetEnterprise request
	GetEnterpriseWithResponse(ctx context.Context, params *GetEnterpriseParams, reqEditors ...RequestEditorFn) (*GetEnterpriseResponse, error)

	// UpdateEnterprise request with any body
	UpdateEnterpriseWithBodyWithResponse(ctx context.Context, params *UpdateEnterpriseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnterpriseResponse, error)

	UpdateEnterpriseWithResponse(ctx context.Context, params *UpdateEnterpriseParams, body UpdateEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnterpriseResponse, error)

	// ListEnterpriseCompanies request
	ListEnterpriseCompaniesWithResponse(ctx context.Context, enterpriseId string, params *ListEnterpriseCompaniesParams, reqEditors ...RequestEditorFn) (*ListEnterpriseCompaniesResponse, error)

	// ListPaymentsLegacy request
	ListPaymentsLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListPaymentsLegacyParams, reqEditors ...RequestEditorFn) (*ListPaymentsLegacyResponse, error)

	// ListEnterpriseSettlementAccounts request
	ListEnterpriseSettlementAccountsWithResponse(ctx context.Context, enterpriseId string, params *ListEnterpriseSettlementAccountsParams, reqEditors ...RequestEditorFn) (*ListEnterpriseSettlementAccountsResponse, error)

	// DeleteEnterpriseSettlementAccount request
	DeleteEnterpriseSettlementAccountWithResponse(ctx context.Context, enterpriseId string, settlementAccountId string, params *DeleteEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*DeleteEnterpriseSettlementAccountResponse, error)

	// GetEnterpriseSettlementAccount request
	GetEnterpriseSettlementAccountWithResponse(ctx context.Context, enterpriseId string, settlementAccountId string, params *GetEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*GetEnterpriseSettlementAccountResponse, error)

	// ListSettlementsLegacy request
	ListSettlementsLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListSettlementsLegacyParams, reqEditors ...RequestEditorFn) (*ListSettlementsLegacyResponse, error)

	// ListVoucherTemplatesLegacy request
	ListVoucherTemplatesLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListVoucherTemplatesLegacyParams, reqEditors ...RequestEditorFn) (*ListVoucherTemplatesLegacyResponse, error)

	// CreateVoucherTemplateLegacy request with any body
	CreateVoucherTemplateLegacyWithBodyWithResponse(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateLegacyResponse, error)

	CreateVoucherTemplateLegacyWithResponse(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, body CreateVoucherTemplateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateLegacyResponse, error)

	// ListVouchersLegacy request
	ListVouchersLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListVouchersLegacyParams, reqEditors ...RequestEditorFn) (*ListVouchersLegacyResponse, error)

	// GetVoucherLegacy request
	GetVoucherLegacyWithResponse(ctx context.Context, enterpriseId string, voucherId string, params *GetVoucherLegacyParams, reqEditors ...RequestEditorFn) (*GetVoucherLegacyResponse, error)

	// UpdateVoucherLegacy request with any body
	UpdateVoucherLegacyWithBodyWithResponse(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVoucherLegacyResponse, error)

	UpdateVoucherLegacyWithResponse(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, body UpdateVoucherLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVoucherLegacyResponse, error)

	// CreateEventStatus request with any body
	CreateEventStatusWithBodyWithResponse(ctx context.Context, params *CreateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventStatusResponse, error)

	CreateEventStatusWithResponse(ctx context.Context, params *CreateEventStatusParams, body CreateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventStatusResponse, error)

	// DeleteEventStatus request
	DeleteEventStatusWithResponse(ctx context.Context, eventStatusId string, params *DeleteEventStatusParams, reqEditors ...RequestEditorFn) (*DeleteEventStatusResponse, error)

	// GetEventStatus request
	GetEventStatusWithResponse(ctx context.Context, eventStatusId string, params *GetEventStatusParams, reqEditors ...RequestEditorFn) (*GetEventStatusResponse, error)

	// UpdateEventStatus request with any body
	UpdateEventStatusWithBodyWithResponse(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventStatusResponse, error)

	UpdateEventStatusWithResponse(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, body UpdateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventStatusResponse, error)

	// GetEventTypeGroup request
	GetEventTypeGroupWithResponse(ctx context.Context, eventTypeGroupId string, params *GetEventTypeGroupParams, reqEditors ...RequestEditorFn) (*GetEventTypeGroupResponse, error)

	// CreateEventType request with any body
	CreateEventTypeWithBodyWithResponse(ctx context.Context, params *CreateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventTypeResponse, error)

	CreateEventTypeWithResponse(ctx context.Context, params *CreateEventTypeParams, body CreateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventTypeResponse, error)

	// DeleteEventType request
	DeleteEventTypeWithResponse(ctx context.Context, eventTypeId string, params *DeleteEventTypeParams, reqEditors ...RequestEditorFn) (*DeleteEventTypeResponse, error)

	// GetEventType request
	GetEventTypeWithResponse(ctx context.Context, eventTypeId string, params *GetEventTypeParams, reqEditors ...RequestEditorFn) (*GetEventTypeResponse, error)

	// UpdateEventType request with any body
	UpdateEventTypeWithBodyWithResponse(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventTypeResponse, error)

	UpdateEventTypeWithResponse(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, body UpdateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventTypeResponse, error)

	// CreateEvent request with any body
	CreateEventWithBodyWithResponse(ctx context.Context, params *CreateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventResponse, error)

	CreateEventWithResponse(ctx context.Context, params *CreateEventParams, body CreateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventResponse, error)

	// DeleteEvent request
	DeleteEventWithResponse(ctx context.Context, eventId string, params *DeleteEventParams, reqEditors ...RequestEditorFn) (*DeleteEventResponse, error)

	// GetEvent request
	GetEventWithResponse(ctx context.Context, eventId string, params *GetEventParams, reqEditors ...RequestEditorFn) (*GetEventResponse, error)

	// UpdateEvent request with any body
	UpdateEventWithBodyWithResponse(ctx context.Context, eventId string, params *UpdateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error)

	UpdateEventWithResponse(ctx context.Context, eventId string, params *UpdateEventParams, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error)

	// CreateCheckoutForEvent request
	CreateCheckoutForEventWithResponse(ctx context.Context, eventId string, params *CreateCheckoutForEventParams, reqEditors ...RequestEditorFn) (*CreateCheckoutForEventResponse, error)

	// DeleteCompanyFiscalizationData request
	DeleteCompanyFiscalizationDataWithResponse(ctx context.Context, companyId string, reqEditors ...RequestEditorFn) (*DeleteCompanyFiscalizationDataResponse, error)

	// GetCompanyFiscalizationData request
	GetCompanyFiscalizationDataWithResponse(ctx context.Context, companyId string, params *GetCompanyFiscalizationDataParams, reqEditors ...RequestEditorFn) (*GetCompanyFiscalizationDataResponse, error)

	// UpsertCompanyFiscalizationData request with any body
	UpsertCompanyFiscalizationDataWithBodyWithResponse(ctx context.Context, companyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCompanyFiscalizationDataResponse, error)

	UpsertCompanyFiscalizationDataWithResponse(ctx context.Context, companyId string, body UpsertCompanyFiscalizationDataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCompanyFiscalizationDataResponse, error)

	// GetFiscalizationReport request
	GetFiscalizationReportWithResponse(ctx context.Context, companyId string, params *GetFiscalizationReportParams, reqEditors ...RequestEditorFn) (*GetFiscalizationReportResponse, error)

	// FiscalizeTransaction request with any body
	FiscalizeTransactionWithBodyWithResponse(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiscalizeTransactionResponse, error)

	FiscalizeTransactionWithResponse(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, body FiscalizeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*FiscalizeTransactionResponse, error)

	// SendFiscalizedTransactionPDF request with any body
	SendFiscalizedTransactionPDFWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendFiscalizedTransactionPDFResponse, error)

	SendFiscalizedTransactionPDFWithResponse(ctx context.Context, transactionId string, body SendFiscalizedTransactionPDFJSONRequestBody, reqEditors ...RequestEditorFn) (*SendFiscalizedTransactionPDFResponse, error)

	// GetFiscalizedTransactionPDF request
	GetFiscalizedTransactionPDFWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetFiscalizedTransactionPDFResponse, error)

	// RefundFiscalizedTransaction request
	RefundFiscalizedTransactionWithResponse(ctx context.Context, transactionId string, params *RefundFiscalizedTransactionParams, reqEditors ...RequestEditorFn) (*RefundFiscalizedTransactionResponse, error)

	// AdyenCompanyOnboardingStatus request
	AdyenCompanyOnboardingStatusWithResponse(ctx context.Context, companyId string, params *AdyenCompanyOnboardingStatusParams, reqEditors ...RequestEditorFn) (*AdyenCompanyOnboardingStatusResponse, error)

	// AdyenCompanyOnboarding request with any body
	AdyenCompanyOnboardingWithBodyWithResponse(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdyenCompanyOnboardingResponse, error)

	AdyenCompanyOnboardingWithResponse(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, body AdyenCompanyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*AdyenCompanyOnboardingResponse, error)

	// AdyenUserOnboardingStatus request
	AdyenUserOnboardingStatusWithResponse(ctx context.Context, userId string, params *AdyenUserOnboardingStatusParams, reqEditors ...RequestEditorFn) (*AdyenUserOnboardingStatusResponse, error)

	// AdyenUserOnboarding request with any body
	AdyenUserOnboardingWithBodyWithResponse(ctx context.Context, userId string, params *AdyenUserOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdyenUserOnboardingResponse, error)

	AdyenUserOnboardingWithResponse(ctx context.Context, userId string, params *AdyenUserOnboardingParams, body AdyenUserOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*AdyenUserOnboardingResponse, error)

	// ListSaltpayCompanies request
	ListSaltpayCompaniesWithResponse(ctx context.Context, params *ListSaltpayCompaniesParams, reqEditors ...RequestEditorFn) (*ListSaltpayCompaniesResponse, error)

	// LinkSaltpayBankAccount request with any body
	LinkSaltpayBankAccountWithBodyWithResponse(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkSaltpayBankAccountResponse, error)

	LinkSaltpayBankAccountWithResponse(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, body LinkSaltpayBankAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkSaltpayBankAccountResponse, error)

	// ListSaltpayStoresAtCompany request
	ListSaltpayStoresAtCompanyWithResponse(ctx context.Context, companyId string, params *ListSaltpayStoresAtCompanyParams, reqEditors ...RequestEditorFn) (*ListSaltpayStoresAtCompanyResponse, error)

	// ListSaltpayStores request
	ListSaltpayStoresWithResponse(ctx context.Context, params *ListSaltpayStoresParams, reqEditors ...RequestEditorFn) (*ListSaltpayStoresResponse, error)

	// ListSaltpayTerminals request
	ListSaltpayTerminalsWithResponse(ctx context.Context, storeId string, params *ListSaltpayTerminalsParams, reqEditors ...RequestEditorFn) (*ListSaltpayTerminalsResponse, error)

	// UpdateSaltpayTerminal request with any body
	UpdateSaltpayTerminalWithBodyWithResponse(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSaltpayTerminalResponse, error)

	UpdateSaltpayTerminalWithResponse(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, body UpdateSaltpayTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSaltpayTerminalResponse, error)

	// CreateLineItem request with any body
	CreateLineItemWithBodyWithResponse(ctx context.Context, params *CreateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLineItemResponse, error)

	CreateLineItemWithResponse(ctx context.Context, params *CreateLineItemParams, body CreateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLineItemResponse, error)

	// DeleteLineItem request
	DeleteLineItemWithResponse(ctx context.Context, lineItemId string, params *DeleteLineItemParams, reqEditors ...RequestEditorFn) (*DeleteLineItemResponse, error)

	// GetLineItem request
	GetLineItemWithResponse(ctx context.Context, lineItemId string, params *GetLineItemParams, reqEditors ...RequestEditorFn) (*GetLineItemResponse, error)

	// UpdateLineItem request with any body
	UpdateLineItemWithBodyWithResponse(ctx context.Context, lineItemId string, params *UpdateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLineItemResponse, error)

	UpdateLineItemWithResponse(ctx context.Context, lineItemId string, params *UpdateLineItemParams, body UpdateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLineItemResponse, error)

	// CreateMemo request with any body
	CreateMemoWithBodyWithResponse(ctx context.Context, params *CreateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMemoResponse, error)

	CreateMemoWithResponse(ctx context.Context, params *CreateMemoParams, body CreateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMemoResponse, error)

	// DeleteMemo request
	DeleteMemoWithResponse(ctx context.Context, memoId string, params *DeleteMemoParams, reqEditors ...RequestEditorFn) (*DeleteMemoResponse, error)

	// GetMemo request
	GetMemoWithResponse(ctx context.Context, memoId string, params *GetMemoParams, reqEditors ...RequestEditorFn) (*GetMemoResponse, error)

	// UpdateMemo request with any body
	UpdateMemoWithBodyWithResponse(ctx context.Context, memoId string, params *UpdateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMemoResponse, error)

	UpdateMemoWithResponse(ctx context.Context, memoId string, params *UpdateMemoParams, body UpdateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMemoResponse, error)

	// CreateNotification request with any body
	CreateNotificationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error)

	CreateNotificationWithResponse(ctx context.Context, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error)

	// DeleteNotification request
	DeleteNotificationWithResponse(ctx context.Context, notificationId string, params *DeleteNotificationParams, reqEditors ...RequestEditorFn) (*DeleteNotificationResponse, error)

	// GetNotification request
	GetNotificationWithResponse(ctx context.Context, notificationId string, params *GetNotificationParams, reqEditors ...RequestEditorFn) (*GetNotificationResponse, error)

	// ListOAuthApplications request
	ListOAuthApplicationsWithResponse(ctx context.Context, params *ListOAuthApplicationsParams, reqEditors ...RequestEditorFn) (*ListOAuthApplicationsResponse, error)

	// CreateOAuthApplication request with any body
	CreateOAuthApplicationWithBodyWithResponse(ctx context.Context, params *CreateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthApplicationResponse, error)

	CreateOAuthApplicationWithResponse(ctx context.Context, params *CreateOAuthApplicationParams, body CreateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthApplicationResponse, error)

	// DeleteOAuthApplication request
	DeleteOAuthApplicationWithResponse(ctx context.Context, applicationId string, params *DeleteOAuthApplicationParams, reqEditors ...RequestEditorFn) (*DeleteOAuthApplicationResponse, error)

	// GetOAuthApplication request
	GetOAuthApplicationWithResponse(ctx context.Context, applicationId string, params *GetOAuthApplicationParams, reqEditors ...RequestEditorFn) (*GetOAuthApplicationResponse, error)

	// UpdateOAuthApplication request with any body
	UpdateOAuthApplicationWithBodyWithResponse(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOAuthApplicationResponse, error)

	UpdateOAuthApplicationWithResponse(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, body UpdateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOAuthApplicationResponse, error)

	// StartOAuthFlow request
	StartOAuthFlowWithResponse(ctx context.Context, params *StartOAuthFlowParams, reqEditors ...RequestEditorFn) (*StartOAuthFlowResponse, error)

	// CreateOAuthConsent request with any body
	CreateOAuthConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthConsentResponse, error)

	CreateOAuthConsentWithResponse(ctx context.Context, body CreateOAuthConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthConsentResponse, error)

	// GetOAuthPublicKey request
	GetOAuthPublicKeyWithResponse(ctx context.Context, params *GetOAuthPublicKeyParams, reqEditors ...RequestEditorFn) (*GetOAuthPublicKeyResponse, error)

	// ListOAuthScopes request
	ListOAuthScopesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthScopesResponse, error)

	// GetOAuthToken request with any body
	GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	GetOAuthTokenWithResponse(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error)

	// ListPaymentMethods request
	ListPaymentMethodsWithResponse(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListPaymentMethodsResponse, error)

	// GetPayment request
	GetPaymentWithResponse(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*GetPaymentResponse, error)

	// UpdatePayment request with any body
	UpdatePaymentWithBodyWithResponse(ctx context.Context, paymentId string, params *UpdatePaymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentResponse, error)

	UpdatePaymentWithResponse(ctx context.Context, paymentId string, params *UpdatePaymentParams, body UpdatePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentResponse, error)

	// DownloadPaymentReceipt request
	DownloadPaymentReceiptWithResponse(ctx context.Context, paymentId string, params *DownloadPaymentReceiptParams, reqEditors ...RequestEditorFn) (*DownloadPaymentReceiptResponse, error)

	// SendPaymentReceipt request with any body
	SendPaymentReceiptWithBodyWithResponse(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPaymentReceiptResponse, error)

	SendPaymentReceiptWithResponse(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, body SendPaymentReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPaymentReceiptResponse, error)

	// ListPricing request
	ListPricingWithResponse(ctx context.Context, params *ListPricingParams, reqEditors ...RequestEditorFn) (*ListPricingResponse, error)

	// CalculatePricing request
	CalculatePricingWithResponse(ctx context.Context, params *CalculatePricingParams, reqEditors ...RequestEditorFn) (*CalculatePricingResponse, error)

	// GetPricingByCountryCode request
	GetPricingByCountryCodeWithResponse(ctx context.Context, countryCode string, params *GetPricingByCountryCodeParams, reqEditors ...RequestEditorFn) (*GetPricingByCountryCodeResponse, error)

	// ListProductGroups request
	ListProductGroupsWithResponse(ctx context.Context, params *ListProductGroupsParams, reqEditors ...RequestEditorFn) (*ListProductGroupsResponse, error)

	// CreateProductGroup request with any body
	CreateProductGroupWithBodyWithResponse(ctx context.Context, params *CreateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductGroupResponse, error)

	CreateProductGroupWithResponse(ctx context.Context, params *CreateProductGroupParams, body CreateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductGroupResponse, error)

	// ListGroupsAndProducts request
	ListGroupsAndProductsWithResponse(ctx context.Context, params *ListGroupsAndProductsParams, reqEditors ...RequestEditorFn) (*ListGroupsAndProductsResponse, error)

	// UpdateProductGroupsOrder request with any body
	UpdateProductGroupsOrderWithBodyWithResponse(ctx context.Context, params *UpdateProductGroupsOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductGroupsOrderResponse, error)

	UpdateProductGroupsOrderWithResponse(ctx context.Context, params *UpdateProductGroupsOrderParams, body UpdateProductGroupsOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductGroupsOrderResponse, error)

	// DeleteProductGroup request
	DeleteProductGroupWithResponse(ctx context.Context, id string, params *DeleteProductGroupParams, reqEditors ...RequestEditorFn) (*DeleteProductGroupResponse, error)

	// GetProductGroup request
	GetProductGroupWithResponse(ctx context.Context, id string, params *GetProductGroupParams, reqEditors ...RequestEditorFn) (*GetProductGroupResponse, error)

	// UpdateProductGroup request with any body
	UpdateProductGroupWithBodyWithResponse(ctx context.Context, id string, params *UpdateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductGroupResponse, error)

	UpdateProductGroupWithResponse(ctx context.Context, id string, params *UpdateProductGroupParams, body UpdateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductGroupResponse, error)

	// ListProducts request
	ListProductsWithResponse(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*ListProductsResponse, error)

	// CreateProduct request with any body
	CreateProductWithBodyWithResponse(ctx context.Context, params *CreateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductResponse, error)

	CreateProductWithResponse(ctx context.Context, params *CreateProductParams, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductResponse, error)

	// DeleteProduct request
	DeleteProductWithResponse(ctx context.Context, id string, params *DeleteProductParams, reqEditors ...RequestEditorFn) (*DeleteProductResponse, error)

	// GetProduct request
	GetProductWithResponse(ctx context.Context, id string, params *GetProductParams, reqEditors ...RequestEditorFn) (*GetProductResponse, error)

	// UpdateProduct request with any body
	UpdateProductWithBodyWithResponse(ctx context.Context, id string, params *UpdateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error)

	UpdateProductWithResponse(ctx context.Context, id string, params *UpdateProductParams, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error)

	// CreateCustomProperty request with any body
	CreateCustomPropertyWithBodyWithResponse(ctx context.Context, params *CreateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomPropertyResponse, error)

	CreateCustomPropertyWithResponse(ctx context.Context, params *CreateCustomPropertyParams, body CreateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomPropertyResponse, error)

	// DeleteCustomProperty request
	DeleteCustomPropertyWithResponse(ctx context.Context, propertyId string, params *DeleteCustomPropertyParams, reqEditors ...RequestEditorFn) (*DeleteCustomPropertyResponse, error)

	// UpdateCustomProperty request with any body
	UpdateCustomPropertyWithBodyWithResponse(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomPropertyResponse, error)

	UpdateCustomPropertyWithResponse(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, body UpdateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomPropertyResponse, error)

	// CreateResourceGroup request with any body
	CreateResourceGroupWithBodyWithResponse(ctx context.Context, params *CreateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceGroupResponse, error)

	CreateResourceGroupWithResponse(ctx context.Context, params *CreateResourceGroupParams, body CreateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceGroupResponse, error)

	// DeleteResourceGroup request
	DeleteResourceGroupWithResponse(ctx context.Context, resourceGroupId string, params *DeleteResourceGroupParams, reqEditors ...RequestEditorFn) (*DeleteResourceGroupResponse, error)

	// GetResourceGroup request
	GetResourceGroupWithResponse(ctx context.Context, resourceGroupId string, params *GetResourceGroupParams, reqEditors ...RequestEditorFn) (*GetResourceGroupResponse, error)

	// UpdateResourceGroup request with any body
	UpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceGroupResponse, error)

	UpdateResourceGroupWithResponse(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, body UpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceGroupResponse, error)

	// CreateResource request with any body
	CreateResourceWithBodyWithResponse(ctx context.Context, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	CreateResourceWithResponse(ctx context.Context, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	// DeleteResource request
	DeleteResourceWithResponse(ctx context.Context, resourceId string, params *DeleteResourceParams, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// GetResource request
	GetResourceWithResponse(ctx context.Context, resourceId string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// UpdateResource request with any body
	UpdateResourceWithBodyWithResponse(ctx context.Context, resourceId string, params *UpdateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	UpdateResourceWithResponse(ctx context.Context, resourceId string, params *UpdateResourceParams, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	// CreateRuleSetTemplate request with any body
	CreateRuleSetTemplateWithBodyWithResponse(ctx context.Context, params *CreateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleSetTemplateResponse, error)

	CreateRuleSetTemplateWithResponse(ctx context.Context, params *CreateRuleSetTemplateParams, body CreateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleSetTemplateResponse, error)

	// DeleteRuleSetTemplate request
	DeleteRuleSetTemplateWithResponse(ctx context.Context, ruleSetTemplateId string, params *DeleteRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*DeleteRuleSetTemplateResponse, error)

	// GetRuleSetTemplate request
	GetRuleSetTemplateWithResponse(ctx context.Context, ruleSetTemplateId string, params *GetRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*GetRuleSetTemplateResponse, error)

	// UpdateRuleSetTemplate request with any body
	UpdateRuleSetTemplateWithBodyWithResponse(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleSetTemplateResponse, error)

	UpdateRuleSetTemplateWithResponse(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, body UpdateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleSetTemplateResponse, error)

	// CreateRuleSet request with any body
	CreateRuleSetWithBodyWithResponse(ctx context.Context, params *CreateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleSetResponse, error)

	CreateRuleSetWithResponse(ctx context.Context, params *CreateRuleSetParams, body CreateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleSetResponse, error)

	// DeleteRuleSet request
	DeleteRuleSetWithResponse(ctx context.Context, ruleSetId string, params *DeleteRuleSetParams, reqEditors ...RequestEditorFn) (*DeleteRuleSetResponse, error)

	// GetRuleSet request
	GetRuleSetWithResponse(ctx context.Context, ruleSetId string, params *GetRuleSetParams, reqEditors ...RequestEditorFn) (*GetRuleSetResponse, error)

	// UpdateRuleSet request with any body
	UpdateRuleSetWithBodyWithResponse(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleSetResponse, error)

	UpdateRuleSetWithResponse(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, body UpdateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleSetResponse, error)

	// CreateSale request with any body
	CreateSaleWithBodyWithResponse(ctx context.Context, params *CreateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSaleResponse, error)

	CreateSaleWithResponse(ctx context.Context, params *CreateSaleParams, body CreateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSaleResponse, error)

	// DeleteSale request
	DeleteSaleWithResponse(ctx context.Context, saleId string, params *DeleteSaleParams, reqEditors ...RequestEditorFn) (*DeleteSaleResponse, error)

	// GetSale request
	GetSaleWithResponse(ctx context.Context, saleId string, params *GetSaleParams, reqEditors ...RequestEditorFn) (*GetSaleResponse, error)

	// UpdateSale request with any body
	UpdateSaleWithBodyWithResponse(ctx context.Context, saleId string, params *UpdateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSaleResponse, error)

	UpdateSaleWithResponse(ctx context.Context, saleId string, params *UpdateSaleParams, body UpdateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSaleResponse, error)

	// RefundMarketplaceSale request
	RefundMarketplaceSaleWithResponse(ctx context.Context, saleId string, params *RefundMarketplaceSaleParams, reqEditors ...RequestEditorFn) (*RefundMarketplaceSaleResponse, error)

	// SendTransactionReceipt request with any body
	SendTransactionReceiptWithBodyWithResponse(ctx context.Context, saleId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendTransactionReceiptResponse, error)

	SendTransactionReceiptWithResponse(ctx context.Context, saleId string, transactionId string, body SendTransactionReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*SendTransactionReceiptResponse, error)

	// DeprecatedListSubtransactions request
	DeprecatedListSubtransactionsWithResponse(ctx context.Context, saleId string, transactionId string, params *DeprecatedListSubtransactionsParams, reqEditors ...RequestEditorFn) (*DeprecatedListSubtransactionsResponse, error)

	// DeprecatedGetSubtransaction request
	DeprecatedGetSubtransactionWithResponse(ctx context.Context, saleId string, transactionId string, id string, params *DeprecatedGetSubtransactionParams, reqEditors ...RequestEditorFn) (*DeprecatedGetSubtransactionResponse, error)

	// CreateSpace request with any body
	CreateSpaceWithBodyWithResponse(ctx context.Context, params *CreateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	CreateSpaceWithResponse(ctx context.Context, params *CreateSpaceParams, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	// DeleteSpace request
	DeleteSpaceWithResponse(ctx context.Context, spaceId string, params *DeleteSpaceParams, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error)

	// GetSpace request
	GetSpaceWithResponse(ctx context.Context, spaceId string, params *GetSpaceParams, reqEditors ...RequestEditorFn) (*GetSpaceResponse, error)

	// UpdateSpace request with any body
	UpdateSpaceWithBodyWithResponse(ctx context.Context, spaceId string, params *UpdateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	UpdateSpaceWithResponse(ctx context.Context, spaceId string, params *UpdateSpaceParams, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	// StreamBlockedTimes request
	StreamBlockedTimesWithResponse(ctx context.Context, companyId string, params *StreamBlockedTimesParams, reqEditors ...RequestEditorFn) (*StreamBlockedTimesResponse, error)

	// StreamEmployees request
	StreamEmployeesWithResponse(ctx context.Context, companyId string, params *StreamEmployeesParams, reqEditors ...RequestEditorFn) (*StreamEmployeesResponse, error)

	// StreamEventTypeGroups request
	StreamEventTypeGroupsWithResponse(ctx context.Context, companyId string, params *StreamEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*StreamEventTypeGroupsResponse, error)

	// StreamEventTypes request
	StreamEventTypesWithResponse(ctx context.Context, companyId string, params *StreamEventTypesParams, reqEditors ...RequestEditorFn) (*StreamEventTypesResponse, error)

	// StreamEvents request
	StreamEventsWithResponse(ctx context.Context, companyId string, params *StreamEventsParams, reqEditors ...RequestEditorFn) (*StreamEventsResponse, error)

	// StreamSalesMetrics request
	StreamSalesMetricsWithResponse(ctx context.Context, companyId string, params *StreamSalesMetricsParams, reqEditors ...RequestEditorFn) (*StreamSalesMetricsResponse, error)

	// StreamNotifications request
	StreamNotificationsWithResponse(ctx context.Context, companyId string, params *StreamNotificationsParams, reqEditors ...RequestEditorFn) (*StreamNotificationsResponse, error)

	// StreamProductGroups request
	StreamProductGroupsWithResponse(ctx context.Context, companyId string, params *StreamProductGroupsParams, reqEditors ...RequestEditorFn) (*StreamProductGroupsResponse, error)

	// StreamProducts request
	StreamProductsWithResponse(ctx context.Context, companyId string, params *StreamProductsParams, reqEditors ...RequestEditorFn) (*StreamProductsResponse, error)

	// StreamResources request
	StreamResourcesWithResponse(ctx context.Context, companyId string, params *StreamResourcesParams, reqEditors ...RequestEditorFn) (*StreamResourcesResponse, error)

	// StreamSpaces request
	StreamSpacesWithResponse(ctx context.Context, companyId string, params *StreamSpacesParams, reqEditors ...RequestEditorFn) (*StreamSpacesResponse, error)

	// StreamTimeSlotReservations request
	StreamTimeSlotReservationsWithResponse(ctx context.Context, companyId string, params *StreamTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*StreamTimeSlotReservationsResponse, error)

	// GetBillingInvoice request
	GetBillingInvoiceWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*GetBillingInvoiceResponse, error)

	// DeleteSubscription request
	DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// GetSubscription request
	GetSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error)

	// CreateSubtransaction request with any body
	CreateSubtransactionWithBodyWithResponse(ctx context.Context, params *CreateSubtransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubtransactionResponse, error)

	CreateSubtransactionWithResponse(ctx context.Context, params *CreateSubtransactionParams, body CreateSubtransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubtransactionResponse, error)

	// DeleteSubtransaction request
	DeleteSubtransactionWithResponse(ctx context.Context, subtransactionId string, params *DeleteSubtransactionParams, reqEditors ...RequestEditorFn) (*DeleteSubtransactionResponse, error)

	// GetSubtransaction request
	GetSubtransactionWithResponse(ctx context.Context, subtransactionId string, params *GetSubtransactionParams, reqEditors ...RequestEditorFn) (*GetSubtransactionResponse, error)

	// DeleteTerminal request
	DeleteTerminalWithResponse(ctx context.Context, terminalId string, params *DeleteTerminalParams, reqEditors ...RequestEditorFn) (*DeleteTerminalResponse, error)

	// GetTerminal request
	GetTerminalWithResponse(ctx context.Context, terminalId string, params *GetTerminalParams, reqEditors ...RequestEditorFn) (*GetTerminalResponse, error)

	// UpdateTerminal request with any body
	UpdateTerminalWithBodyWithResponse(ctx context.Context, terminalId string, params *UpdateTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTerminalResponse, error)

	UpdateTerminalWithResponse(ctx context.Context, terminalId string, params *UpdateTerminalParams, body UpdateTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTerminalResponse, error)

	// GetOAuthConsent request
	GetOAuthConsentWithResponse(ctx context.Context, params *GetOAuthConsentParams, reqEditors ...RequestEditorFn) (*GetOAuthConsentResponse, error)

	// GetOAuthLogin request
	GetOAuthLoginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOAuthLoginResponse, error)

	// PostOAuthLogin request with any body
	PostOAuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOAuthLoginResponse, error)

	PostOAuthLoginWithResponse(ctx context.Context, body PostOAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOAuthLoginResponse, error)

	// GetTimeSlotReservation request
	GetTimeSlotReservationWithResponse(ctx context.Context, timeSlotReservationId string, params *GetTimeSlotReservationParams, reqEditors ...RequestEditorFn) (*GetTimeSlotReservationResponse, error)

	// CreateToken request
	CreateTokenWithResponse(ctx context.Context, params *CreateTokenParams, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// CreateTransaction request with any body
	CreateTransactionWithBodyWithResponse(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error)

	CreateTransactionWithResponse(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error)

	// DeleteTransaction request
	DeleteTransactionWithResponse(ctx context.Context, transactionId string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error)

	// GetTransaction request
	GetTransactionWithResponse(ctx context.Context, transactionId string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error)

	// UpdateTransaction request with any body
	UpdateTransactionWithBodyWithResponse(ctx context.Context, transactionId string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error)

	UpdateTransactionWithResponse(ctx context.Context, transactionId string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error)

	// ListLineItems request
	ListLineItemsWithResponse(ctx context.Context, transactionId string, params *ListLineItemsParams, reqEditors ...RequestEditorFn) (*ListLineItemsResponse, error)

	// ListSubtransactions request
	ListSubtransactionsWithResponse(ctx context.Context, transactionId string, params *ListSubtransactionsParams, reqEditors ...RequestEditorFn) (*ListSubtransactionsResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// DeleteGoogleCalendarConnection request
	DeleteGoogleCalendarConnectionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteGoogleCalendarConnectionResponse, error)

	// GetGoogleCalendarConnection request
	GetGoogleCalendarConnectionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGoogleCalendarConnectionResponse, error)

	// CreateGoogleCalendarConnection request with any body
	CreateGoogleCalendarConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGoogleCalendarConnectionResponse, error)

	CreateGoogleCalendarConnectionWithResponse(ctx context.Context, body CreateGoogleCalendarConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGoogleCalendarConnectionResponse, error)

	// UserOAuth request
	UserOAuthWithResponse(ctx context.Context, params *UserOAuthParams, reqEditors ...RequestEditorFn) (*UserOAuthResponse, error)

	// ListUserSettlementAccounts request
	ListUserSettlementAccountsWithResponse(ctx context.Context, params *ListUserSettlementAccountsParams, reqEditors ...RequestEditorFn) (*ListUserSettlementAccountsResponse, error)

	// ListUserTerminals request
	ListUserTerminalsWithResponse(ctx context.Context, params *ListUserTerminalsParams, reqEditors ...RequestEditorFn) (*ListUserTerminalsResponse, error)

	// DeleteUserTerminal request
	DeleteUserTerminalWithResponse(ctx context.Context, terminalId string, params *DeleteUserTerminalParams, reqEditors ...RequestEditorFn) (*DeleteUserTerminalResponse, error)

	// GetUserTerminal request
	GetUserTerminalWithResponse(ctx context.Context, terminalId string, params *GetUserTerminalParams, reqEditors ...RequestEditorFn) (*GetUserTerminalResponse, error)

	// ListUserTokens request
	ListUserTokensWithResponse(ctx context.Context, params *ListUserTokensParams, reqEditors ...RequestEditorFn) (*ListUserTokensResponse, error)

	// CreateUserToken request with any body
	CreateUserTokenWithBodyWithResponse(ctx context.Context, params *CreateUserTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error)

	CreateUserTokenWithResponse(ctx context.Context, params *CreateUserTokenParams, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error)

	// DeleteUserToken request
	DeleteUserTokenWithResponse(ctx context.Context, tokenId string, params *DeleteUserTokenParams, reqEditors ...RequestEditorFn) (*DeleteUserTokenResponse, error)

	// GetUserToken request
	GetUserTokenWithResponse(ctx context.Context, tokenId string, params *GetUserTokenParams, reqEditors ...RequestEditorFn) (*GetUserTokenResponse, error)

	// CreateVoucherTemplate request with any body
	CreateVoucherTemplateWithBodyWithResponse(ctx context.Context, params *CreateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateResponse, error)

	CreateVoucherTemplateWithResponse(ctx context.Context, params *CreateVoucherTemplateParams, body CreateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateResponse, error)

	// DeleteVoucherTemplate request
	DeleteVoucherTemplateWithResponse(ctx context.Context, voucherTemplateId string, params *DeleteVoucherTemplateParams, reqEditors ...RequestEditorFn) (*DeleteVoucherTemplateResponse, error)

	// UpdateVoucherTemplate request with any body
	UpdateVoucherTemplateWithBodyWithResponse(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVoucherTemplateResponse, error)

	UpdateVoucherTemplateWithResponse(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, body UpdateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVoucherTemplateResponse, error)

	// DeleteVoucher request
	DeleteVoucherWithResponse(ctx context.Context, voucherId string, params *DeleteVoucherParams, reqEditors ...RequestEditorFn) (*DeleteVoucherResponse, error)

	// GetVoucher request
	GetVoucherWithResponse(ctx context.Context, voucherId string, params *GetVoucherParams, reqEditors ...RequestEditorFn) (*GetVoucherResponse, error)

	// UpdateVoucher request with any body
	UpdateVoucherWithBodyWithResponse(ctx context.Context, voucherId string, params *UpdateVoucherParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVoucherResponse, error)

	UpdateVoucherWithResponse(ctx context.Context, voucherId string, params *UpdateVoucherParams, body UpdateVoucherJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVoucherResponse, error)

	// CreateVoucherNotification request with any body
	CreateVoucherNotificationWithBodyWithResponse(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVoucherNotificationResponse, error)

	CreateVoucherNotificationWithResponse(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, body CreateVoucherNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVoucherNotificationResponse, error)

	// CreateWaitlistEntry request with any body
	CreateWaitlistEntryWithBodyWithResponse(ctx context.Context, params *CreateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWaitlistEntryResponse, error)

	CreateWaitlistEntryWithResponse(ctx context.Context, params *CreateWaitlistEntryParams, body CreateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWaitlistEntryResponse, error)

	// DeleteWaitlistEntry request
	DeleteWaitlistEntryWithResponse(ctx context.Context, waitlistEntryId string, params *DeleteWaitlistEntryParams, reqEditors ...RequestEditorFn) (*DeleteWaitlistEntryResponse, error)

	// GetWaitlistEntry request
	GetWaitlistEntryWithResponse(ctx context.Context, waitlistEntryId string, params *GetWaitlistEntryParams, reqEditors ...RequestEditorFn) (*GetWaitlistEntryResponse, error)

	// UpdateWaitlistEntry request with any body
	UpdateWaitlistEntryWithBodyWithResponse(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWaitlistEntryResponse, error)

	UpdateWaitlistEntryWithResponse(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, body UpdateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWaitlistEntryResponse, error)

	// GetWebhookInvocation request
	GetWebhookInvocationWithResponse(ctx context.Context, webhookInvocationId string, params *GetWebhookInvocationParams, reqEditors ...RequestEditorFn) (*GetWebhookInvocationResponse, error)

	// UpdateWebhookInvocation request with any body
	UpdateWebhookInvocationWithBodyWithResponse(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookInvocationResponse, error)

	UpdateWebhookInvocationWithResponse(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, body UpdateWebhookInvocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookInvocationResponse, error)

	// CreateWebhook request with any body
	CreateWebhookWithBodyWithResponse(ctx context.Context, params *CreateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	CreateWebhookWithResponse(ctx context.Context, params *CreateWebhookParams, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	// ListWebhookEvents request
	ListWebhookEventsWithResponse(ctx context.Context, params *ListWebhookEventsParams, reqEditors ...RequestEditorFn) (*ListWebhookEventsResponse, error)

	// DeleteWebhook request
	DeleteWebhookWithResponse(ctx context.Context, webhookId string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhook request
	GetWebhookWithResponse(ctx context.Context, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// UpdateWebhook request with any body
	UpdateWebhookWithBodyWithResponse(ctx context.Context, webhookId string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	UpdateWebhookWithResponse(ctx context.Context, webhookId string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)
}

type ListCustomerActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomerActivities
}

// Status returns HTTPResponse.Status
func (r ListCustomerActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventTypeActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventTypeActivities
}

// Status returns HTTPResponse.Status
func (r ListEventTypeActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventTypeActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventActivities
}

// Status returns HTTPResponse.Status
func (r ListEventActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentActivities
}

// Status returns HTTPResponse.Status
func (r ListPaymentActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBlockedTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedTimeResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r CreateBlockedTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBlockedTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBlockedTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBlockedTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBlockedTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockedTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedTimeResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetBlockedTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockedTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBlockedTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedTimeResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateBlockedTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBlockedTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Companies
}

// Status returns HTTPResponse.Status
func (r GetCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Company
}

// Status returns HTTPResponse.Status
func (r CreateCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Company
}

// Status returns HTTPResponse.Status
func (r GetCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Company
}

// Status returns HTTPResponse.Status
func (r UpdateCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllCompanyActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnifiedActivities
}

// Status returns HTTPResponse.Status
func (r ListAllCompanyActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllCompanyActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Apps
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisableAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBlockedTimesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedTimesResponse
}

// Status returns HTTPResponse.Status
func (r ListBlockedTimesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBlockedTimesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClaimsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Claims
}

// Status returns HTTPResponse.Status
func (r ListClaimsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClaimsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomerGroups
}

// Status returns HTTPResponse.Status
func (r ListCustomerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Customers
}

// Status returns HTTPResponse.Status
func (r ListCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEmployeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Employees
}

// Status returns HTTPResponse.Status
func (r ListEmployeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEmployeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Employee
}

// Status returns HTTPResponse.Status
func (r GetEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Employee
}

// Status returns HTTPResponse.Status
func (r UpdateEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventStatuses
}

// Status returns HTTPResponse.Status
func (r ListEventStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventTypeCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventTypeCategories
}

// Status returns HTTPResponse.Status
func (r ListEventTypeCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventTypeCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventTypeCategoryGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventTypeCategoryGroups
}

// Status returns HTTPResponse.Status
func (r ListEventTypeCategoryGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventTypeCategoryGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventTypeGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventTypeGroups
}

// Status returns HTTPResponse.Status
func (r ListEventTypeGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventTypeGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventTypes
}

// Status returns HTTPResponse.Status
func (r ListEventTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Events
}

// Status returns HTTPResponse.Status
func (r ListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckinWithPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventCheckinResult
}

// Status returns HTTPResponse.Status
func (r CheckinWithPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckinWithPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHolidaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Holidays
}

// Status returns HTTPResponse.Status
func (r ListHolidaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHolidaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIssuersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Issuers
}

// Status returns HTTPResponse.Status
func (r ListIssuersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIssuersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMemosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MemosResponse
}

// Status returns HTTPResponse.Status
func (r ListMemosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMemosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSalesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SalesMetrics
}

// Status returns HTTPResponse.Status
func (r GetSalesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSalesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletionResult
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notifications
}

// Status returns HTTPResponse.Status
func (r ListNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOpeningHoursResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpeningHoursResponse
}

// Status returns HTTPResponse.Status
func (r ListOpeningHoursResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOpeningHoursResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payments
}

// Status returns HTTPResponse.Status
func (r ListPaymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomProperties
}

// Status returns HTTPResponse.Status
func (r ListCustomPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceGroupsResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r ListResourceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resources
}

// Status returns HTTPResponse.Status
func (r ListResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleSetTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetTemplatesResponse
}

// Status returns HTTPResponse.Status
func (r ListRuleSetTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleSetTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetsResponse
}

// Status returns HTTPResponse.Status
func (r ListRuleSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSalesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sales
}

// Status returns HTTPResponse.Status
func (r ListSalesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSalesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSettlementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Settlements
}

// Status returns HTTPResponse.Status
func (r ListSettlementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSettlementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSMSMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SMSMessages
}

// Status returns HTTPResponse.Status
func (r ListSMSMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSMSMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Spaces
}

// Status returns HTTPResponse.Status
func (r ListSpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PowerupSubscription
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionBillingInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BillingCustomer
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionBillingInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionBillingInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBillingInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BillingCustomer
}

// Status returns HTTPResponse.Status
func (r UpdateBillingInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBillingInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingInvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BillingInvoices
}

// Status returns HTTPResponse.Status
func (r ListBillingInvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingInvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePaymentIntentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentIntent
}

// Status returns HTTPResponse.Status
func (r CreatePaymentIntentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePaymentIntentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTerminalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Terminals
}

// Status returns HTTPResponse.Status
func (r ListTerminalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTerminalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTimeSlotReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimeSlotReservations
}

// Status returns HTTPResponse.Status
func (r ListTimeSlotReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTimeSlotReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTimeSlotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimeSlots
}

// Status returns HTTPResponse.Status
func (r ListTimeSlotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTimeSlotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transactions
}

// Status returns HTTPResponse.Status
func (r ListTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVATsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VATs
}

// Status returns HTTPResponse.Status
func (r ListVATsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVATsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVoucherTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoucherTemplatesResponse
}

// Status returns HTTPResponse.Status
func (r ListVoucherTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVoucherTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVouchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vouchers
}

// Status returns HTTPResponse.Status
func (r ListVouchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVouchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWaitlistEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WaitlistEntriesResponse
}

// Status returns HTTPResponse.Status
func (r ListWaitlistEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWaitlistEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhookInvocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookInvocations
}

// Status returns HTTPResponse.Status
func (r ListWebhookInvocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookInvocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhooks
}

// Status returns HTTPResponse.Status
func (r ListWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomerGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomerGroup
}

// Status returns HTTPResponse.Status
func (r CreateCustomerGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomerGroup
}

// Status returns HTTPResponse.Status
func (r GetCustomerGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomerGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomerGroup
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Customer
}

// Status returns HTTPResponse.Status
func (r CreateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Customer
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Customer
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEmployeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Employee
}

// Status returns HTTPResponse.Status
func (r CreateEmployeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEmployeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Enterprise
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Enterprise
}

// Status returns HTTPResponse.Status
func (r UpdateEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnterpriseCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Companies
}

// Status returns HTTPResponse.Status
func (r ListEnterpriseCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnterpriseCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payments
}

// Status returns HTTPResponse.Status
func (r ListPaymentsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEnterpriseSettlementAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettlementAccounts
}

// Status returns HTTPResponse.Status
func (r ListEnterpriseSettlementAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEnterpriseSettlementAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnterpriseSettlementAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEnterpriseSettlementAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnterpriseSettlementAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnterpriseSettlementAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettlementAccount
}

// Status returns HTTPResponse.Status
func (r GetEnterpriseSettlementAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnterpriseSettlementAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSettlementsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Settlements
}

// Status returns HTTPResponse.Status
func (r ListSettlementsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSettlementsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVoucherTemplatesLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoucherTemplatesResponse
}

// Status returns HTTPResponse.Status
func (r ListVoucherTemplatesLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVoucherTemplatesLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVoucherTemplateLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoucherTemplateResponse
}

// Status returns HTTPResponse.Status
func (r CreateVoucherTemplateLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVoucherTemplateLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVouchersLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vouchers
}

// Status returns HTTPResponse.Status
func (r ListVouchersLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVouchersLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoucherLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Voucher
}

// Status returns HTTPResponse.Status
func (r GetVoucherLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoucherLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVoucherLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Voucher
}

// Status returns HTTPResponse.Status
func (r UpdateVoucherLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVoucherLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEventStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventStatus
}

// Status returns HTTPResponse.Status
func (r CreateEventStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEventStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEventStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEventStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEventStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventStatus
}

// Status returns HTTPResponse.Status
func (r GetEventStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEventStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventStatus
}

// Status returns HTTPResponse.Status
func (r UpdateEventStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEventStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventTypeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventTypeGroup
}

// Status returns HTTPResponse.Status
func (r GetEventTypeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventTypeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEventTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventType
}

// Status returns HTTPResponse.Status
func (r CreateEventTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEventTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEventTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEventTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEventTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventType
}

// Status returns HTTPResponse.Status
func (r GetEventTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEventTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventType
}

// Status returns HTTPResponse.Status
func (r UpdateEventTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEventTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
}

// Status returns HTTPResponse.Status
func (r CreateEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
}

// Status returns HTTPResponse.Status
func (r GetEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
}

// Status returns HTTPResponse.Status
func (r UpdateEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCheckoutForEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sale
}

// Status returns HTTPResponse.Status
func (r CreateCheckoutForEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCheckoutForEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCompanyFiscalizationDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FiscalizationOnboarding
}

// Status returns HTTPResponse.Status
func (r DeleteCompanyFiscalizationDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompanyFiscalizationDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompanyFiscalizationDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FiscalizationOnboarding
}

// Status returns HTTPResponse.Status
func (r GetCompanyFiscalizationDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyFiscalizationDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertCompanyFiscalizationDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FiscalizationOnboarding
}

// Status returns HTTPResponse.Status
func (r UpsertCompanyFiscalizationDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertCompanyFiscalizationDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFiscalizationReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFiscalizationReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFiscalizationReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FiscalizeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FiscalizationRecord
	JSON400      *FiscalizeTransactionError
}

// Status returns HTTPResponse.Status
func (r FiscalizeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FiscalizeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendFiscalizedTransactionPDFResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendFiscalizedTransactionPDFResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendFiscalizedTransactionPDFResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFiscalizedTransactionPDFResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFiscalizedTransactionPDFResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFiscalizedTransactionPDFResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefundFiscalizedTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
}

// Status returns HTTPResponse.Status
func (r RefundFiscalizedTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefundFiscalizedTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdyenCompanyOnboardingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdyenOnboardingInfo
}

// Status returns HTTPResponse.Status
func (r AdyenCompanyOnboardingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdyenCompanyOnboardingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdyenCompanyOnboardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdyenOnboardingInfo
}

// Status returns HTTPResponse.Status
func (r AdyenCompanyOnboardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdyenCompanyOnboardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdyenUserOnboardingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdyenOnboardingInfo
}

// Status returns HTTPResponse.Status
func (r AdyenUserOnboardingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdyenUserOnboardingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdyenUserOnboardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdyenOnboardingInfo
}

// Status returns HTTPResponse.Status
func (r AdyenUserOnboardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdyenUserOnboardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSaltpayCompaniesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SaltpayCompanies
}

// Status returns HTTPResponse.Status
func (r ListSaltpayCompaniesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSaltpayCompaniesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkSaltpayBankAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettlementAccount
}

// Status returns HTTPResponse.Status
func (r LinkSaltpayBankAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkSaltpayBankAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSaltpayStoresAtCompanyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SaltpayStores
}

// Status returns HTTPResponse.Status
func (r ListSaltpayStoresAtCompanyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSaltpayStoresAtCompanyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSaltpayStoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SaltpayStores
}

// Status returns HTTPResponse.Status
func (r ListSaltpayStoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSaltpayStoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSaltpayTerminalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SaltpayTerminals
}

// Status returns HTTPResponse.Status
func (r ListSaltpayTerminalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSaltpayTerminalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSaltpayTerminalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SaltpayTerminal
}

// Status returns HTTPResponse.Status
func (r UpdateSaltpayTerminalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSaltpayTerminalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLineItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LineItem
}

// Status returns HTTPResponse.Status
func (r CreateLineItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLineItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLineItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteLineItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLineItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLineItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LineItem
}

// Status returns HTTPResponse.Status
func (r GetLineItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLineItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLineItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LineItem
}

// Status returns HTTPResponse.Status
func (r UpdateLineItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLineItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMemoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MemoResponse
}

// Status returns HTTPResponse.Status
func (r CreateMemoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMemoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMemoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMemoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMemoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMemoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MemoResponse
}

// Status returns HTTPResponse.Status
func (r GetMemoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMemoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMemoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MemoResponse
}

// Status returns HTTPResponse.Status
func (r UpdateMemoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMemoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
}

// Status returns HTTPResponse.Status
func (r GetNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOAuthApplicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Applications
}

// Status returns HTTPResponse.Status
func (r ListOAuthApplicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOAuthApplicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOAuthApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
}

// Status returns HTTPResponse.Status
func (r CreateOAuthApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOAuthApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOAuthApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
}

// Status returns HTTPResponse.Status
func (r DeleteOAuthApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOAuthApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
}

// Status returns HTTPResponse.Status
func (r GetOAuthApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOAuthApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
}

// Status returns HTTPResponse.Status
func (r UpdateOAuthApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOAuthApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartOAuthFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StartOAuthFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartOAuthFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOAuthConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthConsentResponse
}

// Status returns HTTPResponse.Status
func (r CreateOAuthConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOAuthConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthPublicKey
}

// Status returns HTTPResponse.Status
func (r GetOAuthPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOAuthScopesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthScopes
}

// Status returns HTTPResponse.Status
func (r ListOAuthScopesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOAuthScopesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OAuthToken
}

// Status returns HTTPResponse.Status
func (r GetOAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaymentMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentMethods
}

// Status returns HTTPResponse.Status
func (r ListPaymentMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaymentMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payment
}

// Status returns HTTPResponse.Status
func (r GetPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payment
}

// Status returns HTTPResponse.Status
func (r UpdatePaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadPaymentReceiptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadPaymentReceiptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadPaymentReceiptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendPaymentReceiptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendPaymentReceiptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendPaymentReceiptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPricingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllPricing
}

// Status returns HTTPResponse.Status
func (r ListPricingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPricingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculatePricingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PricingCalculation
}

// Status returns HTTPResponse.Status
func (r CalculatePricingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculatePricingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricingByCountryCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pricing
}

// Status returns HTTPResponse.Status
func (r GetPricingByCountryCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricingByCountryCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProductGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroups
}

// Status returns HTTPResponse.Status
func (r ListProductGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProductGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProductGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroup
}

// Status returns HTTPResponse.Status
func (r CreateProductGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProductGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsAndProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroupsExpanded
}

// Status returns HTTPResponse.Status
func (r ListGroupsAndProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsAndProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductGroupsOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroupsOrder
}

// Status returns HTTPResponse.Status
func (r UpdateProductGroupsOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductGroupsOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteProductGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroup
}

// Status returns HTTPResponse.Status
func (r GetProductGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductGroup
}

// Status returns HTTPResponse.Status
func (r UpdateProductGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Products
}

// Status returns HTTPResponse.Status
func (r ListProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Product
}

// Status returns HTTPResponse.Status
func (r CreateProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Product
}

// Status returns HTTPResponse.Status
func (r GetProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Product
}

// Status returns HTTPResponse.Status
func (r UpdateProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomProperty
}

// Status returns HTTPResponse.Status
func (r CreateCustomPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomProperty
}

// Status returns HTTPResponse.Status
func (r UpdateCustomPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceGroupResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r CreateResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceGroupResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceGroupResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
}

// Status returns HTTPResponse.Status
func (r CreateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
}

// Status returns HTTPResponse.Status
func (r UpdateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleSetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetTemplateResponse
}

// Status returns HTTPResponse.Status
func (r CreateRuleSetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleSetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleSetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRuleSetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleSetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleSetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetTemplateResponse
}

// Status returns HTTPResponse.Status
func (r GetRuleSetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleSetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleSetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetTemplateResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRuleSetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleSetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetResponse
}

// Status returns HTTPResponse.Status
func (r CreateRuleSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRuleSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetResponse
}

// Status returns HTTPResponse.Status
func (r GetRuleSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSetResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRuleSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSaleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sale
}

// Status returns HTTPResponse.Status
func (r CreateSaleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSaleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSaleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSaleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSaleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSaleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sale
}

// Status returns HTTPResponse.Status
func (r GetSaleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSaleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSaleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sale
}

// Status returns HTTPResponse.Status
func (r UpdateSaleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSaleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefundMarketplaceSaleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *RefundMarketplaceSaleError
}

// Status returns HTTPResponse.Status
func (r RefundMarketplaceSaleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefundMarketplaceSaleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendTransactionReceiptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendTransactionReceiptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendTransactionReceiptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeprecatedListSubtransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subtransactions
}

// Status returns HTTPResponse.Status
func (r DeprecatedListSubtransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeprecatedListSubtransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeprecatedGetSubtransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subtransaction
}

// Status returns HTTPResponse.Status
func (r DeprecatedGetSubtransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeprecatedGetSubtransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Space
}

// Status returns HTTPResponse.Status
func (r CreateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Space
}

// Status returns HTTPResponse.Status
func (r GetSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Space
}

// Status returns HTTPResponse.Status
func (r UpdateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamBlockedTimesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamBlockedTimesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamBlockedTimesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamEmployeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamEmployeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamEmployeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamEventTypeGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamEventTypeGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamEventTypeGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamEventTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamEventTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamEventTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamSalesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamSalesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamSalesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamProductGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamProductGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamProductGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamSpacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamSpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamSpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamTimeSlotReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StreamTimeSlotReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamTimeSlotReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingInvoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetBillingInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PowerupSubscription
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PowerupSubscription
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubtransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subtransaction
}

// Status returns HTTPResponse.Status
func (r CreateSubtransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubtransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubtransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubtransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubtransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubtransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subtransaction
}

// Status returns HTTPResponse.Status
func (r GetSubtransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubtransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTerminalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTerminalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTerminalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTerminalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Terminal
}

// Status returns HTTPResponse.Status
func (r GetTerminalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTerminalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTerminalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Terminal
}

// Status returns HTTPResponse.Status
func (r UpdateTerminalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTerminalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOAuthConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOAuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOAuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOAuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOAuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostOAuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOAuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimeSlotReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TimeSlotReservation
}

// Status returns HTTPResponse.Status
func (r GetTimeSlotReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimeSlotReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckinToken
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
}

// Status returns HTTPResponse.Status
func (r CreateTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
}

// Status returns HTTPResponse.Status
func (r UpdateTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLineItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LineItems
}

// Status returns HTTPResponse.Status
func (r ListLineItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLineItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubtransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subtransactions
}

// Status returns HTTPResponse.Status
func (r ListSubtransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubtransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGoogleCalendarConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGoogleCalendarConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGoogleCalendarConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoogleCalendarConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GoogleCalendarConnection
}

// Status returns HTTPResponse.Status
func (r GetGoogleCalendarConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoogleCalendarConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGoogleCalendarConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GoogleCalendarConnection
}

// Status returns HTTPResponse.Status
func (r CreateGoogleCalendarConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGoogleCalendarConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserOAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserOAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserOAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserSettlementAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SettlementAccounts
}

// Status returns HTTPResponse.Status
func (r ListUserSettlementAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserSettlementAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserTerminalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Terminals
}

// Status returns HTTPResponse.Status
func (r ListUserTerminalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserTerminalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserTerminalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserTerminalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserTerminalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTerminalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Terminal
}

// Status returns HTTPResponse.Status
func (r GetUserTerminalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTerminalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tokens
}

// Status returns HTTPResponse.Status
func (r ListUserTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Token
}

// Status returns HTTPResponse.Status
func (r CreateUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Token
}

// Status returns HTTPResponse.Status
func (r GetUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVoucherTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoucherTemplateResponse
}

// Status returns HTTPResponse.Status
func (r CreateVoucherTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVoucherTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVoucherTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVoucherTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVoucherTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVoucherTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoucherTemplateResponse
}

// Status returns HTTPResponse.Status
func (r UpdateVoucherTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVoucherTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVoucherResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVoucherResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVoucherResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoucherResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Voucher
}

// Status returns HTTPResponse.Status
func (r GetVoucherResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoucherResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVoucherResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Voucher
}

// Status returns HTTPResponse.Status
func (r UpdateVoucherResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVoucherResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVoucherNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateVoucherNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVoucherNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWaitlistEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WaitlistEntryResponse
}

// Status returns HTTPResponse.Status
func (r CreateWaitlistEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWaitlistEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWaitlistEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWaitlistEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWaitlistEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWaitlistEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WaitlistEntryResponse
}

// Status returns HTTPResponse.Status
func (r GetWaitlistEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWaitlistEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWaitlistEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WaitlistEntryResponse
}

// Status returns HTTPResponse.Status
func (r UpdateWaitlistEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWaitlistEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookInvocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookInvocation
}

// Status returns HTTPResponse.Status
func (r GetWebhookInvocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookInvocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookInvocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookInvocation
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookInvocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookInvocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhook
}

// Status returns HTTPResponse.Status
func (r CreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWebhookEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookEvents
}

// Status returns HTTPResponse.Status
func (r ListWebhookEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhook
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhook
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListCustomerActivitiesWithResponse request returning *ListCustomerActivitiesResponse
func (c *ClientWithResponses) ListCustomerActivitiesWithResponse(ctx context.Context, customerId string, params *ListCustomerActivitiesParams, reqEditors ...RequestEditorFn) (*ListCustomerActivitiesResponse, error) {
	rsp, err := c.ListCustomerActivities(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomerActivitiesResponse(rsp)
}

// ListEventTypeActivitiesWithResponse request returning *ListEventTypeActivitiesResponse
func (c *ClientWithResponses) ListEventTypeActivitiesWithResponse(ctx context.Context, eventTypeId string, params *ListEventTypeActivitiesParams, reqEditors ...RequestEditorFn) (*ListEventTypeActivitiesResponse, error) {
	rsp, err := c.ListEventTypeActivities(ctx, eventTypeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventTypeActivitiesResponse(rsp)
}

// ListEventActivitiesWithResponse request returning *ListEventActivitiesResponse
func (c *ClientWithResponses) ListEventActivitiesWithResponse(ctx context.Context, eventId string, params *ListEventActivitiesParams, reqEditors ...RequestEditorFn) (*ListEventActivitiesResponse, error) {
	rsp, err := c.ListEventActivities(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventActivitiesResponse(rsp)
}

// ListPaymentActivitiesWithResponse request returning *ListPaymentActivitiesResponse
func (c *ClientWithResponses) ListPaymentActivitiesWithResponse(ctx context.Context, paymentId string, params *ListPaymentActivitiesParams, reqEditors ...RequestEditorFn) (*ListPaymentActivitiesResponse, error) {
	rsp, err := c.ListPaymentActivities(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentActivitiesResponse(rsp)
}

// CreateBlockedTimeWithBodyWithResponse request with arbitrary body returning *CreateBlockedTimeResponse
func (c *ClientWithResponses) CreateBlockedTimeWithBodyWithResponse(ctx context.Context, params *CreateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlockedTimeResponse, error) {
	rsp, err := c.CreateBlockedTimeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlockedTimeResponse(rsp)
}

func (c *ClientWithResponses) CreateBlockedTimeWithResponse(ctx context.Context, params *CreateBlockedTimeParams, body CreateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlockedTimeResponse, error) {
	rsp, err := c.CreateBlockedTime(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlockedTimeResponse(rsp)
}

// DeleteBlockedTimeWithResponse request returning *DeleteBlockedTimeResponse
func (c *ClientWithResponses) DeleteBlockedTimeWithResponse(ctx context.Context, blockedTimeId string, params *DeleteBlockedTimeParams, reqEditors ...RequestEditorFn) (*DeleteBlockedTimeResponse, error) {
	rsp, err := c.DeleteBlockedTime(ctx, blockedTimeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBlockedTimeResponse(rsp)
}

// GetBlockedTimeWithResponse request returning *GetBlockedTimeResponse
func (c *ClientWithResponses) GetBlockedTimeWithResponse(ctx context.Context, blockedTimeId string, params *GetBlockedTimeParams, reqEditors ...RequestEditorFn) (*GetBlockedTimeResponse, error) {
	rsp, err := c.GetBlockedTime(ctx, blockedTimeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockedTimeResponse(rsp)
}

// UpdateBlockedTimeWithBodyWithResponse request with arbitrary body returning *UpdateBlockedTimeResponse
func (c *ClientWithResponses) UpdateBlockedTimeWithBodyWithResponse(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBlockedTimeResponse, error) {
	rsp, err := c.UpdateBlockedTimeWithBody(ctx, blockedTimeId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBlockedTimeResponse(rsp)
}

func (c *ClientWithResponses) UpdateBlockedTimeWithResponse(ctx context.Context, blockedTimeId string, params *UpdateBlockedTimeParams, body UpdateBlockedTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBlockedTimeResponse, error) {
	rsp, err := c.UpdateBlockedTime(ctx, blockedTimeId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBlockedTimeResponse(rsp)
}

// GetCompaniesWithResponse request returning *GetCompaniesResponse
func (c *ClientWithResponses) GetCompaniesWithResponse(ctx context.Context, params *GetCompaniesParams, reqEditors ...RequestEditorFn) (*GetCompaniesResponse, error) {
	rsp, err := c.GetCompanies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompaniesResponse(rsp)
}

// CreateCompanyWithBodyWithResponse request with arbitrary body returning *CreateCompanyResponse
func (c *ClientWithResponses) CreateCompanyWithBodyWithResponse(ctx context.Context, params *CreateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCompanyResponse, error) {
	rsp, err := c.CreateCompanyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCompanyResponse(rsp)
}

func (c *ClientWithResponses) CreateCompanyWithResponse(ctx context.Context, params *CreateCompanyParams, body CreateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCompanyResponse, error) {
	rsp, err := c.CreateCompany(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCompanyResponse(rsp)
}

// GetCompanyWithResponse request returning *GetCompanyResponse
func (c *ClientWithResponses) GetCompanyWithResponse(ctx context.Context, companyId string, params *GetCompanyParams, reqEditors ...RequestEditorFn) (*GetCompanyResponse, error) {
	rsp, err := c.GetCompany(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyResponse(rsp)
}

// UpdateCompanyWithBodyWithResponse request with arbitrary body returning *UpdateCompanyResponse
func (c *ClientWithResponses) UpdateCompanyWithBodyWithResponse(ctx context.Context, companyId string, params *UpdateCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCompanyResponse, error) {
	rsp, err := c.UpdateCompanyWithBody(ctx, companyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCompanyResponse(rsp)
}

func (c *ClientWithResponses) UpdateCompanyWithResponse(ctx context.Context, companyId string, params *UpdateCompanyParams, body UpdateCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCompanyResponse, error) {
	rsp, err := c.UpdateCompany(ctx, companyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCompanyResponse(rsp)
}

// ListAllCompanyActivitiesWithResponse request returning *ListAllCompanyActivitiesResponse
func (c *ClientWithResponses) ListAllCompanyActivitiesWithResponse(ctx context.Context, companyId string, params *ListAllCompanyActivitiesParams, reqEditors ...RequestEditorFn) (*ListAllCompanyActivitiesResponse, error) {
	rsp, err := c.ListAllCompanyActivities(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllCompanyActivitiesResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, companyId string, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, companyId string, appId string, params *GetAppParams, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, companyId, appId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// DisableAppWithResponse request returning *DisableAppResponse
func (c *ClientWithResponses) DisableAppWithResponse(ctx context.Context, companyId string, appId string, reqEditors ...RequestEditorFn) (*DisableAppResponse, error) {
	rsp, err := c.DisableApp(ctx, companyId, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableAppResponse(rsp)
}

// ListBlockedTimesWithResponse request returning *ListBlockedTimesResponse
func (c *ClientWithResponses) ListBlockedTimesWithResponse(ctx context.Context, companyId string, params *ListBlockedTimesParams, reqEditors ...RequestEditorFn) (*ListBlockedTimesResponse, error) {
	rsp, err := c.ListBlockedTimes(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBlockedTimesResponse(rsp)
}

// ListClaimsWithResponse request returning *ListClaimsResponse
func (c *ClientWithResponses) ListClaimsWithResponse(ctx context.Context, companyId string, params *ListClaimsParams, reqEditors ...RequestEditorFn) (*ListClaimsResponse, error) {
	rsp, err := c.ListClaims(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClaimsResponse(rsp)
}

// ListCustomerGroupsWithResponse request returning *ListCustomerGroupsResponse
func (c *ClientWithResponses) ListCustomerGroupsWithResponse(ctx context.Context, companyId string, params *ListCustomerGroupsParams, reqEditors ...RequestEditorFn) (*ListCustomerGroupsResponse, error) {
	rsp, err := c.ListCustomerGroups(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomerGroupsResponse(rsp)
}

// ListCustomersWithResponse request returning *ListCustomersResponse
func (c *ClientWithResponses) ListCustomersWithResponse(ctx context.Context, companyId string, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error) {
	rsp, err := c.ListCustomers(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomersResponse(rsp)
}

// ListEmployeesWithResponse request returning *ListEmployeesResponse
func (c *ClientWithResponses) ListEmployeesWithResponse(ctx context.Context, companyId string, params *ListEmployeesParams, reqEditors ...RequestEditorFn) (*ListEmployeesResponse, error) {
	rsp, err := c.ListEmployees(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEmployeesResponse(rsp)
}

// DeleteEmployeeWithResponse request returning *DeleteEmployeeResponse
func (c *ClientWithResponses) DeleteEmployeeWithResponse(ctx context.Context, companyId string, employeeId string, params *DeleteEmployeeParams, reqEditors ...RequestEditorFn) (*DeleteEmployeeResponse, error) {
	rsp, err := c.DeleteEmployee(ctx, companyId, employeeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEmployeeResponse(rsp)
}

// GetEmployeeWithResponse request returning *GetEmployeeResponse
func (c *ClientWithResponses) GetEmployeeWithResponse(ctx context.Context, companyId string, employeeId string, params *GetEmployeeParams, reqEditors ...RequestEditorFn) (*GetEmployeeResponse, error) {
	rsp, err := c.GetEmployee(ctx, companyId, employeeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeeResponse(rsp)
}

// UpdateEmployeeWithBodyWithResponse request with arbitrary body returning *UpdateEmployeeResponse
func (c *ClientWithResponses) UpdateEmployeeWithBodyWithResponse(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error) {
	rsp, err := c.UpdateEmployeeWithBody(ctx, companyId, employeeId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmployeeResponse(rsp)
}

func (c *ClientWithResponses) UpdateEmployeeWithResponse(ctx context.Context, companyId string, employeeId string, params *UpdateEmployeeParams, body UpdateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEmployeeResponse, error) {
	rsp, err := c.UpdateEmployee(ctx, companyId, employeeId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEmployeeResponse(rsp)
}

// ListEventStatusesWithResponse request returning *ListEventStatusesResponse
func (c *ClientWithResponses) ListEventStatusesWithResponse(ctx context.Context, companyId string, params *ListEventStatusesParams, reqEditors ...RequestEditorFn) (*ListEventStatusesResponse, error) {
	rsp, err := c.ListEventStatuses(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventStatusesResponse(rsp)
}

// ListEventTypeCategoriesWithResponse request returning *ListEventTypeCategoriesResponse
func (c *ClientWithResponses) ListEventTypeCategoriesWithResponse(ctx context.Context, companyId string, params *ListEventTypeCategoriesParams, reqEditors ...RequestEditorFn) (*ListEventTypeCategoriesResponse, error) {
	rsp, err := c.ListEventTypeCategories(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventTypeCategoriesResponse(rsp)
}

// ListEventTypeCategoryGroupsWithResponse request returning *ListEventTypeCategoryGroupsResponse
func (c *ClientWithResponses) ListEventTypeCategoryGroupsWithResponse(ctx context.Context, companyId string, params *ListEventTypeCategoryGroupsParams, reqEditors ...RequestEditorFn) (*ListEventTypeCategoryGroupsResponse, error) {
	rsp, err := c.ListEventTypeCategoryGroups(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventTypeCategoryGroupsResponse(rsp)
}

// ListEventTypeGroupsWithResponse request returning *ListEventTypeGroupsResponse
func (c *ClientWithResponses) ListEventTypeGroupsWithResponse(ctx context.Context, companyId string, params *ListEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*ListEventTypeGroupsResponse, error) {
	rsp, err := c.ListEventTypeGroups(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventTypeGroupsResponse(rsp)
}

// ListEventTypesWithResponse request returning *ListEventTypesResponse
func (c *ClientWithResponses) ListEventTypesWithResponse(ctx context.Context, companyId string, params *ListEventTypesParams, reqEditors ...RequestEditorFn) (*ListEventTypesResponse, error) {
	rsp, err := c.ListEventTypes(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventTypesResponse(rsp)
}

// ListEventsWithResponse request returning *ListEventsResponse
func (c *ClientWithResponses) ListEventsWithResponse(ctx context.Context, companyId string, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error) {
	rsp, err := c.ListEvents(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsResponse(rsp)
}

// CheckinWithPaymentWithResponse request returning *CheckinWithPaymentResponse
func (c *ClientWithResponses) CheckinWithPaymentWithResponse(ctx context.Context, companyId string, id string, params *CheckinWithPaymentParams, reqEditors ...RequestEditorFn) (*CheckinWithPaymentResponse, error) {
	rsp, err := c.CheckinWithPayment(ctx, companyId, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckinWithPaymentResponse(rsp)
}

// ListHolidaysWithResponse request returning *ListHolidaysResponse
func (c *ClientWithResponses) ListHolidaysWithResponse(ctx context.Context, companyId string, params *ListHolidaysParams, reqEditors ...RequestEditorFn) (*ListHolidaysResponse, error) {
	rsp, err := c.ListHolidays(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHolidaysResponse(rsp)
}

// ListIssuersWithResponse request returning *ListIssuersResponse
func (c *ClientWithResponses) ListIssuersWithResponse(ctx context.Context, companyId string, params *ListIssuersParams, reqEditors ...RequestEditorFn) (*ListIssuersResponse, error) {
	rsp, err := c.ListIssuers(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIssuersResponse(rsp)
}

// ListMemosWithResponse request returning *ListMemosResponse
func (c *ClientWithResponses) ListMemosWithResponse(ctx context.Context, companyId string, params *ListMemosParams, reqEditors ...RequestEditorFn) (*ListMemosResponse, error) {
	rsp, err := c.ListMemos(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMemosResponse(rsp)
}

// GetSalesMetricsWithResponse request returning *GetSalesMetricsResponse
func (c *ClientWithResponses) GetSalesMetricsWithResponse(ctx context.Context, companyId string, params *GetSalesMetricsParams, reqEditors ...RequestEditorFn) (*GetSalesMetricsResponse, error) {
	rsp, err := c.GetSalesMetrics(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSalesMetricsResponse(rsp)
}

// DeleteNotificationsWithResponse request returning *DeleteNotificationsResponse
func (c *ClientWithResponses) DeleteNotificationsWithResponse(ctx context.Context, companyId string, params *DeleteNotificationsParams, reqEditors ...RequestEditorFn) (*DeleteNotificationsResponse, error) {
	rsp, err := c.DeleteNotifications(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationsResponse(rsp)
}

// ListNotificationsWithResponse request returning *ListNotificationsResponse
func (c *ClientWithResponses) ListNotificationsWithResponse(ctx context.Context, companyId string, params *ListNotificationsParams, reqEditors ...RequestEditorFn) (*ListNotificationsResponse, error) {
	rsp, err := c.ListNotifications(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNotificationsResponse(rsp)
}

// ListOpeningHoursWithResponse request returning *ListOpeningHoursResponse
func (c *ClientWithResponses) ListOpeningHoursWithResponse(ctx context.Context, companyId string, params *ListOpeningHoursParams, reqEditors ...RequestEditorFn) (*ListOpeningHoursResponse, error) {
	rsp, err := c.ListOpeningHours(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOpeningHoursResponse(rsp)
}

// ListPaymentsWithResponse request returning *ListPaymentsResponse
func (c *ClientWithResponses) ListPaymentsWithResponse(ctx context.Context, companyId string, params *ListPaymentsParams, reqEditors ...RequestEditorFn) (*ListPaymentsResponse, error) {
	rsp, err := c.ListPayments(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentsResponse(rsp)
}

// ListCustomPropertiesWithResponse request returning *ListCustomPropertiesResponse
func (c *ClientWithResponses) ListCustomPropertiesWithResponse(ctx context.Context, companyId string, params *ListCustomPropertiesParams, reqEditors ...RequestEditorFn) (*ListCustomPropertiesResponse, error) {
	rsp, err := c.ListCustomProperties(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomPropertiesResponse(rsp)
}

// ListResourceGroupsWithResponse request returning *ListResourceGroupsResponse
func (c *ClientWithResponses) ListResourceGroupsWithResponse(ctx context.Context, companyId string, params *ListResourceGroupsParams, reqEditors ...RequestEditorFn) (*ListResourceGroupsResponse, error) {
	rsp, err := c.ListResourceGroups(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceGroupsResponse(rsp)
}

// ListResourcesWithResponse request returning *ListResourcesResponse
func (c *ClientWithResponses) ListResourcesWithResponse(ctx context.Context, companyId string, params *ListResourcesParams, reqEditors ...RequestEditorFn) (*ListResourcesResponse, error) {
	rsp, err := c.ListResources(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourcesResponse(rsp)
}

// ListRuleSetTemplatesWithResponse request returning *ListRuleSetTemplatesResponse
func (c *ClientWithResponses) ListRuleSetTemplatesWithResponse(ctx context.Context, companyId string, params *ListRuleSetTemplatesParams, reqEditors ...RequestEditorFn) (*ListRuleSetTemplatesResponse, error) {
	rsp, err := c.ListRuleSetTemplates(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleSetTemplatesResponse(rsp)
}

// ListRuleSetsWithResponse request returning *ListRuleSetsResponse
func (c *ClientWithResponses) ListRuleSetsWithResponse(ctx context.Context, companyId string, params *ListRuleSetsParams, reqEditors ...RequestEditorFn) (*ListRuleSetsResponse, error) {
	rsp, err := c.ListRuleSets(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleSetsResponse(rsp)
}

// ListSalesWithResponse request returning *ListSalesResponse
func (c *ClientWithResponses) ListSalesWithResponse(ctx context.Context, companyId string, params *ListSalesParams, reqEditors ...RequestEditorFn) (*ListSalesResponse, error) {
	rsp, err := c.ListSales(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSalesResponse(rsp)
}

// ListSettlementsWithResponse request returning *ListSettlementsResponse
func (c *ClientWithResponses) ListSettlementsWithResponse(ctx context.Context, companyId string, params *ListSettlementsParams, reqEditors ...RequestEditorFn) (*ListSettlementsResponse, error) {
	rsp, err := c.ListSettlements(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSettlementsResponse(rsp)
}

// ListSMSMessagesWithResponse request returning *ListSMSMessagesResponse
func (c *ClientWithResponses) ListSMSMessagesWithResponse(ctx context.Context, companyId string, params *ListSMSMessagesParams, reqEditors ...RequestEditorFn) (*ListSMSMessagesResponse, error) {
	rsp, err := c.ListSMSMessages(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSMSMessagesResponse(rsp)
}

// ListSpacesWithResponse request returning *ListSpacesResponse
func (c *ClientWithResponses) ListSpacesWithResponse(ctx context.Context, companyId string, params *ListSpacesParams, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error) {
	rsp, err := c.ListSpaces(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, companyId string, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, companyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionWithResponse(ctx context.Context, companyId string, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscription(ctx, companyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// GetSubscriptionBillingInfoWithResponse request returning *GetSubscriptionBillingInfoResponse
func (c *ClientWithResponses) GetSubscriptionBillingInfoWithResponse(ctx context.Context, companyId string, params *GetSubscriptionBillingInfoParams, reqEditors ...RequestEditorFn) (*GetSubscriptionBillingInfoResponse, error) {
	rsp, err := c.GetSubscriptionBillingInfo(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionBillingInfoResponse(rsp)
}

// UpdateBillingInfoWithBodyWithResponse request with arbitrary body returning *UpdateBillingInfoResponse
func (c *ClientWithResponses) UpdateBillingInfoWithBodyWithResponse(ctx context.Context, companyId string, params *UpdateBillingInfoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingInfoResponse, error) {
	rsp, err := c.UpdateBillingInfoWithBody(ctx, companyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingInfoResponse(rsp)
}

func (c *ClientWithResponses) UpdateBillingInfoWithResponse(ctx context.Context, companyId string, params *UpdateBillingInfoParams, body UpdateBillingInfoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingInfoResponse, error) {
	rsp, err := c.UpdateBillingInfo(ctx, companyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingInfoResponse(rsp)
}

// ListBillingInvoicesWithResponse request returning *ListBillingInvoicesResponse
func (c *ClientWithResponses) ListBillingInvoicesWithResponse(ctx context.Context, companyId string, params *ListBillingInvoicesParams, reqEditors ...RequestEditorFn) (*ListBillingInvoicesResponse, error) {
	rsp, err := c.ListBillingInvoices(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingInvoicesResponse(rsp)
}

// CreatePaymentIntentWithResponse request returning *CreatePaymentIntentResponse
func (c *ClientWithResponses) CreatePaymentIntentWithResponse(ctx context.Context, companyId string, params *CreatePaymentIntentParams, reqEditors ...RequestEditorFn) (*CreatePaymentIntentResponse, error) {
	rsp, err := c.CreatePaymentIntent(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentIntentResponse(rsp)
}

// ListTerminalsWithResponse request returning *ListTerminalsResponse
func (c *ClientWithResponses) ListTerminalsWithResponse(ctx context.Context, companyId string, params *ListTerminalsParams, reqEditors ...RequestEditorFn) (*ListTerminalsResponse, error) {
	rsp, err := c.ListTerminals(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTerminalsResponse(rsp)
}

// ListTimeSlotReservationsWithResponse request returning *ListTimeSlotReservationsResponse
func (c *ClientWithResponses) ListTimeSlotReservationsWithResponse(ctx context.Context, companyId string, params *ListTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*ListTimeSlotReservationsResponse, error) {
	rsp, err := c.ListTimeSlotReservations(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTimeSlotReservationsResponse(rsp)
}

// ListTimeSlotsWithResponse request returning *ListTimeSlotsResponse
func (c *ClientWithResponses) ListTimeSlotsWithResponse(ctx context.Context, companyId string, params *ListTimeSlotsParams, reqEditors ...RequestEditorFn) (*ListTimeSlotsResponse, error) {
	rsp, err := c.ListTimeSlots(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTimeSlotsResponse(rsp)
}

// ListTransactionsWithResponse request returning *ListTransactionsResponse
func (c *ClientWithResponses) ListTransactionsWithResponse(ctx context.Context, companyId string, params *ListTransactionsParams, reqEditors ...RequestEditorFn) (*ListTransactionsResponse, error) {
	rsp, err := c.ListTransactions(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTransactionsResponse(rsp)
}

// ListVATsWithResponse request returning *ListVATsResponse
func (c *ClientWithResponses) ListVATsWithResponse(ctx context.Context, companyId string, params *ListVATsParams, reqEditors ...RequestEditorFn) (*ListVATsResponse, error) {
	rsp, err := c.ListVATs(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVATsResponse(rsp)
}

// ListVoucherTemplatesWithResponse request returning *ListVoucherTemplatesResponse
func (c *ClientWithResponses) ListVoucherTemplatesWithResponse(ctx context.Context, companyId string, params *ListVoucherTemplatesParams, reqEditors ...RequestEditorFn) (*ListVoucherTemplatesResponse, error) {
	rsp, err := c.ListVoucherTemplates(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVoucherTemplatesResponse(rsp)
}

// ListVouchersWithResponse request returning *ListVouchersResponse
func (c *ClientWithResponses) ListVouchersWithResponse(ctx context.Context, companyId string, params *ListVouchersParams, reqEditors ...RequestEditorFn) (*ListVouchersResponse, error) {
	rsp, err := c.ListVouchers(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVouchersResponse(rsp)
}

// ListWaitlistEntriesWithResponse request returning *ListWaitlistEntriesResponse
func (c *ClientWithResponses) ListWaitlistEntriesWithResponse(ctx context.Context, companyId string, params *ListWaitlistEntriesParams, reqEditors ...RequestEditorFn) (*ListWaitlistEntriesResponse, error) {
	rsp, err := c.ListWaitlistEntries(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWaitlistEntriesResponse(rsp)
}

// ListWebhookInvocationsWithResponse request returning *ListWebhookInvocationsResponse
func (c *ClientWithResponses) ListWebhookInvocationsWithResponse(ctx context.Context, companyId string, params *ListWebhookInvocationsParams, reqEditors ...RequestEditorFn) (*ListWebhookInvocationsResponse, error) {
	rsp, err := c.ListWebhookInvocations(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhookInvocationsResponse(rsp)
}

// ListWebhooksWithResponse request returning *ListWebhooksResponse
func (c *ClientWithResponses) ListWebhooksWithResponse(ctx context.Context, companyId string, params *ListWebhooksParams, reqEditors ...RequestEditorFn) (*ListWebhooksResponse, error) {
	rsp, err := c.ListWebhooks(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhooksResponse(rsp)
}

// CreateCustomerGroupWithBodyWithResponse request with arbitrary body returning *CreateCustomerGroupResponse
func (c *ClientWithResponses) CreateCustomerGroupWithBodyWithResponse(ctx context.Context, params *CreateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerGroupResponse, error) {
	rsp, err := c.CreateCustomerGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomerGroupWithResponse(ctx context.Context, params *CreateCustomerGroupParams, body CreateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerGroupResponse, error) {
	rsp, err := c.CreateCustomerGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerGroupResponse(rsp)
}

// DeleteCustomerGroupWithResponse request returning *DeleteCustomerGroupResponse
func (c *ClientWithResponses) DeleteCustomerGroupWithResponse(ctx context.Context, customerGroupId string, params *DeleteCustomerGroupParams, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupResponse, error) {
	rsp, err := c.DeleteCustomerGroup(ctx, customerGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerGroupResponse(rsp)
}

// GetCustomerGroupWithResponse request returning *GetCustomerGroupResponse
func (c *ClientWithResponses) GetCustomerGroupWithResponse(ctx context.Context, customerGroupId string, params *GetCustomerGroupParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupResponse, error) {
	rsp, err := c.GetCustomerGroup(ctx, customerGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerGroupResponse(rsp)
}

// UpdateCustomerGroupWithBodyWithResponse request with arbitrary body returning *UpdateCustomerGroupResponse
func (c *ClientWithResponses) UpdateCustomerGroupWithBodyWithResponse(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerGroupResponse, error) {
	rsp, err := c.UpdateCustomerGroupWithBody(ctx, customerGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerGroupWithResponse(ctx context.Context, customerGroupId string, params *UpdateCustomerGroupParams, body UpdateCustomerGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerGroupResponse, error) {
	rsp, err := c.UpdateCustomerGroup(ctx, customerGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerGroupResponse(rsp)
}

// CreateCustomerWithBodyWithResponse request with arbitrary body returning *CreateCustomerResponse
func (c *ClientWithResponses) CreateCustomerWithBodyWithResponse(ctx context.Context, params *CreateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomerWithResponse(ctx context.Context, params *CreateCustomerParams, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

// DeleteCustomerWithResponse request returning *DeleteCustomerResponse
func (c *ClientWithResponses) DeleteCustomerWithResponse(ctx context.Context, customerId string, params *DeleteCustomerParams, reqEditors ...RequestEditorFn) (*DeleteCustomerResponse, error) {
	rsp, err := c.DeleteCustomer(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerResponse(rsp)
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, customerId string, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerResponse(rsp)
}

// UpdateCustomerWithBodyWithResponse request with arbitrary body returning *UpdateCustomerResponse
func (c *ClientWithResponses) UpdateCustomerWithBodyWithResponse(ctx context.Context, customerId string, params *UpdateCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomerWithBody(ctx, customerId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerWithResponse(ctx context.Context, customerId string, params *UpdateCustomerParams, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomer(ctx, customerId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

// CreateEmployeeWithBodyWithResponse request with arbitrary body returning *CreateEmployeeResponse
func (c *ClientWithResponses) CreateEmployeeWithBodyWithResponse(ctx context.Context, params *CreateEmployeeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmployeeResponse, error) {
	rsp, err := c.CreateEmployeeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmployeeResponse(rsp)
}

func (c *ClientWithResponses) CreateEmployeeWithResponse(ctx context.Context, params *CreateEmployeeParams, body CreateEmployeeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmployeeResponse, error) {
	rsp, err := c.CreateEmployee(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmployeeResponse(rsp)
}

// GetEnterpriseWithResponse request returning *GetEnterpriseResponse
func (c *ClientWithResponses) GetEnterpriseWithResponse(ctx context.Context, params *GetEnterpriseParams, reqEditors ...RequestEditorFn) (*GetEnterpriseResponse, error) {
	rsp, err := c.GetEnterprise(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseResponse(rsp)
}

// UpdateEnterpriseWithBodyWithResponse request with arbitrary body returning *UpdateEnterpriseResponse
func (c *ClientWithResponses) UpdateEnterpriseWithBodyWithResponse(ctx context.Context, params *UpdateEnterpriseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnterpriseResponse, error) {
	rsp, err := c.UpdateEnterpriseWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnterpriseWithResponse(ctx context.Context, params *UpdateEnterpriseParams, body UpdateEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnterpriseResponse, error) {
	rsp, err := c.UpdateEnterprise(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnterpriseResponse(rsp)
}

// ListEnterpriseCompaniesWithResponse request returning *ListEnterpriseCompaniesResponse
func (c *ClientWithResponses) ListEnterpriseCompaniesWithResponse(ctx context.Context, enterpriseId string, params *ListEnterpriseCompaniesParams, reqEditors ...RequestEditorFn) (*ListEnterpriseCompaniesResponse, error) {
	rsp, err := c.ListEnterpriseCompanies(ctx, enterpriseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnterpriseCompaniesResponse(rsp)
}

// ListPaymentsLegacyWithResponse request returning *ListPaymentsLegacyResponse
func (c *ClientWithResponses) ListPaymentsLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListPaymentsLegacyParams, reqEditors ...RequestEditorFn) (*ListPaymentsLegacyResponse, error) {
	rsp, err := c.ListPaymentsLegacy(ctx, enterpriseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentsLegacyResponse(rsp)
}

// ListEnterpriseSettlementAccountsWithResponse request returning *ListEnterpriseSettlementAccountsResponse
func (c *ClientWithResponses) ListEnterpriseSettlementAccountsWithResponse(ctx context.Context, enterpriseId string, params *ListEnterpriseSettlementAccountsParams, reqEditors ...RequestEditorFn) (*ListEnterpriseSettlementAccountsResponse, error) {
	rsp, err := c.ListEnterpriseSettlementAccounts(ctx, enterpriseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEnterpriseSettlementAccountsResponse(rsp)
}

// DeleteEnterpriseSettlementAccountWithResponse request returning *DeleteEnterpriseSettlementAccountResponse
func (c *ClientWithResponses) DeleteEnterpriseSettlementAccountWithResponse(ctx context.Context, enterpriseId string, settlementAccountId string, params *DeleteEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*DeleteEnterpriseSettlementAccountResponse, error) {
	rsp, err := c.DeleteEnterpriseSettlementAccount(ctx, enterpriseId, settlementAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnterpriseSettlementAccountResponse(rsp)
}

// GetEnterpriseSettlementAccountWithResponse request returning *GetEnterpriseSettlementAccountResponse
func (c *ClientWithResponses) GetEnterpriseSettlementAccountWithResponse(ctx context.Context, enterpriseId string, settlementAccountId string, params *GetEnterpriseSettlementAccountParams, reqEditors ...RequestEditorFn) (*GetEnterpriseSettlementAccountResponse, error) {
	rsp, err := c.GetEnterpriseSettlementAccount(ctx, enterpriseId, settlementAccountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnterpriseSettlementAccountResponse(rsp)
}

// ListSettlementsLegacyWithResponse request returning *ListSettlementsLegacyResponse
func (c *ClientWithResponses) ListSettlementsLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListSettlementsLegacyParams, reqEditors ...RequestEditorFn) (*ListSettlementsLegacyResponse, error) {
	rsp, err := c.ListSettlementsLegacy(ctx, enterpriseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSettlementsLegacyResponse(rsp)
}

// ListVoucherTemplatesLegacyWithResponse request returning *ListVoucherTemplatesLegacyResponse
func (c *ClientWithResponses) ListVoucherTemplatesLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListVoucherTemplatesLegacyParams, reqEditors ...RequestEditorFn) (*ListVoucherTemplatesLegacyResponse, error) {
	rsp, err := c.ListVoucherTemplatesLegacy(ctx, enterpriseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVoucherTemplatesLegacyResponse(rsp)
}

// CreateVoucherTemplateLegacyWithBodyWithResponse request with arbitrary body returning *CreateVoucherTemplateLegacyResponse
func (c *ClientWithResponses) CreateVoucherTemplateLegacyWithBodyWithResponse(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateLegacyResponse, error) {
	rsp, err := c.CreateVoucherTemplateLegacyWithBody(ctx, enterpriseId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVoucherTemplateLegacyResponse(rsp)
}

func (c *ClientWithResponses) CreateVoucherTemplateLegacyWithResponse(ctx context.Context, enterpriseId string, params *CreateVoucherTemplateLegacyParams, body CreateVoucherTemplateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateLegacyResponse, error) {
	rsp, err := c.CreateVoucherTemplateLegacy(ctx, enterpriseId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVoucherTemplateLegacyResponse(rsp)
}

// ListVouchersLegacyWithResponse request returning *ListVouchersLegacyResponse
func (c *ClientWithResponses) ListVouchersLegacyWithResponse(ctx context.Context, enterpriseId string, params *ListVouchersLegacyParams, reqEditors ...RequestEditorFn) (*ListVouchersLegacyResponse, error) {
	rsp, err := c.ListVouchersLegacy(ctx, enterpriseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVouchersLegacyResponse(rsp)
}

// GetVoucherLegacyWithResponse request returning *GetVoucherLegacyResponse
func (c *ClientWithResponses) GetVoucherLegacyWithResponse(ctx context.Context, enterpriseId string, voucherId string, params *GetVoucherLegacyParams, reqEditors ...RequestEditorFn) (*GetVoucherLegacyResponse, error) {
	rsp, err := c.GetVoucherLegacy(ctx, enterpriseId, voucherId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoucherLegacyResponse(rsp)
}

// UpdateVoucherLegacyWithBodyWithResponse request with arbitrary body returning *UpdateVoucherLegacyResponse
func (c *ClientWithResponses) UpdateVoucherLegacyWithBodyWithResponse(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVoucherLegacyResponse, error) {
	rsp, err := c.UpdateVoucherLegacyWithBody(ctx, enterpriseId, voucherId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVoucherLegacyResponse(rsp)
}

func (c *ClientWithResponses) UpdateVoucherLegacyWithResponse(ctx context.Context, enterpriseId string, voucherId string, params *UpdateVoucherLegacyParams, body UpdateVoucherLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVoucherLegacyResponse, error) {
	rsp, err := c.UpdateVoucherLegacy(ctx, enterpriseId, voucherId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVoucherLegacyResponse(rsp)
}

// CreateEventStatusWithBodyWithResponse request with arbitrary body returning *CreateEventStatusResponse
func (c *ClientWithResponses) CreateEventStatusWithBodyWithResponse(ctx context.Context, params *CreateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventStatusResponse, error) {
	rsp, err := c.CreateEventStatusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventStatusResponse(rsp)
}

func (c *ClientWithResponses) CreateEventStatusWithResponse(ctx context.Context, params *CreateEventStatusParams, body CreateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventStatusResponse, error) {
	rsp, err := c.CreateEventStatus(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventStatusResponse(rsp)
}

// DeleteEventStatusWithResponse request returning *DeleteEventStatusResponse
func (c *ClientWithResponses) DeleteEventStatusWithResponse(ctx context.Context, eventStatusId string, params *DeleteEventStatusParams, reqEditors ...RequestEditorFn) (*DeleteEventStatusResponse, error) {
	rsp, err := c.DeleteEventStatus(ctx, eventStatusId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEventStatusResponse(rsp)
}

// GetEventStatusWithResponse request returning *GetEventStatusResponse
func (c *ClientWithResponses) GetEventStatusWithResponse(ctx context.Context, eventStatusId string, params *GetEventStatusParams, reqEditors ...RequestEditorFn) (*GetEventStatusResponse, error) {
	rsp, err := c.GetEventStatus(ctx, eventStatusId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventStatusResponse(rsp)
}

// UpdateEventStatusWithBodyWithResponse request with arbitrary body returning *UpdateEventStatusResponse
func (c *ClientWithResponses) UpdateEventStatusWithBodyWithResponse(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventStatusResponse, error) {
	rsp, err := c.UpdateEventStatusWithBody(ctx, eventStatusId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdateEventStatusWithResponse(ctx context.Context, eventStatusId string, params *UpdateEventStatusParams, body UpdateEventStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventStatusResponse, error) {
	rsp, err := c.UpdateEventStatus(ctx, eventStatusId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventStatusResponse(rsp)
}

// GetEventTypeGroupWithResponse request returning *GetEventTypeGroupResponse
func (c *ClientWithResponses) GetEventTypeGroupWithResponse(ctx context.Context, eventTypeGroupId string, params *GetEventTypeGroupParams, reqEditors ...RequestEditorFn) (*GetEventTypeGroupResponse, error) {
	rsp, err := c.GetEventTypeGroup(ctx, eventTypeGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventTypeGroupResponse(rsp)
}

// CreateEventTypeWithBodyWithResponse request with arbitrary body returning *CreateEventTypeResponse
func (c *ClientWithResponses) CreateEventTypeWithBodyWithResponse(ctx context.Context, params *CreateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventTypeResponse, error) {
	rsp, err := c.CreateEventTypeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventTypeResponse(rsp)
}

func (c *ClientWithResponses) CreateEventTypeWithResponse(ctx context.Context, params *CreateEventTypeParams, body CreateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventTypeResponse, error) {
	rsp, err := c.CreateEventType(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventTypeResponse(rsp)
}

// DeleteEventTypeWithResponse request returning *DeleteEventTypeResponse
func (c *ClientWithResponses) DeleteEventTypeWithResponse(ctx context.Context, eventTypeId string, params *DeleteEventTypeParams, reqEditors ...RequestEditorFn) (*DeleteEventTypeResponse, error) {
	rsp, err := c.DeleteEventType(ctx, eventTypeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEventTypeResponse(rsp)
}

// GetEventTypeWithResponse request returning *GetEventTypeResponse
func (c *ClientWithResponses) GetEventTypeWithResponse(ctx context.Context, eventTypeId string, params *GetEventTypeParams, reqEditors ...RequestEditorFn) (*GetEventTypeResponse, error) {
	rsp, err := c.GetEventType(ctx, eventTypeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventTypeResponse(rsp)
}

// UpdateEventTypeWithBodyWithResponse request with arbitrary body returning *UpdateEventTypeResponse
func (c *ClientWithResponses) UpdateEventTypeWithBodyWithResponse(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventTypeResponse, error) {
	rsp, err := c.UpdateEventTypeWithBody(ctx, eventTypeId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateEventTypeWithResponse(ctx context.Context, eventTypeId string, params *UpdateEventTypeParams, body UpdateEventTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventTypeResponse, error) {
	rsp, err := c.UpdateEventType(ctx, eventTypeId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventTypeResponse(rsp)
}

// CreateEventWithBodyWithResponse request with arbitrary body returning *CreateEventResponse
func (c *ClientWithResponses) CreateEventWithBodyWithResponse(ctx context.Context, params *CreateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventResponse, error) {
	rsp, err := c.CreateEventWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventResponse(rsp)
}

func (c *ClientWithResponses) CreateEventWithResponse(ctx context.Context, params *CreateEventParams, body CreateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventResponse, error) {
	rsp, err := c.CreateEvent(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEventResponse(rsp)
}

// DeleteEventWithResponse request returning *DeleteEventResponse
func (c *ClientWithResponses) DeleteEventWithResponse(ctx context.Context, eventId string, params *DeleteEventParams, reqEditors ...RequestEditorFn) (*DeleteEventResponse, error) {
	rsp, err := c.DeleteEvent(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEventResponse(rsp)
}

// GetEventWithResponse request returning *GetEventResponse
func (c *ClientWithResponses) GetEventWithResponse(ctx context.Context, eventId string, params *GetEventParams, reqEditors ...RequestEditorFn) (*GetEventResponse, error) {
	rsp, err := c.GetEvent(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventResponse(rsp)
}

// UpdateEventWithBodyWithResponse request with arbitrary body returning *UpdateEventResponse
func (c *ClientWithResponses) UpdateEventWithBodyWithResponse(ctx context.Context, eventId string, params *UpdateEventParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error) {
	rsp, err := c.UpdateEventWithBody(ctx, eventId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventResponse(rsp)
}

func (c *ClientWithResponses) UpdateEventWithResponse(ctx context.Context, eventId string, params *UpdateEventParams, body UpdateEventJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEventResponse, error) {
	rsp, err := c.UpdateEvent(ctx, eventId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEventResponse(rsp)
}

// CreateCheckoutForEventWithResponse request returning *CreateCheckoutForEventResponse
func (c *ClientWithResponses) CreateCheckoutForEventWithResponse(ctx context.Context, eventId string, params *CreateCheckoutForEventParams, reqEditors ...RequestEditorFn) (*CreateCheckoutForEventResponse, error) {
	rsp, err := c.CreateCheckoutForEvent(ctx, eventId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCheckoutForEventResponse(rsp)
}

// DeleteCompanyFiscalizationDataWithResponse request returning *DeleteCompanyFiscalizationDataResponse
func (c *ClientWithResponses) DeleteCompanyFiscalizationDataWithResponse(ctx context.Context, companyId string, reqEditors ...RequestEditorFn) (*DeleteCompanyFiscalizationDataResponse, error) {
	rsp, err := c.DeleteCompanyFiscalizationData(ctx, companyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCompanyFiscalizationDataResponse(rsp)
}

// GetCompanyFiscalizationDataWithResponse request returning *GetCompanyFiscalizationDataResponse
func (c *ClientWithResponses) GetCompanyFiscalizationDataWithResponse(ctx context.Context, companyId string, params *GetCompanyFiscalizationDataParams, reqEditors ...RequestEditorFn) (*GetCompanyFiscalizationDataResponse, error) {
	rsp, err := c.GetCompanyFiscalizationData(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompanyFiscalizationDataResponse(rsp)
}

// UpsertCompanyFiscalizationDataWithBodyWithResponse request with arbitrary body returning *UpsertCompanyFiscalizationDataResponse
func (c *ClientWithResponses) UpsertCompanyFiscalizationDataWithBodyWithResponse(ctx context.Context, companyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertCompanyFiscalizationDataResponse, error) {
	rsp, err := c.UpsertCompanyFiscalizationDataWithBody(ctx, companyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCompanyFiscalizationDataResponse(rsp)
}

func (c *ClientWithResponses) UpsertCompanyFiscalizationDataWithResponse(ctx context.Context, companyId string, body UpsertCompanyFiscalizationDataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertCompanyFiscalizationDataResponse, error) {
	rsp, err := c.UpsertCompanyFiscalizationData(ctx, companyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertCompanyFiscalizationDataResponse(rsp)
}

// GetFiscalizationReportWithResponse request returning *GetFiscalizationReportResponse
func (c *ClientWithResponses) GetFiscalizationReportWithResponse(ctx context.Context, companyId string, params *GetFiscalizationReportParams, reqEditors ...RequestEditorFn) (*GetFiscalizationReportResponse, error) {
	rsp, err := c.GetFiscalizationReport(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFiscalizationReportResponse(rsp)
}

// FiscalizeTransactionWithBodyWithResponse request with arbitrary body returning *FiscalizeTransactionResponse
func (c *ClientWithResponses) FiscalizeTransactionWithBodyWithResponse(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FiscalizeTransactionResponse, error) {
	rsp, err := c.FiscalizeTransactionWithBody(ctx, transactionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiscalizeTransactionResponse(rsp)
}

func (c *ClientWithResponses) FiscalizeTransactionWithResponse(ctx context.Context, transactionId string, params *FiscalizeTransactionParams, body FiscalizeTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*FiscalizeTransactionResponse, error) {
	rsp, err := c.FiscalizeTransaction(ctx, transactionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFiscalizeTransactionResponse(rsp)
}

// SendFiscalizedTransactionPDFWithBodyWithResponse request with arbitrary body returning *SendFiscalizedTransactionPDFResponse
func (c *ClientWithResponses) SendFiscalizedTransactionPDFWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendFiscalizedTransactionPDFResponse, error) {
	rsp, err := c.SendFiscalizedTransactionPDFWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendFiscalizedTransactionPDFResponse(rsp)
}

func (c *ClientWithResponses) SendFiscalizedTransactionPDFWithResponse(ctx context.Context, transactionId string, body SendFiscalizedTransactionPDFJSONRequestBody, reqEditors ...RequestEditorFn) (*SendFiscalizedTransactionPDFResponse, error) {
	rsp, err := c.SendFiscalizedTransactionPDF(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendFiscalizedTransactionPDFResponse(rsp)
}

// GetFiscalizedTransactionPDFWithResponse request returning *GetFiscalizedTransactionPDFResponse
func (c *ClientWithResponses) GetFiscalizedTransactionPDFWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*GetFiscalizedTransactionPDFResponse, error) {
	rsp, err := c.GetFiscalizedTransactionPDF(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFiscalizedTransactionPDFResponse(rsp)
}

// RefundFiscalizedTransactionWithResponse request returning *RefundFiscalizedTransactionResponse
func (c *ClientWithResponses) RefundFiscalizedTransactionWithResponse(ctx context.Context, transactionId string, params *RefundFiscalizedTransactionParams, reqEditors ...RequestEditorFn) (*RefundFiscalizedTransactionResponse, error) {
	rsp, err := c.RefundFiscalizedTransaction(ctx, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefundFiscalizedTransactionResponse(rsp)
}

// AdyenCompanyOnboardingStatusWithResponse request returning *AdyenCompanyOnboardingStatusResponse
func (c *ClientWithResponses) AdyenCompanyOnboardingStatusWithResponse(ctx context.Context, companyId string, params *AdyenCompanyOnboardingStatusParams, reqEditors ...RequestEditorFn) (*AdyenCompanyOnboardingStatusResponse, error) {
	rsp, err := c.AdyenCompanyOnboardingStatus(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdyenCompanyOnboardingStatusResponse(rsp)
}

// AdyenCompanyOnboardingWithBodyWithResponse request with arbitrary body returning *AdyenCompanyOnboardingResponse
func (c *ClientWithResponses) AdyenCompanyOnboardingWithBodyWithResponse(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdyenCompanyOnboardingResponse, error) {
	rsp, err := c.AdyenCompanyOnboardingWithBody(ctx, companyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdyenCompanyOnboardingResponse(rsp)
}

func (c *ClientWithResponses) AdyenCompanyOnboardingWithResponse(ctx context.Context, companyId string, params *AdyenCompanyOnboardingParams, body AdyenCompanyOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*AdyenCompanyOnboardingResponse, error) {
	rsp, err := c.AdyenCompanyOnboarding(ctx, companyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdyenCompanyOnboardingResponse(rsp)
}

// AdyenUserOnboardingStatusWithResponse request returning *AdyenUserOnboardingStatusResponse
func (c *ClientWithResponses) AdyenUserOnboardingStatusWithResponse(ctx context.Context, userId string, params *AdyenUserOnboardingStatusParams, reqEditors ...RequestEditorFn) (*AdyenUserOnboardingStatusResponse, error) {
	rsp, err := c.AdyenUserOnboardingStatus(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdyenUserOnboardingStatusResponse(rsp)
}

// AdyenUserOnboardingWithBodyWithResponse request with arbitrary body returning *AdyenUserOnboardingResponse
func (c *ClientWithResponses) AdyenUserOnboardingWithBodyWithResponse(ctx context.Context, userId string, params *AdyenUserOnboardingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdyenUserOnboardingResponse, error) {
	rsp, err := c.AdyenUserOnboardingWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdyenUserOnboardingResponse(rsp)
}

func (c *ClientWithResponses) AdyenUserOnboardingWithResponse(ctx context.Context, userId string, params *AdyenUserOnboardingParams, body AdyenUserOnboardingJSONRequestBody, reqEditors ...RequestEditorFn) (*AdyenUserOnboardingResponse, error) {
	rsp, err := c.AdyenUserOnboarding(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdyenUserOnboardingResponse(rsp)
}

// ListSaltpayCompaniesWithResponse request returning *ListSaltpayCompaniesResponse
func (c *ClientWithResponses) ListSaltpayCompaniesWithResponse(ctx context.Context, params *ListSaltpayCompaniesParams, reqEditors ...RequestEditorFn) (*ListSaltpayCompaniesResponse, error) {
	rsp, err := c.ListSaltpayCompanies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSaltpayCompaniesResponse(rsp)
}

// LinkSaltpayBankAccountWithBodyWithResponse request with arbitrary body returning *LinkSaltpayBankAccountResponse
func (c *ClientWithResponses) LinkSaltpayBankAccountWithBodyWithResponse(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkSaltpayBankAccountResponse, error) {
	rsp, err := c.LinkSaltpayBankAccountWithBody(ctx, companyId, bankAccountId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkSaltpayBankAccountResponse(rsp)
}

func (c *ClientWithResponses) LinkSaltpayBankAccountWithResponse(ctx context.Context, companyId string, bankAccountId string, params *LinkSaltpayBankAccountParams, body LinkSaltpayBankAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkSaltpayBankAccountResponse, error) {
	rsp, err := c.LinkSaltpayBankAccount(ctx, companyId, bankAccountId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkSaltpayBankAccountResponse(rsp)
}

// ListSaltpayStoresAtCompanyWithResponse request returning *ListSaltpayStoresAtCompanyResponse
func (c *ClientWithResponses) ListSaltpayStoresAtCompanyWithResponse(ctx context.Context, companyId string, params *ListSaltpayStoresAtCompanyParams, reqEditors ...RequestEditorFn) (*ListSaltpayStoresAtCompanyResponse, error) {
	rsp, err := c.ListSaltpayStoresAtCompany(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSaltpayStoresAtCompanyResponse(rsp)
}

// ListSaltpayStoresWithResponse request returning *ListSaltpayStoresResponse
func (c *ClientWithResponses) ListSaltpayStoresWithResponse(ctx context.Context, params *ListSaltpayStoresParams, reqEditors ...RequestEditorFn) (*ListSaltpayStoresResponse, error) {
	rsp, err := c.ListSaltpayStores(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSaltpayStoresResponse(rsp)
}

// ListSaltpayTerminalsWithResponse request returning *ListSaltpayTerminalsResponse
func (c *ClientWithResponses) ListSaltpayTerminalsWithResponse(ctx context.Context, storeId string, params *ListSaltpayTerminalsParams, reqEditors ...RequestEditorFn) (*ListSaltpayTerminalsResponse, error) {
	rsp, err := c.ListSaltpayTerminals(ctx, storeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSaltpayTerminalsResponse(rsp)
}

// UpdateSaltpayTerminalWithBodyWithResponse request with arbitrary body returning *UpdateSaltpayTerminalResponse
func (c *ClientWithResponses) UpdateSaltpayTerminalWithBodyWithResponse(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSaltpayTerminalResponse, error) {
	rsp, err := c.UpdateSaltpayTerminalWithBody(ctx, storeId, terminalId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSaltpayTerminalResponse(rsp)
}

func (c *ClientWithResponses) UpdateSaltpayTerminalWithResponse(ctx context.Context, storeId string, terminalId string, params *UpdateSaltpayTerminalParams, body UpdateSaltpayTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSaltpayTerminalResponse, error) {
	rsp, err := c.UpdateSaltpayTerminal(ctx, storeId, terminalId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSaltpayTerminalResponse(rsp)
}

// CreateLineItemWithBodyWithResponse request with arbitrary body returning *CreateLineItemResponse
func (c *ClientWithResponses) CreateLineItemWithBodyWithResponse(ctx context.Context, params *CreateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLineItemResponse, error) {
	rsp, err := c.CreateLineItemWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLineItemResponse(rsp)
}

func (c *ClientWithResponses) CreateLineItemWithResponse(ctx context.Context, params *CreateLineItemParams, body CreateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLineItemResponse, error) {
	rsp, err := c.CreateLineItem(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLineItemResponse(rsp)
}

// DeleteLineItemWithResponse request returning *DeleteLineItemResponse
func (c *ClientWithResponses) DeleteLineItemWithResponse(ctx context.Context, lineItemId string, params *DeleteLineItemParams, reqEditors ...RequestEditorFn) (*DeleteLineItemResponse, error) {
	rsp, err := c.DeleteLineItem(ctx, lineItemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLineItemResponse(rsp)
}

// GetLineItemWithResponse request returning *GetLineItemResponse
func (c *ClientWithResponses) GetLineItemWithResponse(ctx context.Context, lineItemId string, params *GetLineItemParams, reqEditors ...RequestEditorFn) (*GetLineItemResponse, error) {
	rsp, err := c.GetLineItem(ctx, lineItemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLineItemResponse(rsp)
}

// UpdateLineItemWithBodyWithResponse request with arbitrary body returning *UpdateLineItemResponse
func (c *ClientWithResponses) UpdateLineItemWithBodyWithResponse(ctx context.Context, lineItemId string, params *UpdateLineItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLineItemResponse, error) {
	rsp, err := c.UpdateLineItemWithBody(ctx, lineItemId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLineItemResponse(rsp)
}

func (c *ClientWithResponses) UpdateLineItemWithResponse(ctx context.Context, lineItemId string, params *UpdateLineItemParams, body UpdateLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLineItemResponse, error) {
	rsp, err := c.UpdateLineItem(ctx, lineItemId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLineItemResponse(rsp)
}

// CreateMemoWithBodyWithResponse request with arbitrary body returning *CreateMemoResponse
func (c *ClientWithResponses) CreateMemoWithBodyWithResponse(ctx context.Context, params *CreateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMemoResponse, error) {
	rsp, err := c.CreateMemoWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMemoResponse(rsp)
}

func (c *ClientWithResponses) CreateMemoWithResponse(ctx context.Context, params *CreateMemoParams, body CreateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMemoResponse, error) {
	rsp, err := c.CreateMemo(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMemoResponse(rsp)
}

// DeleteMemoWithResponse request returning *DeleteMemoResponse
func (c *ClientWithResponses) DeleteMemoWithResponse(ctx context.Context, memoId string, params *DeleteMemoParams, reqEditors ...RequestEditorFn) (*DeleteMemoResponse, error) {
	rsp, err := c.DeleteMemo(ctx, memoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMemoResponse(rsp)
}

// GetMemoWithResponse request returning *GetMemoResponse
func (c *ClientWithResponses) GetMemoWithResponse(ctx context.Context, memoId string, params *GetMemoParams, reqEditors ...RequestEditorFn) (*GetMemoResponse, error) {
	rsp, err := c.GetMemo(ctx, memoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMemoResponse(rsp)
}

// UpdateMemoWithBodyWithResponse request with arbitrary body returning *UpdateMemoResponse
func (c *ClientWithResponses) UpdateMemoWithBodyWithResponse(ctx context.Context, memoId string, params *UpdateMemoParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMemoResponse, error) {
	rsp, err := c.UpdateMemoWithBody(ctx, memoId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMemoResponse(rsp)
}

func (c *ClientWithResponses) UpdateMemoWithResponse(ctx context.Context, memoId string, params *UpdateMemoParams, body UpdateMemoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMemoResponse, error) {
	rsp, err := c.UpdateMemo(ctx, memoId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMemoResponse(rsp)
}

// CreateNotificationWithBodyWithResponse request with arbitrary body returning *CreateNotificationResponse
func (c *ClientWithResponses) CreateNotificationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error) {
	rsp, err := c.CreateNotificationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationWithResponse(ctx context.Context, body CreateNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationResponse, error) {
	rsp, err := c.CreateNotification(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationResponse(rsp)
}

// DeleteNotificationWithResponse request returning *DeleteNotificationResponse
func (c *ClientWithResponses) DeleteNotificationWithResponse(ctx context.Context, notificationId string, params *DeleteNotificationParams, reqEditors ...RequestEditorFn) (*DeleteNotificationResponse, error) {
	rsp, err := c.DeleteNotification(ctx, notificationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationResponse(rsp)
}

// GetNotificationWithResponse request returning *GetNotificationResponse
func (c *ClientWithResponses) GetNotificationWithResponse(ctx context.Context, notificationId string, params *GetNotificationParams, reqEditors ...RequestEditorFn) (*GetNotificationResponse, error) {
	rsp, err := c.GetNotification(ctx, notificationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationResponse(rsp)
}

// ListOAuthApplicationsWithResponse request returning *ListOAuthApplicationsResponse
func (c *ClientWithResponses) ListOAuthApplicationsWithResponse(ctx context.Context, params *ListOAuthApplicationsParams, reqEditors ...RequestEditorFn) (*ListOAuthApplicationsResponse, error) {
	rsp, err := c.ListOAuthApplications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOAuthApplicationsResponse(rsp)
}

// CreateOAuthApplicationWithBodyWithResponse request with arbitrary body returning *CreateOAuthApplicationResponse
func (c *ClientWithResponses) CreateOAuthApplicationWithBodyWithResponse(ctx context.Context, params *CreateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthApplicationResponse, error) {
	rsp, err := c.CreateOAuthApplicationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreateOAuthApplicationWithResponse(ctx context.Context, params *CreateOAuthApplicationParams, body CreateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthApplicationResponse, error) {
	rsp, err := c.CreateOAuthApplication(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthApplicationResponse(rsp)
}

// DeleteOAuthApplicationWithResponse request returning *DeleteOAuthApplicationResponse
func (c *ClientWithResponses) DeleteOAuthApplicationWithResponse(ctx context.Context, applicationId string, params *DeleteOAuthApplicationParams, reqEditors ...RequestEditorFn) (*DeleteOAuthApplicationResponse, error) {
	rsp, err := c.DeleteOAuthApplication(ctx, applicationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOAuthApplicationResponse(rsp)
}

// GetOAuthApplicationWithResponse request returning *GetOAuthApplicationResponse
func (c *ClientWithResponses) GetOAuthApplicationWithResponse(ctx context.Context, applicationId string, params *GetOAuthApplicationParams, reqEditors ...RequestEditorFn) (*GetOAuthApplicationResponse, error) {
	rsp, err := c.GetOAuthApplication(ctx, applicationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthApplicationResponse(rsp)
}

// UpdateOAuthApplicationWithBodyWithResponse request with arbitrary body returning *UpdateOAuthApplicationResponse
func (c *ClientWithResponses) UpdateOAuthApplicationWithBodyWithResponse(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOAuthApplicationResponse, error) {
	rsp, err := c.UpdateOAuthApplicationWithBody(ctx, applicationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOAuthApplicationResponse(rsp)
}

func (c *ClientWithResponses) UpdateOAuthApplicationWithResponse(ctx context.Context, applicationId string, params *UpdateOAuthApplicationParams, body UpdateOAuthApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOAuthApplicationResponse, error) {
	rsp, err := c.UpdateOAuthApplication(ctx, applicationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOAuthApplicationResponse(rsp)
}

// StartOAuthFlowWithResponse request returning *StartOAuthFlowResponse
func (c *ClientWithResponses) StartOAuthFlowWithResponse(ctx context.Context, params *StartOAuthFlowParams, reqEditors ...RequestEditorFn) (*StartOAuthFlowResponse, error) {
	rsp, err := c.StartOAuthFlow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartOAuthFlowResponse(rsp)
}

// CreateOAuthConsentWithBodyWithResponse request with arbitrary body returning *CreateOAuthConsentResponse
func (c *ClientWithResponses) CreateOAuthConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOAuthConsentResponse, error) {
	rsp, err := c.CreateOAuthConsentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthConsentResponse(rsp)
}

func (c *ClientWithResponses) CreateOAuthConsentWithResponse(ctx context.Context, body CreateOAuthConsentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOAuthConsentResponse, error) {
	rsp, err := c.CreateOAuthConsent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOAuthConsentResponse(rsp)
}

// GetOAuthPublicKeyWithResponse request returning *GetOAuthPublicKeyResponse
func (c *ClientWithResponses) GetOAuthPublicKeyWithResponse(ctx context.Context, params *GetOAuthPublicKeyParams, reqEditors ...RequestEditorFn) (*GetOAuthPublicKeyResponse, error) {
	rsp, err := c.GetOAuthPublicKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthPublicKeyResponse(rsp)
}

// ListOAuthScopesWithResponse request returning *ListOAuthScopesResponse
func (c *ClientWithResponses) ListOAuthScopesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthScopesResponse, error) {
	rsp, err := c.ListOAuthScopes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOAuthScopesResponse(rsp)
}

// GetOAuthTokenWithBodyWithResponse request with arbitrary body returning *GetOAuthTokenResponse
func (c *ClientWithResponses) GetOAuthTokenWithBodyWithResponse(ctx context.Context, params *GetOAuthTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

func (c *ClientWithResponses) GetOAuthTokenWithResponse(ctx context.Context, params *GetOAuthTokenParams, body GetOAuthTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOAuthTokenResponse, error) {
	rsp, err := c.GetOAuthToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthTokenResponse(rsp)
}

// ListPaymentMethodsWithResponse request returning *ListPaymentMethodsResponse
func (c *ClientWithResponses) ListPaymentMethodsWithResponse(ctx context.Context, params *ListPaymentMethodsParams, reqEditors ...RequestEditorFn) (*ListPaymentMethodsResponse, error) {
	rsp, err := c.ListPaymentMethods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaymentMethodsResponse(rsp)
}

// GetPaymentWithResponse request returning *GetPaymentResponse
func (c *ClientWithResponses) GetPaymentWithResponse(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*GetPaymentResponse, error) {
	rsp, err := c.GetPayment(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentResponse(rsp)
}

// UpdatePaymentWithBodyWithResponse request with arbitrary body returning *UpdatePaymentResponse
func (c *ClientWithResponses) UpdatePaymentWithBodyWithResponse(ctx context.Context, paymentId string, params *UpdatePaymentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePaymentResponse, error) {
	rsp, err := c.UpdatePaymentWithBody(ctx, paymentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentResponse(rsp)
}

func (c *ClientWithResponses) UpdatePaymentWithResponse(ctx context.Context, paymentId string, params *UpdatePaymentParams, body UpdatePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePaymentResponse, error) {
	rsp, err := c.UpdatePayment(ctx, paymentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePaymentResponse(rsp)
}

// DownloadPaymentReceiptWithResponse request returning *DownloadPaymentReceiptResponse
func (c *ClientWithResponses) DownloadPaymentReceiptWithResponse(ctx context.Context, paymentId string, params *DownloadPaymentReceiptParams, reqEditors ...RequestEditorFn) (*DownloadPaymentReceiptResponse, error) {
	rsp, err := c.DownloadPaymentReceipt(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPaymentReceiptResponse(rsp)
}

// SendPaymentReceiptWithBodyWithResponse request with arbitrary body returning *SendPaymentReceiptResponse
func (c *ClientWithResponses) SendPaymentReceiptWithBodyWithResponse(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendPaymentReceiptResponse, error) {
	rsp, err := c.SendPaymentReceiptWithBody(ctx, paymentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPaymentReceiptResponse(rsp)
}

func (c *ClientWithResponses) SendPaymentReceiptWithResponse(ctx context.Context, paymentId string, params *SendPaymentReceiptParams, body SendPaymentReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*SendPaymentReceiptResponse, error) {
	rsp, err := c.SendPaymentReceipt(ctx, paymentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendPaymentReceiptResponse(rsp)
}

// ListPricingWithResponse request returning *ListPricingResponse
func (c *ClientWithResponses) ListPricingWithResponse(ctx context.Context, params *ListPricingParams, reqEditors ...RequestEditorFn) (*ListPricingResponse, error) {
	rsp, err := c.ListPricing(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPricingResponse(rsp)
}

// CalculatePricingWithResponse request returning *CalculatePricingResponse
func (c *ClientWithResponses) CalculatePricingWithResponse(ctx context.Context, params *CalculatePricingParams, reqEditors ...RequestEditorFn) (*CalculatePricingResponse, error) {
	rsp, err := c.CalculatePricing(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculatePricingResponse(rsp)
}

// GetPricingByCountryCodeWithResponse request returning *GetPricingByCountryCodeResponse
func (c *ClientWithResponses) GetPricingByCountryCodeWithResponse(ctx context.Context, countryCode string, params *GetPricingByCountryCodeParams, reqEditors ...RequestEditorFn) (*GetPricingByCountryCodeResponse, error) {
	rsp, err := c.GetPricingByCountryCode(ctx, countryCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricingByCountryCodeResponse(rsp)
}

// ListProductGroupsWithResponse request returning *ListProductGroupsResponse
func (c *ClientWithResponses) ListProductGroupsWithResponse(ctx context.Context, params *ListProductGroupsParams, reqEditors ...RequestEditorFn) (*ListProductGroupsResponse, error) {
	rsp, err := c.ListProductGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProductGroupsResponse(rsp)
}

// CreateProductGroupWithBodyWithResponse request with arbitrary body returning *CreateProductGroupResponse
func (c *ClientWithResponses) CreateProductGroupWithBodyWithResponse(ctx context.Context, params *CreateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductGroupResponse, error) {
	rsp, err := c.CreateProductGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateProductGroupWithResponse(ctx context.Context, params *CreateProductGroupParams, body CreateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductGroupResponse, error) {
	rsp, err := c.CreateProductGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductGroupResponse(rsp)
}

// ListGroupsAndProductsWithResponse request returning *ListGroupsAndProductsResponse
func (c *ClientWithResponses) ListGroupsAndProductsWithResponse(ctx context.Context, params *ListGroupsAndProductsParams, reqEditors ...RequestEditorFn) (*ListGroupsAndProductsResponse, error) {
	rsp, err := c.ListGroupsAndProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsAndProductsResponse(rsp)
}

// UpdateProductGroupsOrderWithBodyWithResponse request with arbitrary body returning *UpdateProductGroupsOrderResponse
func (c *ClientWithResponses) UpdateProductGroupsOrderWithBodyWithResponse(ctx context.Context, params *UpdateProductGroupsOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductGroupsOrderResponse, error) {
	rsp, err := c.UpdateProductGroupsOrderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductGroupsOrderResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductGroupsOrderWithResponse(ctx context.Context, params *UpdateProductGroupsOrderParams, body UpdateProductGroupsOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductGroupsOrderResponse, error) {
	rsp, err := c.UpdateProductGroupsOrder(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductGroupsOrderResponse(rsp)
}

// DeleteProductGroupWithResponse request returning *DeleteProductGroupResponse
func (c *ClientWithResponses) DeleteProductGroupWithResponse(ctx context.Context, id string, params *DeleteProductGroupParams, reqEditors ...RequestEditorFn) (*DeleteProductGroupResponse, error) {
	rsp, err := c.DeleteProductGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductGroupResponse(rsp)
}

// GetProductGroupWithResponse request returning *GetProductGroupResponse
func (c *ClientWithResponses) GetProductGroupWithResponse(ctx context.Context, id string, params *GetProductGroupParams, reqEditors ...RequestEditorFn) (*GetProductGroupResponse, error) {
	rsp, err := c.GetProductGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductGroupResponse(rsp)
}

// UpdateProductGroupWithBodyWithResponse request with arbitrary body returning *UpdateProductGroupResponse
func (c *ClientWithResponses) UpdateProductGroupWithBodyWithResponse(ctx context.Context, id string, params *UpdateProductGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductGroupResponse, error) {
	rsp, err := c.UpdateProductGroupWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductGroupWithResponse(ctx context.Context, id string, params *UpdateProductGroupParams, body UpdateProductGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductGroupResponse, error) {
	rsp, err := c.UpdateProductGroup(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductGroupResponse(rsp)
}

// ListProductsWithResponse request returning *ListProductsResponse
func (c *ClientWithResponses) ListProductsWithResponse(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*ListProductsResponse, error) {
	rsp, err := c.ListProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProductsResponse(rsp)
}

// CreateProductWithBodyWithResponse request with arbitrary body returning *CreateProductResponse
func (c *ClientWithResponses) CreateProductWithBodyWithResponse(ctx context.Context, params *CreateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductResponse, error) {
	rsp, err := c.CreateProductWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductResponse(rsp)
}

func (c *ClientWithResponses) CreateProductWithResponse(ctx context.Context, params *CreateProductParams, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductResponse, error) {
	rsp, err := c.CreateProduct(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductResponse(rsp)
}

// DeleteProductWithResponse request returning *DeleteProductResponse
func (c *ClientWithResponses) DeleteProductWithResponse(ctx context.Context, id string, params *DeleteProductParams, reqEditors ...RequestEditorFn) (*DeleteProductResponse, error) {
	rsp, err := c.DeleteProduct(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductResponse(rsp)
}

// GetProductWithResponse request returning *GetProductResponse
func (c *ClientWithResponses) GetProductWithResponse(ctx context.Context, id string, params *GetProductParams, reqEditors ...RequestEditorFn) (*GetProductResponse, error) {
	rsp, err := c.GetProduct(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductResponse(rsp)
}

// UpdateProductWithBodyWithResponse request with arbitrary body returning *UpdateProductResponse
func (c *ClientWithResponses) UpdateProductWithBodyWithResponse(ctx context.Context, id string, params *UpdateProductParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error) {
	rsp, err := c.UpdateProductWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductWithResponse(ctx context.Context, id string, params *UpdateProductParams, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error) {
	rsp, err := c.UpdateProduct(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductResponse(rsp)
}

// CreateCustomPropertyWithBodyWithResponse request with arbitrary body returning *CreateCustomPropertyResponse
func (c *ClientWithResponses) CreateCustomPropertyWithBodyWithResponse(ctx context.Context, params *CreateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomPropertyResponse, error) {
	rsp, err := c.CreateCustomPropertyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomPropertyResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomPropertyWithResponse(ctx context.Context, params *CreateCustomPropertyParams, body CreateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomPropertyResponse, error) {
	rsp, err := c.CreateCustomProperty(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomPropertyResponse(rsp)
}

// DeleteCustomPropertyWithResponse request returning *DeleteCustomPropertyResponse
func (c *ClientWithResponses) DeleteCustomPropertyWithResponse(ctx context.Context, propertyId string, params *DeleteCustomPropertyParams, reqEditors ...RequestEditorFn) (*DeleteCustomPropertyResponse, error) {
	rsp, err := c.DeleteCustomProperty(ctx, propertyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomPropertyResponse(rsp)
}

// UpdateCustomPropertyWithBodyWithResponse request with arbitrary body returning *UpdateCustomPropertyResponse
func (c *ClientWithResponses) UpdateCustomPropertyWithBodyWithResponse(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomPropertyResponse, error) {
	rsp, err := c.UpdateCustomPropertyWithBody(ctx, propertyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomPropertyResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomPropertyWithResponse(ctx context.Context, propertyId string, params *UpdateCustomPropertyParams, body UpdateCustomPropertyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomPropertyResponse, error) {
	rsp, err := c.UpdateCustomProperty(ctx, propertyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomPropertyResponse(rsp)
}

// CreateResourceGroupWithBodyWithResponse request with arbitrary body returning *CreateResourceGroupResponse
func (c *ClientWithResponses) CreateResourceGroupWithBodyWithResponse(ctx context.Context, params *CreateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceGroupResponse, error) {
	rsp, err := c.CreateResourceGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceGroupWithResponse(ctx context.Context, params *CreateResourceGroupParams, body CreateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceGroupResponse, error) {
	rsp, err := c.CreateResourceGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceGroupResponse(rsp)
}

// DeleteResourceGroupWithResponse request returning *DeleteResourceGroupResponse
func (c *ClientWithResponses) DeleteResourceGroupWithResponse(ctx context.Context, resourceGroupId string, params *DeleteResourceGroupParams, reqEditors ...RequestEditorFn) (*DeleteResourceGroupResponse, error) {
	rsp, err := c.DeleteResourceGroup(ctx, resourceGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceGroupResponse(rsp)
}

// GetResourceGroupWithResponse request returning *GetResourceGroupResponse
func (c *ClientWithResponses) GetResourceGroupWithResponse(ctx context.Context, resourceGroupId string, params *GetResourceGroupParams, reqEditors ...RequestEditorFn) (*GetResourceGroupResponse, error) {
	rsp, err := c.GetResourceGroup(ctx, resourceGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceGroupResponse(rsp)
}

// UpdateResourceGroupWithBodyWithResponse request with arbitrary body returning *UpdateResourceGroupResponse
func (c *ClientWithResponses) UpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceGroupResponse, error) {
	rsp, err := c.UpdateResourceGroupWithBody(ctx, resourceGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceGroupWithResponse(ctx context.Context, resourceGroupId string, params *UpdateResourceGroupParams, body UpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceGroupResponse, error) {
	rsp, err := c.UpdateResourceGroup(ctx, resourceGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceGroupResponse(rsp)
}

// CreateResourceWithBodyWithResponse request with arbitrary body returning *CreateResourceResponse
func (c *ClientWithResponses) CreateResourceWithBodyWithResponse(ctx context.Context, params *CreateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResourceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceWithResponse(ctx context.Context, params *CreateResourceParams, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResource(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

// DeleteResourceWithResponse request returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, resourceId string, params *DeleteResourceParams, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, resourceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, resourceId string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, resourceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// UpdateResourceWithBodyWithResponse request with arbitrary body returning *UpdateResourceResponse
func (c *ClientWithResponses) UpdateResourceWithBodyWithResponse(ctx context.Context, resourceId string, params *UpdateResourceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResourceWithBody(ctx, resourceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceWithResponse(ctx context.Context, resourceId string, params *UpdateResourceParams, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResource(ctx, resourceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

// CreateRuleSetTemplateWithBodyWithResponse request with arbitrary body returning *CreateRuleSetTemplateResponse
func (c *ClientWithResponses) CreateRuleSetTemplateWithBodyWithResponse(ctx context.Context, params *CreateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleSetTemplateResponse, error) {
	rsp, err := c.CreateRuleSetTemplateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleSetTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleSetTemplateWithResponse(ctx context.Context, params *CreateRuleSetTemplateParams, body CreateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleSetTemplateResponse, error) {
	rsp, err := c.CreateRuleSetTemplate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleSetTemplateResponse(rsp)
}

// DeleteRuleSetTemplateWithResponse request returning *DeleteRuleSetTemplateResponse
func (c *ClientWithResponses) DeleteRuleSetTemplateWithResponse(ctx context.Context, ruleSetTemplateId string, params *DeleteRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*DeleteRuleSetTemplateResponse, error) {
	rsp, err := c.DeleteRuleSetTemplate(ctx, ruleSetTemplateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleSetTemplateResponse(rsp)
}

// GetRuleSetTemplateWithResponse request returning *GetRuleSetTemplateResponse
func (c *ClientWithResponses) GetRuleSetTemplateWithResponse(ctx context.Context, ruleSetTemplateId string, params *GetRuleSetTemplateParams, reqEditors ...RequestEditorFn) (*GetRuleSetTemplateResponse, error) {
	rsp, err := c.GetRuleSetTemplate(ctx, ruleSetTemplateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleSetTemplateResponse(rsp)
}

// UpdateRuleSetTemplateWithBodyWithResponse request with arbitrary body returning *UpdateRuleSetTemplateResponse
func (c *ClientWithResponses) UpdateRuleSetTemplateWithBodyWithResponse(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleSetTemplateResponse, error) {
	rsp, err := c.UpdateRuleSetTemplateWithBody(ctx, ruleSetTemplateId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleSetTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleSetTemplateWithResponse(ctx context.Context, ruleSetTemplateId string, params *UpdateRuleSetTemplateParams, body UpdateRuleSetTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleSetTemplateResponse, error) {
	rsp, err := c.UpdateRuleSetTemplate(ctx, ruleSetTemplateId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleSetTemplateResponse(rsp)
}

// CreateRuleSetWithBodyWithResponse request with arbitrary body returning *CreateRuleSetResponse
func (c *ClientWithResponses) CreateRuleSetWithBodyWithResponse(ctx context.Context, params *CreateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleSetResponse, error) {
	rsp, err := c.CreateRuleSetWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleSetResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleSetWithResponse(ctx context.Context, params *CreateRuleSetParams, body CreateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleSetResponse, error) {
	rsp, err := c.CreateRuleSet(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleSetResponse(rsp)
}

// DeleteRuleSetWithResponse request returning *DeleteRuleSetResponse
func (c *ClientWithResponses) DeleteRuleSetWithResponse(ctx context.Context, ruleSetId string, params *DeleteRuleSetParams, reqEditors ...RequestEditorFn) (*DeleteRuleSetResponse, error) {
	rsp, err := c.DeleteRuleSet(ctx, ruleSetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleSetResponse(rsp)
}

// GetRuleSetWithResponse request returning *GetRuleSetResponse
func (c *ClientWithResponses) GetRuleSetWithResponse(ctx context.Context, ruleSetId string, params *GetRuleSetParams, reqEditors ...RequestEditorFn) (*GetRuleSetResponse, error) {
	rsp, err := c.GetRuleSet(ctx, ruleSetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleSetResponse(rsp)
}

// UpdateRuleSetWithBodyWithResponse request with arbitrary body returning *UpdateRuleSetResponse
func (c *ClientWithResponses) UpdateRuleSetWithBodyWithResponse(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleSetResponse, error) {
	rsp, err := c.UpdateRuleSetWithBody(ctx, ruleSetId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleSetResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleSetWithResponse(ctx context.Context, ruleSetId string, params *UpdateRuleSetParams, body UpdateRuleSetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleSetResponse, error) {
	rsp, err := c.UpdateRuleSet(ctx, ruleSetId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleSetResponse(rsp)
}

// CreateSaleWithBodyWithResponse request with arbitrary body returning *CreateSaleResponse
func (c *ClientWithResponses) CreateSaleWithBodyWithResponse(ctx context.Context, params *CreateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSaleResponse, error) {
	rsp, err := c.CreateSaleWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSaleResponse(rsp)
}

func (c *ClientWithResponses) CreateSaleWithResponse(ctx context.Context, params *CreateSaleParams, body CreateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSaleResponse, error) {
	rsp, err := c.CreateSale(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSaleResponse(rsp)
}

// DeleteSaleWithResponse request returning *DeleteSaleResponse
func (c *ClientWithResponses) DeleteSaleWithResponse(ctx context.Context, saleId string, params *DeleteSaleParams, reqEditors ...RequestEditorFn) (*DeleteSaleResponse, error) {
	rsp, err := c.DeleteSale(ctx, saleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSaleResponse(rsp)
}

// GetSaleWithResponse request returning *GetSaleResponse
func (c *ClientWithResponses) GetSaleWithResponse(ctx context.Context, saleId string, params *GetSaleParams, reqEditors ...RequestEditorFn) (*GetSaleResponse, error) {
	rsp, err := c.GetSale(ctx, saleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSaleResponse(rsp)
}

// UpdateSaleWithBodyWithResponse request with arbitrary body returning *UpdateSaleResponse
func (c *ClientWithResponses) UpdateSaleWithBodyWithResponse(ctx context.Context, saleId string, params *UpdateSaleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSaleResponse, error) {
	rsp, err := c.UpdateSaleWithBody(ctx, saleId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSaleResponse(rsp)
}

func (c *ClientWithResponses) UpdateSaleWithResponse(ctx context.Context, saleId string, params *UpdateSaleParams, body UpdateSaleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSaleResponse, error) {
	rsp, err := c.UpdateSale(ctx, saleId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSaleResponse(rsp)
}

// RefundMarketplaceSaleWithResponse request returning *RefundMarketplaceSaleResponse
func (c *ClientWithResponses) RefundMarketplaceSaleWithResponse(ctx context.Context, saleId string, params *RefundMarketplaceSaleParams, reqEditors ...RequestEditorFn) (*RefundMarketplaceSaleResponse, error) {
	rsp, err := c.RefundMarketplaceSale(ctx, saleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefundMarketplaceSaleResponse(rsp)
}

// SendTransactionReceiptWithBodyWithResponse request with arbitrary body returning *SendTransactionReceiptResponse
func (c *ClientWithResponses) SendTransactionReceiptWithBodyWithResponse(ctx context.Context, saleId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendTransactionReceiptResponse, error) {
	rsp, err := c.SendTransactionReceiptWithBody(ctx, saleId, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendTransactionReceiptResponse(rsp)
}

func (c *ClientWithResponses) SendTransactionReceiptWithResponse(ctx context.Context, saleId string, transactionId string, body SendTransactionReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*SendTransactionReceiptResponse, error) {
	rsp, err := c.SendTransactionReceipt(ctx, saleId, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendTransactionReceiptResponse(rsp)
}

// DeprecatedListSubtransactionsWithResponse request returning *DeprecatedListSubtransactionsResponse
func (c *ClientWithResponses) DeprecatedListSubtransactionsWithResponse(ctx context.Context, saleId string, transactionId string, params *DeprecatedListSubtransactionsParams, reqEditors ...RequestEditorFn) (*DeprecatedListSubtransactionsResponse, error) {
	rsp, err := c.DeprecatedListSubtransactions(ctx, saleId, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeprecatedListSubtransactionsResponse(rsp)
}

// DeprecatedGetSubtransactionWithResponse request returning *DeprecatedGetSubtransactionResponse
func (c *ClientWithResponses) DeprecatedGetSubtransactionWithResponse(ctx context.Context, saleId string, transactionId string, id string, params *DeprecatedGetSubtransactionParams, reqEditors ...RequestEditorFn) (*DeprecatedGetSubtransactionResponse, error) {
	rsp, err := c.DeprecatedGetSubtransaction(ctx, saleId, transactionId, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeprecatedGetSubtransactionResponse(rsp)
}

// CreateSpaceWithBodyWithResponse request with arbitrary body returning *CreateSpaceResponse
func (c *ClientWithResponses) CreateSpaceWithBodyWithResponse(ctx context.Context, params *CreateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpaceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateSpaceWithResponse(ctx context.Context, params *CreateSpaceParams, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpace(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

// DeleteSpaceWithResponse request returning *DeleteSpaceResponse
func (c *ClientWithResponses) DeleteSpaceWithResponse(ctx context.Context, spaceId string, params *DeleteSpaceParams, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error) {
	rsp, err := c.DeleteSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpaceResponse(rsp)
}

// GetSpaceWithResponse request returning *GetSpaceResponse
func (c *ClientWithResponses) GetSpaceWithResponse(ctx context.Context, spaceId string, params *GetSpaceParams, reqEditors ...RequestEditorFn) (*GetSpaceResponse, error) {
	rsp, err := c.GetSpace(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceResponse(rsp)
}

// UpdateSpaceWithBodyWithResponse request with arbitrary body returning *UpdateSpaceResponse
func (c *ClientWithResponses) UpdateSpaceWithBodyWithResponse(ctx context.Context, spaceId string, params *UpdateSpaceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpaceWithBody(ctx, spaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpaceWithResponse(ctx context.Context, spaceId string, params *UpdateSpaceParams, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpace(ctx, spaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

// StreamBlockedTimesWithResponse request returning *StreamBlockedTimesResponse
func (c *ClientWithResponses) StreamBlockedTimesWithResponse(ctx context.Context, companyId string, params *StreamBlockedTimesParams, reqEditors ...RequestEditorFn) (*StreamBlockedTimesResponse, error) {
	rsp, err := c.StreamBlockedTimes(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamBlockedTimesResponse(rsp)
}

// StreamEmployeesWithResponse request returning *StreamEmployeesResponse
func (c *ClientWithResponses) StreamEmployeesWithResponse(ctx context.Context, companyId string, params *StreamEmployeesParams, reqEditors ...RequestEditorFn) (*StreamEmployeesResponse, error) {
	rsp, err := c.StreamEmployees(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamEmployeesResponse(rsp)
}

// StreamEventTypeGroupsWithResponse request returning *StreamEventTypeGroupsResponse
func (c *ClientWithResponses) StreamEventTypeGroupsWithResponse(ctx context.Context, companyId string, params *StreamEventTypeGroupsParams, reqEditors ...RequestEditorFn) (*StreamEventTypeGroupsResponse, error) {
	rsp, err := c.StreamEventTypeGroups(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamEventTypeGroupsResponse(rsp)
}

// StreamEventTypesWithResponse request returning *StreamEventTypesResponse
func (c *ClientWithResponses) StreamEventTypesWithResponse(ctx context.Context, companyId string, params *StreamEventTypesParams, reqEditors ...RequestEditorFn) (*StreamEventTypesResponse, error) {
	rsp, err := c.StreamEventTypes(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamEventTypesResponse(rsp)
}

// StreamEventsWithResponse request returning *StreamEventsResponse
func (c *ClientWithResponses) StreamEventsWithResponse(ctx context.Context, companyId string, params *StreamEventsParams, reqEditors ...RequestEditorFn) (*StreamEventsResponse, error) {
	rsp, err := c.StreamEvents(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamEventsResponse(rsp)
}

// StreamSalesMetricsWithResponse request returning *StreamSalesMetricsResponse
func (c *ClientWithResponses) StreamSalesMetricsWithResponse(ctx context.Context, companyId string, params *StreamSalesMetricsParams, reqEditors ...RequestEditorFn) (*StreamSalesMetricsResponse, error) {
	rsp, err := c.StreamSalesMetrics(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamSalesMetricsResponse(rsp)
}

// StreamNotificationsWithResponse request returning *StreamNotificationsResponse
func (c *ClientWithResponses) StreamNotificationsWithResponse(ctx context.Context, companyId string, params *StreamNotificationsParams, reqEditors ...RequestEditorFn) (*StreamNotificationsResponse, error) {
	rsp, err := c.StreamNotifications(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamNotificationsResponse(rsp)
}

// StreamProductGroupsWithResponse request returning *StreamProductGroupsResponse
func (c *ClientWithResponses) StreamProductGroupsWithResponse(ctx context.Context, companyId string, params *StreamProductGroupsParams, reqEditors ...RequestEditorFn) (*StreamProductGroupsResponse, error) {
	rsp, err := c.StreamProductGroups(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamProductGroupsResponse(rsp)
}

// StreamProductsWithResponse request returning *StreamProductsResponse
func (c *ClientWithResponses) StreamProductsWithResponse(ctx context.Context, companyId string, params *StreamProductsParams, reqEditors ...RequestEditorFn) (*StreamProductsResponse, error) {
	rsp, err := c.StreamProducts(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamProductsResponse(rsp)
}

// StreamResourcesWithResponse request returning *StreamResourcesResponse
func (c *ClientWithResponses) StreamResourcesWithResponse(ctx context.Context, companyId string, params *StreamResourcesParams, reqEditors ...RequestEditorFn) (*StreamResourcesResponse, error) {
	rsp, err := c.StreamResources(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamResourcesResponse(rsp)
}

// StreamSpacesWithResponse request returning *StreamSpacesResponse
func (c *ClientWithResponses) StreamSpacesWithResponse(ctx context.Context, companyId string, params *StreamSpacesParams, reqEditors ...RequestEditorFn) (*StreamSpacesResponse, error) {
	rsp, err := c.StreamSpaces(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamSpacesResponse(rsp)
}

// StreamTimeSlotReservationsWithResponse request returning *StreamTimeSlotReservationsResponse
func (c *ClientWithResponses) StreamTimeSlotReservationsWithResponse(ctx context.Context, companyId string, params *StreamTimeSlotReservationsParams, reqEditors ...RequestEditorFn) (*StreamTimeSlotReservationsResponse, error) {
	rsp, err := c.StreamTimeSlotReservations(ctx, companyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamTimeSlotReservationsResponse(rsp)
}

// GetBillingInvoiceWithResponse request returning *GetBillingInvoiceResponse
func (c *ClientWithResponses) GetBillingInvoiceWithResponse(ctx context.Context, invoiceId string, reqEditors ...RequestEditorFn) (*GetBillingInvoiceResponse, error) {
	rsp, err := c.GetBillingInvoice(ctx, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingInvoiceResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *DeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, subscriptionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// GetSubscriptionWithResponse request returning *GetSubscriptionResponse
func (c *ClientWithResponses) GetSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *GetSubscriptionParams, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error) {
	rsp, err := c.GetSubscription(ctx, subscriptionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionResponse(rsp)
}

// CreateSubtransactionWithBodyWithResponse request with arbitrary body returning *CreateSubtransactionResponse
func (c *ClientWithResponses) CreateSubtransactionWithBodyWithResponse(ctx context.Context, params *CreateSubtransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubtransactionResponse, error) {
	rsp, err := c.CreateSubtransactionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubtransactionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubtransactionWithResponse(ctx context.Context, params *CreateSubtransactionParams, body CreateSubtransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubtransactionResponse, error) {
	rsp, err := c.CreateSubtransaction(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubtransactionResponse(rsp)
}

// DeleteSubtransactionWithResponse request returning *DeleteSubtransactionResponse
func (c *ClientWithResponses) DeleteSubtransactionWithResponse(ctx context.Context, subtransactionId string, params *DeleteSubtransactionParams, reqEditors ...RequestEditorFn) (*DeleteSubtransactionResponse, error) {
	rsp, err := c.DeleteSubtransaction(ctx, subtransactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubtransactionResponse(rsp)
}

// GetSubtransactionWithResponse request returning *GetSubtransactionResponse
func (c *ClientWithResponses) GetSubtransactionWithResponse(ctx context.Context, subtransactionId string, params *GetSubtransactionParams, reqEditors ...RequestEditorFn) (*GetSubtransactionResponse, error) {
	rsp, err := c.GetSubtransaction(ctx, subtransactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubtransactionResponse(rsp)
}

// DeleteTerminalWithResponse request returning *DeleteTerminalResponse
func (c *ClientWithResponses) DeleteTerminalWithResponse(ctx context.Context, terminalId string, params *DeleteTerminalParams, reqEditors ...RequestEditorFn) (*DeleteTerminalResponse, error) {
	rsp, err := c.DeleteTerminal(ctx, terminalId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTerminalResponse(rsp)
}

// GetTerminalWithResponse request returning *GetTerminalResponse
func (c *ClientWithResponses) GetTerminalWithResponse(ctx context.Context, terminalId string, params *GetTerminalParams, reqEditors ...RequestEditorFn) (*GetTerminalResponse, error) {
	rsp, err := c.GetTerminal(ctx, terminalId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTerminalResponse(rsp)
}

// UpdateTerminalWithBodyWithResponse request with arbitrary body returning *UpdateTerminalResponse
func (c *ClientWithResponses) UpdateTerminalWithBodyWithResponse(ctx context.Context, terminalId string, params *UpdateTerminalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTerminalResponse, error) {
	rsp, err := c.UpdateTerminalWithBody(ctx, terminalId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTerminalResponse(rsp)
}

func (c *ClientWithResponses) UpdateTerminalWithResponse(ctx context.Context, terminalId string, params *UpdateTerminalParams, body UpdateTerminalJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTerminalResponse, error) {
	rsp, err := c.UpdateTerminal(ctx, terminalId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTerminalResponse(rsp)
}

// GetOAuthConsentWithResponse request returning *GetOAuthConsentResponse
func (c *ClientWithResponses) GetOAuthConsentWithResponse(ctx context.Context, params *GetOAuthConsentParams, reqEditors ...RequestEditorFn) (*GetOAuthConsentResponse, error) {
	rsp, err := c.GetOAuthConsent(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthConsentResponse(rsp)
}

// GetOAuthLoginWithResponse request returning *GetOAuthLoginResponse
func (c *ClientWithResponses) GetOAuthLoginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOAuthLoginResponse, error) {
	rsp, err := c.GetOAuthLogin(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOAuthLoginResponse(rsp)
}

// PostOAuthLoginWithBodyWithResponse request with arbitrary body returning *PostOAuthLoginResponse
func (c *ClientWithResponses) PostOAuthLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOAuthLoginResponse, error) {
	rsp, err := c.PostOAuthLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOAuthLoginResponse(rsp)
}

func (c *ClientWithResponses) PostOAuthLoginWithResponse(ctx context.Context, body PostOAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOAuthLoginResponse, error) {
	rsp, err := c.PostOAuthLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOAuthLoginResponse(rsp)
}

// GetTimeSlotReservationWithResponse request returning *GetTimeSlotReservationResponse
func (c *ClientWithResponses) GetTimeSlotReservationWithResponse(ctx context.Context, timeSlotReservationId string, params *GetTimeSlotReservationParams, reqEditors ...RequestEditorFn) (*GetTimeSlotReservationResponse, error) {
	rsp, err := c.GetTimeSlotReservation(ctx, timeSlotReservationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimeSlotReservationResponse(rsp)
}

// CreateTokenWithResponse request returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, params *CreateTokenParams, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// CreateTransactionWithBodyWithResponse request with arbitrary body returning *CreateTransactionResponse
func (c *ClientWithResponses) CreateTransactionWithBodyWithResponse(ctx context.Context, params *CreateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error) {
	rsp, err := c.CreateTransactionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransactionResponse(rsp)
}

func (c *ClientWithResponses) CreateTransactionWithResponse(ctx context.Context, params *CreateTransactionParams, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error) {
	rsp, err := c.CreateTransaction(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransactionResponse(rsp)
}

// DeleteTransactionWithResponse request returning *DeleteTransactionResponse
func (c *ClientWithResponses) DeleteTransactionWithResponse(ctx context.Context, transactionId string, params *DeleteTransactionParams, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error) {
	rsp, err := c.DeleteTransaction(ctx, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, transactionId string, params *GetTransactionParams, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// UpdateTransactionWithBodyWithResponse request with arbitrary body returning *UpdateTransactionResponse
func (c *ClientWithResponses) UpdateTransactionWithBodyWithResponse(ctx context.Context, transactionId string, params *UpdateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error) {
	rsp, err := c.UpdateTransactionWithBody(ctx, transactionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionWithResponse(ctx context.Context, transactionId string, params *UpdateTransactionParams, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error) {
	rsp, err := c.UpdateTransaction(ctx, transactionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionResponse(rsp)
}

// ListLineItemsWithResponse request returning *ListLineItemsResponse
func (c *ClientWithResponses) ListLineItemsWithResponse(ctx context.Context, transactionId string, params *ListLineItemsParams, reqEditors ...RequestEditorFn) (*ListLineItemsResponse, error) {
	rsp, err := c.ListLineItems(ctx, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLineItemsResponse(rsp)
}

// ListSubtransactionsWithResponse request returning *ListSubtransactionsResponse
func (c *ClientWithResponses) ListSubtransactionsWithResponse(ctx context.Context, transactionId string, params *ListSubtransactionsParams, reqEditors ...RequestEditorFn) (*ListSubtransactionsResponse, error) {
	rsp, err := c.ListSubtransactions(ctx, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubtransactionsResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// DeleteGoogleCalendarConnectionWithResponse request returning *DeleteGoogleCalendarConnectionResponse
func (c *ClientWithResponses) DeleteGoogleCalendarConnectionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteGoogleCalendarConnectionResponse, error) {
	rsp, err := c.DeleteGoogleCalendarConnection(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGoogleCalendarConnectionResponse(rsp)
}

// GetGoogleCalendarConnectionWithResponse request returning *GetGoogleCalendarConnectionResponse
func (c *ClientWithResponses) GetGoogleCalendarConnectionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGoogleCalendarConnectionResponse, error) {
	rsp, err := c.GetGoogleCalendarConnection(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoogleCalendarConnectionResponse(rsp)
}

// CreateGoogleCalendarConnectionWithBodyWithResponse request with arbitrary body returning *CreateGoogleCalendarConnectionResponse
func (c *ClientWithResponses) CreateGoogleCalendarConnectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGoogleCalendarConnectionResponse, error) {
	rsp, err := c.CreateGoogleCalendarConnectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGoogleCalendarConnectionResponse(rsp)
}

func (c *ClientWithResponses) CreateGoogleCalendarConnectionWithResponse(ctx context.Context, body CreateGoogleCalendarConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGoogleCalendarConnectionResponse, error) {
	rsp, err := c.CreateGoogleCalendarConnection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGoogleCalendarConnectionResponse(rsp)
}

// UserOAuthWithResponse request returning *UserOAuthResponse
func (c *ClientWithResponses) UserOAuthWithResponse(ctx context.Context, params *UserOAuthParams, reqEditors ...RequestEditorFn) (*UserOAuthResponse, error) {
	rsp, err := c.UserOAuth(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserOAuthResponse(rsp)
}

// ListUserSettlementAccountsWithResponse request returning *ListUserSettlementAccountsResponse
func (c *ClientWithResponses) ListUserSettlementAccountsWithResponse(ctx context.Context, params *ListUserSettlementAccountsParams, reqEditors ...RequestEditorFn) (*ListUserSettlementAccountsResponse, error) {
	rsp, err := c.ListUserSettlementAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserSettlementAccountsResponse(rsp)
}

// ListUserTerminalsWithResponse request returning *ListUserTerminalsResponse
func (c *ClientWithResponses) ListUserTerminalsWithResponse(ctx context.Context, params *ListUserTerminalsParams, reqEditors ...RequestEditorFn) (*ListUserTerminalsResponse, error) {
	rsp, err := c.ListUserTerminals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserTerminalsResponse(rsp)
}

// DeleteUserTerminalWithResponse request returning *DeleteUserTerminalResponse
func (c *ClientWithResponses) DeleteUserTerminalWithResponse(ctx context.Context, terminalId string, params *DeleteUserTerminalParams, reqEditors ...RequestEditorFn) (*DeleteUserTerminalResponse, error) {
	rsp, err := c.DeleteUserTerminal(ctx, terminalId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserTerminalResponse(rsp)
}

// GetUserTerminalWithResponse request returning *GetUserTerminalResponse
func (c *ClientWithResponses) GetUserTerminalWithResponse(ctx context.Context, terminalId string, params *GetUserTerminalParams, reqEditors ...RequestEditorFn) (*GetUserTerminalResponse, error) {
	rsp, err := c.GetUserTerminal(ctx, terminalId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTerminalResponse(rsp)
}

// ListUserTokensWithResponse request returning *ListUserTokensResponse
func (c *ClientWithResponses) ListUserTokensWithResponse(ctx context.Context, params *ListUserTokensParams, reqEditors ...RequestEditorFn) (*ListUserTokensResponse, error) {
	rsp, err := c.ListUserTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserTokensResponse(rsp)
}

// CreateUserTokenWithBodyWithResponse request with arbitrary body returning *CreateUserTokenResponse
func (c *ClientWithResponses) CreateUserTokenWithBodyWithResponse(ctx context.Context, params *CreateUserTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error) {
	rsp, err := c.CreateUserTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateUserTokenWithResponse(ctx context.Context, params *CreateUserTokenParams, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error) {
	rsp, err := c.CreateUserToken(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserTokenResponse(rsp)
}

// DeleteUserTokenWithResponse request returning *DeleteUserTokenResponse
func (c *ClientWithResponses) DeleteUserTokenWithResponse(ctx context.Context, tokenId string, params *DeleteUserTokenParams, reqEditors ...RequestEditorFn) (*DeleteUserTokenResponse, error) {
	rsp, err := c.DeleteUserToken(ctx, tokenId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserTokenResponse(rsp)
}

// GetUserTokenWithResponse request returning *GetUserTokenResponse
func (c *ClientWithResponses) GetUserTokenWithResponse(ctx context.Context, tokenId string, params *GetUserTokenParams, reqEditors ...RequestEditorFn) (*GetUserTokenResponse, error) {
	rsp, err := c.GetUserToken(ctx, tokenId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserTokenResponse(rsp)
}

// CreateVoucherTemplateWithBodyWithResponse request with arbitrary body returning *CreateVoucherTemplateResponse
func (c *ClientWithResponses) CreateVoucherTemplateWithBodyWithResponse(ctx context.Context, params *CreateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateResponse, error) {
	rsp, err := c.CreateVoucherTemplateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVoucherTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateVoucherTemplateWithResponse(ctx context.Context, params *CreateVoucherTemplateParams, body CreateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVoucherTemplateResponse, error) {
	rsp, err := c.CreateVoucherTemplate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVoucherTemplateResponse(rsp)
}

// DeleteVoucherTemplateWithResponse request returning *DeleteVoucherTemplateResponse
func (c *ClientWithResponses) DeleteVoucherTemplateWithResponse(ctx context.Context, voucherTemplateId string, params *DeleteVoucherTemplateParams, reqEditors ...RequestEditorFn) (*DeleteVoucherTemplateResponse, error) {
	rsp, err := c.DeleteVoucherTemplate(ctx, voucherTemplateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVoucherTemplateResponse(rsp)
}

// UpdateVoucherTemplateWithBodyWithResponse request with arbitrary body returning *UpdateVoucherTemplateResponse
func (c *ClientWithResponses) UpdateVoucherTemplateWithBodyWithResponse(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVoucherTemplateResponse, error) {
	rsp, err := c.UpdateVoucherTemplateWithBody(ctx, voucherTemplateId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVoucherTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateVoucherTemplateWithResponse(ctx context.Context, voucherTemplateId string, params *UpdateVoucherTemplateParams, body UpdateVoucherTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVoucherTemplateResponse, error) {
	rsp, err := c.UpdateVoucherTemplate(ctx, voucherTemplateId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVoucherTemplateResponse(rsp)
}

// DeleteVoucherWithResponse request returning *DeleteVoucherResponse
func (c *ClientWithResponses) DeleteVoucherWithResponse(ctx context.Context, voucherId string, params *DeleteVoucherParams, reqEditors ...RequestEditorFn) (*DeleteVoucherResponse, error) {
	rsp, err := c.DeleteVoucher(ctx, voucherId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVoucherResponse(rsp)
}

// GetVoucherWithResponse request returning *GetVoucherResponse
func (c *ClientWithResponses) GetVoucherWithResponse(ctx context.Context, voucherId string, params *GetVoucherParams, reqEditors ...RequestEditorFn) (*GetVoucherResponse, error) {
	rsp, err := c.GetVoucher(ctx, voucherId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoucherResponse(rsp)
}

// UpdateVoucherWithBodyWithResponse request with arbitrary body returning *UpdateVoucherResponse
func (c *ClientWithResponses) UpdateVoucherWithBodyWithResponse(ctx context.Context, voucherId string, params *UpdateVoucherParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVoucherResponse, error) {
	rsp, err := c.UpdateVoucherWithBody(ctx, voucherId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVoucherResponse(rsp)
}

func (c *ClientWithResponses) UpdateVoucherWithResponse(ctx context.Context, voucherId string, params *UpdateVoucherParams, body UpdateVoucherJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVoucherResponse, error) {
	rsp, err := c.UpdateVoucher(ctx, voucherId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVoucherResponse(rsp)
}

// CreateVoucherNotificationWithBodyWithResponse request with arbitrary body returning *CreateVoucherNotificationResponse
func (c *ClientWithResponses) CreateVoucherNotificationWithBodyWithResponse(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVoucherNotificationResponse, error) {
	rsp, err := c.CreateVoucherNotificationWithBody(ctx, voucherId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVoucherNotificationResponse(rsp)
}

func (c *ClientWithResponses) CreateVoucherNotificationWithResponse(ctx context.Context, voucherId string, params *CreateVoucherNotificationParams, body CreateVoucherNotificationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVoucherNotificationResponse, error) {
	rsp, err := c.CreateVoucherNotification(ctx, voucherId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVoucherNotificationResponse(rsp)
}

// CreateWaitlistEntryWithBodyWithResponse request with arbitrary body returning *CreateWaitlistEntryResponse
func (c *ClientWithResponses) CreateWaitlistEntryWithBodyWithResponse(ctx context.Context, params *CreateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWaitlistEntryResponse, error) {
	rsp, err := c.CreateWaitlistEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWaitlistEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateWaitlistEntryWithResponse(ctx context.Context, params *CreateWaitlistEntryParams, body CreateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWaitlistEntryResponse, error) {
	rsp, err := c.CreateWaitlistEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWaitlistEntryResponse(rsp)
}

// DeleteWaitlistEntryWithResponse request returning *DeleteWaitlistEntryResponse
func (c *ClientWithResponses) DeleteWaitlistEntryWithResponse(ctx context.Context, waitlistEntryId string, params *DeleteWaitlistEntryParams, reqEditors ...RequestEditorFn) (*DeleteWaitlistEntryResponse, error) {
	rsp, err := c.DeleteWaitlistEntry(ctx, waitlistEntryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWaitlistEntryResponse(rsp)
}

// GetWaitlistEntryWithResponse request returning *GetWaitlistEntryResponse
func (c *ClientWithResponses) GetWaitlistEntryWithResponse(ctx context.Context, waitlistEntryId string, params *GetWaitlistEntryParams, reqEditors ...RequestEditorFn) (*GetWaitlistEntryResponse, error) {
	rsp, err := c.GetWaitlistEntry(ctx, waitlistEntryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWaitlistEntryResponse(rsp)
}

// UpdateWaitlistEntryWithBodyWithResponse request with arbitrary body returning *UpdateWaitlistEntryResponse
func (c *ClientWithResponses) UpdateWaitlistEntryWithBodyWithResponse(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWaitlistEntryResponse, error) {
	rsp, err := c.UpdateWaitlistEntryWithBody(ctx, waitlistEntryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWaitlistEntryResponse(rsp)
}

func (c *ClientWithResponses) UpdateWaitlistEntryWithResponse(ctx context.Context, waitlistEntryId string, params *UpdateWaitlistEntryParams, body UpdateWaitlistEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWaitlistEntryResponse, error) {
	rsp, err := c.UpdateWaitlistEntry(ctx, waitlistEntryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWaitlistEntryResponse(rsp)
}

// GetWebhookInvocationWithResponse request returning *GetWebhookInvocationResponse
func (c *ClientWithResponses) GetWebhookInvocationWithResponse(ctx context.Context, webhookInvocationId string, params *GetWebhookInvocationParams, reqEditors ...RequestEditorFn) (*GetWebhookInvocationResponse, error) {
	rsp, err := c.GetWebhookInvocation(ctx, webhookInvocationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookInvocationResponse(rsp)
}

// UpdateWebhookInvocationWithBodyWithResponse request with arbitrary body returning *UpdateWebhookInvocationResponse
func (c *ClientWithResponses) UpdateWebhookInvocationWithBodyWithResponse(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookInvocationResponse, error) {
	rsp, err := c.UpdateWebhookInvocationWithBody(ctx, webhookInvocationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookInvocationResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookInvocationWithResponse(ctx context.Context, webhookInvocationId string, params *UpdateWebhookInvocationParams, body UpdateWebhookInvocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookInvocationResponse, error) {
	rsp, err := c.UpdateWebhookInvocation(ctx, webhookInvocationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookInvocationResponse(rsp)
}

// CreateWebhookWithBodyWithResponse request with arbitrary body returning *CreateWebhookResponse
func (c *ClientWithResponses) CreateWebhookWithBodyWithResponse(ctx context.Context, params *CreateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhookWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookWithResponse(ctx context.Context, params *CreateWebhookParams, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhook(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

// ListWebhookEventsWithResponse request returning *ListWebhookEventsResponse
func (c *ClientWithResponses) ListWebhookEventsWithResponse(ctx context.Context, params *ListWebhookEventsParams, reqEditors ...RequestEditorFn) (*ListWebhookEventsResponse, error) {
	rsp, err := c.ListWebhookEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWebhookEventsResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, webhookId string, params *DeleteWebhookParams, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, webhookId string, params *GetWebhookParams, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// UpdateWebhookWithBodyWithResponse request with arbitrary body returning *UpdateWebhookResponse
func (c *ClientWithResponses) UpdateWebhookWithBodyWithResponse(ctx context.Context, webhookId string, params *UpdateWebhookParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhookWithBody(ctx, webhookId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookWithResponse(ctx context.Context, webhookId string, params *UpdateWebhookParams, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhook(ctx, webhookId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

// ParseListCustomerActivitiesResponse parses an HTTP response from a ListCustomerActivitiesWithResponse call
func ParseListCustomerActivitiesResponse(rsp *http.Response) (*ListCustomerActivitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomerActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerActivities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventTypeActivitiesResponse parses an HTTP response from a ListEventTypeActivitiesWithResponse call
func ParseListEventTypeActivitiesResponse(rsp *http.Response) (*ListEventTypeActivitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventTypeActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventTypeActivities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventActivitiesResponse parses an HTTP response from a ListEventActivitiesWithResponse call
func ParseListEventActivitiesResponse(rsp *http.Response) (*ListEventActivitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventActivities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPaymentActivitiesResponse parses an HTTP response from a ListPaymentActivitiesWithResponse call
func ParseListPaymentActivitiesResponse(rsp *http.Response) (*ListPaymentActivitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentActivities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBlockedTimeResponse parses an HTTP response from a CreateBlockedTimeWithResponse call
func ParseCreateBlockedTimeResponse(rsp *http.Response) (*CreateBlockedTimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBlockedTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedTimeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteBlockedTimeResponse parses an HTTP response from a DeleteBlockedTimeWithResponse call
func ParseDeleteBlockedTimeResponse(rsp *http.Response) (*DeleteBlockedTimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBlockedTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBlockedTimeResponse parses an HTTP response from a GetBlockedTimeWithResponse call
func ParseGetBlockedTimeResponse(rsp *http.Response) (*GetBlockedTimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockedTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedTimeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateBlockedTimeResponse parses an HTTP response from a UpdateBlockedTimeWithResponse call
func ParseUpdateBlockedTimeResponse(rsp *http.Response) (*UpdateBlockedTimeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBlockedTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedTimeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetCompaniesResponse parses an HTTP response from a GetCompaniesWithResponse call
func ParseGetCompaniesResponse(rsp *http.Response) (*GetCompaniesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Companies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCompanyResponse parses an HTTP response from a CreateCompanyWithResponse call
func ParseCreateCompanyResponse(rsp *http.Response) (*CreateCompanyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Company
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyResponse parses an HTTP response from a GetCompanyWithResponse call
func ParseGetCompanyResponse(rsp *http.Response) (*GetCompanyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Company
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCompanyResponse parses an HTTP response from a UpdateCompanyWithResponse call
func ParseUpdateCompanyResponse(rsp *http.Response) (*UpdateCompanyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Company
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllCompanyActivitiesResponse parses an HTTP response from a ListAllCompanyActivitiesWithResponse call
func ParseListAllCompanyActivitiesResponse(rsp *http.Response) (*ListAllCompanyActivitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllCompanyActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnifiedActivities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Apps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDisableAppResponse parses an HTTP response from a DisableAppWithResponse call
func ParseDisableAppResponse(rsp *http.Response) (*DisableAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListBlockedTimesResponse parses an HTTP response from a ListBlockedTimesWithResponse call
func ParseListBlockedTimesResponse(rsp *http.Response) (*ListBlockedTimesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBlockedTimesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedTimesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListClaimsResponse parses an HTTP response from a ListClaimsWithResponse call
func ParseListClaimsResponse(rsp *http.Response) (*ListClaimsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClaimsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Claims
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomerGroupsResponse parses an HTTP response from a ListCustomerGroupsWithResponse call
func ParseListCustomerGroupsResponse(rsp *http.Response) (*ListCustomerGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomersResponse parses an HTTP response from a ListCustomersWithResponse call
func ParseListCustomersResponse(rsp *http.Response) (*ListCustomersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEmployeesResponse parses an HTTP response from a ListEmployeesWithResponse call
func ParseListEmployeesResponse(rsp *http.Response) (*ListEmployeesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEmployeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Employees
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEmployeeResponse parses an HTTP response from a DeleteEmployeeWithResponse call
func ParseDeleteEmployeeResponse(rsp *http.Response) (*DeleteEmployeeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEmployeeResponse parses an HTTP response from a GetEmployeeWithResponse call
func ParseGetEmployeeResponse(rsp *http.Response) (*GetEmployeeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Employee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEmployeeResponse parses an HTTP response from a UpdateEmployeeWithResponse call
func ParseUpdateEmployeeResponse(rsp *http.Response) (*UpdateEmployeeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Employee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventStatusesResponse parses an HTTP response from a ListEventStatusesWithResponse call
func ParseListEventStatusesResponse(rsp *http.Response) (*ListEventStatusesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventStatuses
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventTypeCategoriesResponse parses an HTTP response from a ListEventTypeCategoriesWithResponse call
func ParseListEventTypeCategoriesResponse(rsp *http.Response) (*ListEventTypeCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventTypeCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventTypeCategories
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventTypeCategoryGroupsResponse parses an HTTP response from a ListEventTypeCategoryGroupsWithResponse call
func ParseListEventTypeCategoryGroupsResponse(rsp *http.Response) (*ListEventTypeCategoryGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventTypeCategoryGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventTypeCategoryGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventTypeGroupsResponse parses an HTTP response from a ListEventTypeGroupsWithResponse call
func ParseListEventTypeGroupsResponse(rsp *http.Response) (*ListEventTypeGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventTypeGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventTypeGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventTypesResponse parses an HTTP response from a ListEventTypesWithResponse call
func ParseListEventTypesResponse(rsp *http.Response) (*ListEventTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventsResponse parses an HTTP response from a ListEventsWithResponse call
func ParseListEventsResponse(rsp *http.Response) (*ListEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Events
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckinWithPaymentResponse parses an HTTP response from a CheckinWithPaymentWithResponse call
func ParseCheckinWithPaymentResponse(rsp *http.Response) (*CheckinWithPaymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckinWithPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventCheckinResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHolidaysResponse parses an HTTP response from a ListHolidaysWithResponse call
func ParseListHolidaysResponse(rsp *http.Response) (*ListHolidaysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHolidaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Holidays
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListIssuersResponse parses an HTTP response from a ListIssuersWithResponse call
func ParseListIssuersResponse(rsp *http.Response) (*ListIssuersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIssuersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issuers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMemosResponse parses an HTTP response from a ListMemosWithResponse call
func ParseListMemosResponse(rsp *http.Response) (*ListMemosResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMemosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MemosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSalesMetricsResponse parses an HTTP response from a GetSalesMetricsWithResponse call
func ParseGetSalesMetricsResponse(rsp *http.Response) (*GetSalesMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSalesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SalesMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNotificationsResponse parses an HTTP response from a DeleteNotificationsWithResponse call
func ParseDeleteNotificationsResponse(rsp *http.Response) (*DeleteNotificationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNotificationsResponse parses an HTTP response from a ListNotificationsWithResponse call
func ParseListNotificationsResponse(rsp *http.Response) (*ListNotificationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notifications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOpeningHoursResponse parses an HTTP response from a ListOpeningHoursWithResponse call
func ParseListOpeningHoursResponse(rsp *http.Response) (*ListOpeningHoursResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOpeningHoursResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpeningHoursResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPaymentsResponse parses an HTTP response from a ListPaymentsWithResponse call
func ParseListPaymentsResponse(rsp *http.Response) (*ListPaymentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payments
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomPropertiesResponse parses an HTTP response from a ListCustomPropertiesWithResponse call
func ParseListCustomPropertiesResponse(rsp *http.Response) (*ListCustomPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceGroupsResponse parses an HTTP response from a ListResourceGroupsWithResponse call
func ParseListResourceGroupsResponse(rsp *http.Response) (*ListResourceGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListResourcesResponse parses an HTTP response from a ListResourcesWithResponse call
func ParseListResourcesResponse(rsp *http.Response) (*ListResourcesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resources
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRuleSetTemplatesResponse parses an HTTP response from a ListRuleSetTemplatesWithResponse call
func ParseListRuleSetTemplatesResponse(rsp *http.Response) (*ListRuleSetTemplatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleSetTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetTemplatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRuleSetsResponse parses an HTTP response from a ListRuleSetsWithResponse call
func ParseListRuleSetsResponse(rsp *http.Response) (*ListRuleSetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSalesResponse parses an HTTP response from a ListSalesWithResponse call
func ParseListSalesResponse(rsp *http.Response) (*ListSalesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSalesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sales
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSettlementsResponse parses an HTTP response from a ListSettlementsWithResponse call
func ParseListSettlementsResponse(rsp *http.Response) (*ListSettlementsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSettlementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Settlements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSMSMessagesResponse parses an HTTP response from a ListSMSMessagesWithResponse call
func ParseListSMSMessagesResponse(rsp *http.Response) (*ListSMSMessagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSMSMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SMSMessages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSpacesResponse parses an HTTP response from a ListSpacesWithResponse call
func ParseListSpacesResponse(rsp *http.Response) (*ListSpacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Spaces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PowerupSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionBillingInfoResponse parses an HTTP response from a GetSubscriptionBillingInfoWithResponse call
func ParseGetSubscriptionBillingInfoResponse(rsp *http.Response) (*GetSubscriptionBillingInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionBillingInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingCustomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateBillingInfoResponse parses an HTTP response from a UpdateBillingInfoWithResponse call
func ParseUpdateBillingInfoResponse(rsp *http.Response) (*UpdateBillingInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBillingInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingCustomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBillingInvoicesResponse parses an HTTP response from a ListBillingInvoicesWithResponse call
func ParseListBillingInvoicesResponse(rsp *http.Response) (*ListBillingInvoicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingInvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingInvoices
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePaymentIntentResponse parses an HTTP response from a CreatePaymentIntentWithResponse call
func ParseCreatePaymentIntentResponse(rsp *http.Response) (*CreatePaymentIntentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePaymentIntentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentIntent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTerminalsResponse parses an HTTP response from a ListTerminalsWithResponse call
func ParseListTerminalsResponse(rsp *http.Response) (*ListTerminalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTerminalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Terminals
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTimeSlotReservationsResponse parses an HTTP response from a ListTimeSlotReservationsWithResponse call
func ParseListTimeSlotReservationsResponse(rsp *http.Response) (*ListTimeSlotReservationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTimeSlotReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimeSlotReservations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTimeSlotsResponse parses an HTTP response from a ListTimeSlotsWithResponse call
func ParseListTimeSlotsResponse(rsp *http.Response) (*ListTimeSlotsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTimeSlotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimeSlots
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTransactionsResponse parses an HTTP response from a ListTransactionsWithResponse call
func ParseListTransactionsResponse(rsp *http.Response) (*ListTransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVATsResponse parses an HTTP response from a ListVATsWithResponse call
func ParseListVATsResponse(rsp *http.Response) (*ListVATsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVATsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VATs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVoucherTemplatesResponse parses an HTTP response from a ListVoucherTemplatesWithResponse call
func ParseListVoucherTemplatesResponse(rsp *http.Response) (*ListVoucherTemplatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVoucherTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoucherTemplatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVouchersResponse parses an HTTP response from a ListVouchersWithResponse call
func ParseListVouchersResponse(rsp *http.Response) (*ListVouchersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVouchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vouchers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWaitlistEntriesResponse parses an HTTP response from a ListWaitlistEntriesWithResponse call
func ParseListWaitlistEntriesResponse(rsp *http.Response) (*ListWaitlistEntriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWaitlistEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WaitlistEntriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWebhookInvocationsResponse parses an HTTP response from a ListWebhookInvocationsWithResponse call
func ParseListWebhookInvocationsResponse(rsp *http.Response) (*ListWebhookInvocationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhookInvocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookInvocations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWebhooksResponse parses an HTTP response from a ListWebhooksWithResponse call
func ParseListWebhooksResponse(rsp *http.Response) (*ListWebhooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhooks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomerGroupResponse parses an HTTP response from a CreateCustomerGroupWithResponse call
func ParseCreateCustomerGroupResponse(rsp *http.Response) (*CreateCustomerGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomerGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomerGroupResponse parses an HTTP response from a DeleteCustomerGroupWithResponse call
func ParseDeleteCustomerGroupResponse(rsp *http.Response) (*DeleteCustomerGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomerGroupResponse parses an HTTP response from a GetCustomerGroupWithResponse call
func ParseGetCustomerGroupResponse(rsp *http.Response) (*GetCustomerGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomerGroupResponse parses an HTTP response from a UpdateCustomerGroupWithResponse call
func ParseUpdateCustomerGroupResponse(rsp *http.Response) (*UpdateCustomerGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomerGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomerGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomerResponse parses an HTTP response from a CreateCustomerWithResponse call
func ParseCreateCustomerResponse(rsp *http.Response) (*CreateCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomerResponse parses an HTTP response from a DeleteCustomerWithResponse call
func ParseDeleteCustomerResponse(rsp *http.Response) (*DeleteCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomerResponse parses an HTTP response from a UpdateCustomerWithResponse call
func ParseUpdateCustomerResponse(rsp *http.Response) (*UpdateCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEmployeeResponse parses an HTTP response from a CreateEmployeeWithResponse call
func ParseCreateEmployeeResponse(rsp *http.Response) (*CreateEmployeeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEmployeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Employee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEnterpriseResponse parses an HTTP response from a GetEnterpriseWithResponse call
func ParseGetEnterpriseResponse(rsp *http.Response) (*GetEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Enterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEnterpriseResponse parses an HTTP response from a UpdateEnterpriseWithResponse call
func ParseUpdateEnterpriseResponse(rsp *http.Response) (*UpdateEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Enterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEnterpriseCompaniesResponse parses an HTTP response from a ListEnterpriseCompaniesWithResponse call
func ParseListEnterpriseCompaniesResponse(rsp *http.Response) (*ListEnterpriseCompaniesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnterpriseCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Companies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPaymentsLegacyResponse parses an HTTP response from a ListPaymentsLegacyWithResponse call
func ParseListPaymentsLegacyResponse(rsp *http.Response) (*ListPaymentsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payments
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEnterpriseSettlementAccountsResponse parses an HTTP response from a ListEnterpriseSettlementAccountsWithResponse call
func ParseListEnterpriseSettlementAccountsResponse(rsp *http.Response) (*ListEnterpriseSettlementAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEnterpriseSettlementAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettlementAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEnterpriseSettlementAccountResponse parses an HTTP response from a DeleteEnterpriseSettlementAccountWithResponse call
func ParseDeleteEnterpriseSettlementAccountResponse(rsp *http.Response) (*DeleteEnterpriseSettlementAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnterpriseSettlementAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEnterpriseSettlementAccountResponse parses an HTTP response from a GetEnterpriseSettlementAccountWithResponse call
func ParseGetEnterpriseSettlementAccountResponse(rsp *http.Response) (*GetEnterpriseSettlementAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnterpriseSettlementAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettlementAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSettlementsLegacyResponse parses an HTTP response from a ListSettlementsLegacyWithResponse call
func ParseListSettlementsLegacyResponse(rsp *http.Response) (*ListSettlementsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSettlementsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Settlements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVoucherTemplatesLegacyResponse parses an HTTP response from a ListVoucherTemplatesLegacyWithResponse call
func ParseListVoucherTemplatesLegacyResponse(rsp *http.Response) (*ListVoucherTemplatesLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVoucherTemplatesLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoucherTemplatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVoucherTemplateLegacyResponse parses an HTTP response from a CreateVoucherTemplateLegacyWithResponse call
func ParseCreateVoucherTemplateLegacyResponse(rsp *http.Response) (*CreateVoucherTemplateLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVoucherTemplateLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoucherTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVouchersLegacyResponse parses an HTTP response from a ListVouchersLegacyWithResponse call
func ParseListVouchersLegacyResponse(rsp *http.Response) (*ListVouchersLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVouchersLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vouchers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVoucherLegacyResponse parses an HTTP response from a GetVoucherLegacyWithResponse call
func ParseGetVoucherLegacyResponse(rsp *http.Response) (*GetVoucherLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoucherLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Voucher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVoucherLegacyResponse parses an HTTP response from a UpdateVoucherLegacyWithResponse call
func ParseUpdateVoucherLegacyResponse(rsp *http.Response) (*UpdateVoucherLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVoucherLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Voucher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEventStatusResponse parses an HTTP response from a CreateEventStatusWithResponse call
func ParseCreateEventStatusResponse(rsp *http.Response) (*CreateEventStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEventStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEventStatusResponse parses an HTTP response from a DeleteEventStatusWithResponse call
func ParseDeleteEventStatusResponse(rsp *http.Response) (*DeleteEventStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEventStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventStatusResponse parses an HTTP response from a GetEventStatusWithResponse call
func ParseGetEventStatusResponse(rsp *http.Response) (*GetEventStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEventStatusResponse parses an HTTP response from a UpdateEventStatusWithResponse call
func ParseUpdateEventStatusResponse(rsp *http.Response) (*UpdateEventStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEventStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEventTypeGroupResponse parses an HTTP response from a GetEventTypeGroupWithResponse call
func ParseGetEventTypeGroupResponse(rsp *http.Response) (*GetEventTypeGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventTypeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventTypeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEventTypeResponse parses an HTTP response from a CreateEventTypeWithResponse call
func ParseCreateEventTypeResponse(rsp *http.Response) (*CreateEventTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEventTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEventTypeResponse parses an HTTP response from a DeleteEventTypeWithResponse call
func ParseDeleteEventTypeResponse(rsp *http.Response) (*DeleteEventTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEventTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventTypeResponse parses an HTTP response from a GetEventTypeWithResponse call
func ParseGetEventTypeResponse(rsp *http.Response) (*GetEventTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEventTypeResponse parses an HTTP response from a UpdateEventTypeWithResponse call
func ParseUpdateEventTypeResponse(rsp *http.Response) (*UpdateEventTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEventTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEventResponse parses an HTTP response from a CreateEventWithResponse call
func ParseCreateEventResponse(rsp *http.Response) (*CreateEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteEventResponse parses an HTTP response from a DeleteEventWithResponse call
func ParseDeleteEventResponse(rsp *http.Response) (*DeleteEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventResponse parses an HTTP response from a GetEventWithResponse call
func ParseGetEventResponse(rsp *http.Response) (*GetEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEventResponse parses an HTTP response from a UpdateEventWithResponse call
func ParseUpdateEventResponse(rsp *http.Response) (*UpdateEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCheckoutForEventResponse parses an HTTP response from a CreateCheckoutForEventWithResponse call
func ParseCreateCheckoutForEventResponse(rsp *http.Response) (*CreateCheckoutForEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCheckoutForEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sale
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCompanyFiscalizationDataResponse parses an HTTP response from a DeleteCompanyFiscalizationDataWithResponse call
func ParseDeleteCompanyFiscalizationDataResponse(rsp *http.Response) (*DeleteCompanyFiscalizationDataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCompanyFiscalizationDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FiscalizationOnboarding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompanyFiscalizationDataResponse parses an HTTP response from a GetCompanyFiscalizationDataWithResponse call
func ParseGetCompanyFiscalizationDataResponse(rsp *http.Response) (*GetCompanyFiscalizationDataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompanyFiscalizationDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FiscalizationOnboarding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpsertCompanyFiscalizationDataResponse parses an HTTP response from a UpsertCompanyFiscalizationDataWithResponse call
func ParseUpsertCompanyFiscalizationDataResponse(rsp *http.Response) (*UpsertCompanyFiscalizationDataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertCompanyFiscalizationDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FiscalizationOnboarding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFiscalizationReportResponse parses an HTTP response from a GetFiscalizationReportWithResponse call
func ParseGetFiscalizationReportResponse(rsp *http.Response) (*GetFiscalizationReportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFiscalizationReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFiscalizeTransactionResponse parses an HTTP response from a FiscalizeTransactionWithResponse call
func ParseFiscalizeTransactionResponse(rsp *http.Response) (*FiscalizeTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FiscalizeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FiscalizationRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest FiscalizeTransactionError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSendFiscalizedTransactionPDFResponse parses an HTTP response from a SendFiscalizedTransactionPDFWithResponse call
func ParseSendFiscalizedTransactionPDFResponse(rsp *http.Response) (*SendFiscalizedTransactionPDFResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendFiscalizedTransactionPDFResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFiscalizedTransactionPDFResponse parses an HTTP response from a GetFiscalizedTransactionPDFWithResponse call
func ParseGetFiscalizedTransactionPDFResponse(rsp *http.Response) (*GetFiscalizedTransactionPDFResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFiscalizedTransactionPDFResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRefundFiscalizedTransactionResponse parses an HTTP response from a RefundFiscalizedTransactionWithResponse call
func ParseRefundFiscalizedTransactionResponse(rsp *http.Response) (*RefundFiscalizedTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefundFiscalizedTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAdyenCompanyOnboardingStatusResponse parses an HTTP response from a AdyenCompanyOnboardingStatusWithResponse call
func ParseAdyenCompanyOnboardingStatusResponse(rsp *http.Response) (*AdyenCompanyOnboardingStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdyenCompanyOnboardingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdyenOnboardingInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAdyenCompanyOnboardingResponse parses an HTTP response from a AdyenCompanyOnboardingWithResponse call
func ParseAdyenCompanyOnboardingResponse(rsp *http.Response) (*AdyenCompanyOnboardingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdyenCompanyOnboardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdyenOnboardingInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAdyenUserOnboardingStatusResponse parses an HTTP response from a AdyenUserOnboardingStatusWithResponse call
func ParseAdyenUserOnboardingStatusResponse(rsp *http.Response) (*AdyenUserOnboardingStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdyenUserOnboardingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdyenOnboardingInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAdyenUserOnboardingResponse parses an HTTP response from a AdyenUserOnboardingWithResponse call
func ParseAdyenUserOnboardingResponse(rsp *http.Response) (*AdyenUserOnboardingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdyenUserOnboardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdyenOnboardingInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSaltpayCompaniesResponse parses an HTTP response from a ListSaltpayCompaniesWithResponse call
func ParseListSaltpayCompaniesResponse(rsp *http.Response) (*ListSaltpayCompaniesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSaltpayCompaniesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SaltpayCompanies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLinkSaltpayBankAccountResponse parses an HTTP response from a LinkSaltpayBankAccountWithResponse call
func ParseLinkSaltpayBankAccountResponse(rsp *http.Response) (*LinkSaltpayBankAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LinkSaltpayBankAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettlementAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSaltpayStoresAtCompanyResponse parses an HTTP response from a ListSaltpayStoresAtCompanyWithResponse call
func ParseListSaltpayStoresAtCompanyResponse(rsp *http.Response) (*ListSaltpayStoresAtCompanyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSaltpayStoresAtCompanyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SaltpayStores
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSaltpayStoresResponse parses an HTTP response from a ListSaltpayStoresWithResponse call
func ParseListSaltpayStoresResponse(rsp *http.Response) (*ListSaltpayStoresResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSaltpayStoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SaltpayStores
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSaltpayTerminalsResponse parses an HTTP response from a ListSaltpayTerminalsWithResponse call
func ParseListSaltpayTerminalsResponse(rsp *http.Response) (*ListSaltpayTerminalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSaltpayTerminalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SaltpayTerminals
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSaltpayTerminalResponse parses an HTTP response from a UpdateSaltpayTerminalWithResponse call
func ParseUpdateSaltpayTerminalResponse(rsp *http.Response) (*UpdateSaltpayTerminalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSaltpayTerminalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SaltpayTerminal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateLineItemResponse parses an HTTP response from a CreateLineItemWithResponse call
func ParseCreateLineItemResponse(rsp *http.Response) (*CreateLineItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLineItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LineItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteLineItemResponse parses an HTTP response from a DeleteLineItemWithResponse call
func ParseDeleteLineItemResponse(rsp *http.Response) (*DeleteLineItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLineItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLineItemResponse parses an HTTP response from a GetLineItemWithResponse call
func ParseGetLineItemResponse(rsp *http.Response) (*GetLineItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLineItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LineItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateLineItemResponse parses an HTTP response from a UpdateLineItemWithResponse call
func ParseUpdateLineItemResponse(rsp *http.Response) (*UpdateLineItemResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLineItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LineItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateMemoResponse parses an HTTP response from a CreateMemoWithResponse call
func ParseCreateMemoResponse(rsp *http.Response) (*CreateMemoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMemoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MemoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMemoResponse parses an HTTP response from a DeleteMemoWithResponse call
func ParseDeleteMemoResponse(rsp *http.Response) (*DeleteMemoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMemoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMemoResponse parses an HTTP response from a GetMemoWithResponse call
func ParseGetMemoResponse(rsp *http.Response) (*GetMemoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMemoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MemoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateMemoResponse parses an HTTP response from a UpdateMemoWithResponse call
func ParseUpdateMemoResponse(rsp *http.Response) (*UpdateMemoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMemoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MemoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateNotificationResponse parses an HTTP response from a CreateNotificationWithResponse call
func ParseCreateNotificationResponse(rsp *http.Response) (*CreateNotificationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteNotificationResponse parses an HTTP response from a DeleteNotificationWithResponse call
func ParseDeleteNotificationResponse(rsp *http.Response) (*DeleteNotificationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetNotificationResponse parses an HTTP response from a GetNotificationWithResponse call
func ParseGetNotificationResponse(rsp *http.Response) (*GetNotificationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOAuthApplicationsResponse parses an HTTP response from a ListOAuthApplicationsWithResponse call
func ParseListOAuthApplicationsResponse(rsp *http.Response) (*ListOAuthApplicationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOAuthApplicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Applications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOAuthApplicationResponse parses an HTTP response from a CreateOAuthApplicationWithResponse call
func ParseCreateOAuthApplicationResponse(rsp *http.Response) (*CreateOAuthApplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOAuthApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOAuthApplicationResponse parses an HTTP response from a DeleteOAuthApplicationWithResponse call
func ParseDeleteOAuthApplicationResponse(rsp *http.Response) (*DeleteOAuthApplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOAuthApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthApplicationResponse parses an HTTP response from a GetOAuthApplicationWithResponse call
func ParseGetOAuthApplicationResponse(rsp *http.Response) (*GetOAuthApplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOAuthApplicationResponse parses an HTTP response from a UpdateOAuthApplicationWithResponse call
func ParseUpdateOAuthApplicationResponse(rsp *http.Response) (*UpdateOAuthApplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOAuthApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartOAuthFlowResponse parses an HTTP response from a StartOAuthFlowWithResponse call
func ParseStartOAuthFlowResponse(rsp *http.Response) (*StartOAuthFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartOAuthFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateOAuthConsentResponse parses an HTTP response from a CreateOAuthConsentWithResponse call
func ParseCreateOAuthConsentResponse(rsp *http.Response) (*CreateOAuthConsentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOAuthConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthConsentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthPublicKeyResponse parses an HTTP response from a GetOAuthPublicKeyWithResponse call
func ParseGetOAuthPublicKeyResponse(rsp *http.Response) (*GetOAuthPublicKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOAuthScopesResponse parses an HTTP response from a ListOAuthScopesWithResponse call
func ParseListOAuthScopesResponse(rsp *http.Response) (*ListOAuthScopesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOAuthScopesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthScopes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthTokenResponse parses an HTTP response from a GetOAuthTokenWithResponse call
func ParseGetOAuthTokenResponse(rsp *http.Response) (*GetOAuthTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OAuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPaymentMethodsResponse parses an HTTP response from a ListPaymentMethodsWithResponse call
func ParseListPaymentMethodsResponse(rsp *http.Response) (*ListPaymentMethodsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPaymentMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentMethods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPaymentResponse parses an HTTP response from a GetPaymentWithResponse call
func ParseGetPaymentResponse(rsp *http.Response) (*GetPaymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePaymentResponse parses an HTTP response from a UpdatePaymentWithResponse call
func ParseUpdatePaymentResponse(rsp *http.Response) (*UpdatePaymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadPaymentReceiptResponse parses an HTTP response from a DownloadPaymentReceiptWithResponse call
func ParseDownloadPaymentReceiptResponse(rsp *http.Response) (*DownloadPaymentReceiptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadPaymentReceiptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSendPaymentReceiptResponse parses an HTTP response from a SendPaymentReceiptWithResponse call
func ParseSendPaymentReceiptResponse(rsp *http.Response) (*SendPaymentReceiptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendPaymentReceiptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListPricingResponse parses an HTTP response from a ListPricingWithResponse call
func ParseListPricingResponse(rsp *http.Response) (*ListPricingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPricingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllPricing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCalculatePricingResponse parses an HTTP response from a CalculatePricingWithResponse call
func ParseCalculatePricingResponse(rsp *http.Response) (*CalculatePricingResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculatePricingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PricingCalculation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPricingByCountryCodeResponse parses an HTTP response from a GetPricingByCountryCodeWithResponse call
func ParseGetPricingByCountryCodeResponse(rsp *http.Response) (*GetPricingByCountryCodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricingByCountryCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pricing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProductGroupsResponse parses an HTTP response from a ListProductGroupsWithResponse call
func ParseListProductGroupsResponse(rsp *http.Response) (*ListProductGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProductGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProductGroupResponse parses an HTTP response from a CreateProductGroupWithResponse call
func ParseCreateProductGroupResponse(rsp *http.Response) (*CreateProductGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProductGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupsAndProductsResponse parses an HTTP response from a ListGroupsAndProductsWithResponse call
func ParseListGroupsAndProductsResponse(rsp *http.Response) (*ListGroupsAndProductsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsAndProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroupsExpanded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProductGroupsOrderResponse parses an HTTP response from a UpdateProductGroupsOrderWithResponse call
func ParseUpdateProductGroupsOrderResponse(rsp *http.Response) (*UpdateProductGroupsOrderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductGroupsOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroupsOrder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductGroupResponse parses an HTTP response from a DeleteProductGroupWithResponse call
func ParseDeleteProductGroupResponse(rsp *http.Response) (*DeleteProductGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProductGroupResponse parses an HTTP response from a GetProductGroupWithResponse call
func ParseGetProductGroupResponse(rsp *http.Response) (*GetProductGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProductGroupResponse parses an HTTP response from a UpdateProductGroupWithResponse call
func ParseUpdateProductGroupResponse(rsp *http.Response) (*UpdateProductGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProductsResponse parses an HTTP response from a ListProductsWithResponse call
func ParseListProductsResponse(rsp *http.Response) (*ListProductsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Products
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProductResponse parses an HTTP response from a CreateProductWithResponse call
func ParseCreateProductResponse(rsp *http.Response) (*CreateProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProductResponse parses an HTTP response from a DeleteProductWithResponse call
func ParseDeleteProductResponse(rsp *http.Response) (*DeleteProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetProductResponse parses an HTTP response from a GetProductWithResponse call
func ParseGetProductResponse(rsp *http.Response) (*GetProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProductResponse parses an HTTP response from a UpdateProductWithResponse call
func ParseUpdateProductResponse(rsp *http.Response) (*UpdateProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomPropertyResponse parses an HTTP response from a CreateCustomPropertyWithResponse call
func ParseCreateCustomPropertyResponse(rsp *http.Response) (*CreateCustomPropertyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomPropertyResponse parses an HTTP response from a DeleteCustomPropertyWithResponse call
func ParseDeleteCustomPropertyResponse(rsp *http.Response) (*DeleteCustomPropertyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateCustomPropertyResponse parses an HTTP response from a UpdateCustomPropertyWithResponse call
func ParseUpdateCustomPropertyResponse(rsp *http.Response) (*UpdateCustomPropertyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomProperty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResourceGroupResponse parses an HTTP response from a CreateResourceGroupWithResponse call
func ParseCreateResourceGroupResponse(rsp *http.Response) (*CreateResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteResourceGroupResponse parses an HTTP response from a DeleteResourceGroupWithResponse call
func ParseDeleteResourceGroupResponse(rsp *http.Response) (*DeleteResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetResourceGroupResponse parses an HTTP response from a GetResourceGroupWithResponse call
func ParseGetResourceGroupResponse(rsp *http.Response) (*GetResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateResourceGroupResponse parses an HTTP response from a UpdateResourceGroupWithResponse call
func ParseUpdateResourceGroupResponse(rsp *http.Response) (*UpdateResourceGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateResourceResponse parses an HTTP response from a CreateResourceWithResponse call
func ParseCreateResourceResponse(rsp *http.Response) (*CreateResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateResourceResponse parses an HTTP response from a UpdateResourceWithResponse call
func ParseUpdateResourceResponse(rsp *http.Response) (*UpdateResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRuleSetTemplateResponse parses an HTTP response from a CreateRuleSetTemplateWithResponse call
func ParseCreateRuleSetTemplateResponse(rsp *http.Response) (*CreateRuleSetTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleSetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRuleSetTemplateResponse parses an HTTP response from a DeleteRuleSetTemplateWithResponse call
func ParseDeleteRuleSetTemplateResponse(rsp *http.Response) (*DeleteRuleSetTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleSetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleSetTemplateResponse parses an HTTP response from a GetRuleSetTemplateWithResponse call
func ParseGetRuleSetTemplateResponse(rsp *http.Response) (*GetRuleSetTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleSetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleSetTemplateResponse parses an HTTP response from a UpdateRuleSetTemplateWithResponse call
func ParseUpdateRuleSetTemplateResponse(rsp *http.Response) (*UpdateRuleSetTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleSetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRuleSetResponse parses an HTTP response from a CreateRuleSetWithResponse call
func ParseCreateRuleSetResponse(rsp *http.Response) (*CreateRuleSetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRuleSetResponse parses an HTTP response from a DeleteRuleSetWithResponse call
func ParseDeleteRuleSetResponse(rsp *http.Response) (*DeleteRuleSetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleSetResponse parses an HTTP response from a GetRuleSetWithResponse call
func ParseGetRuleSetResponse(rsp *http.Response) (*GetRuleSetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleSetResponse parses an HTTP response from a UpdateRuleSetWithResponse call
func ParseUpdateRuleSetResponse(rsp *http.Response) (*UpdateRuleSetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSaleResponse parses an HTTP response from a CreateSaleWithResponse call
func ParseCreateSaleResponse(rsp *http.Response) (*CreateSaleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSaleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sale
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSaleResponse parses an HTTP response from a DeleteSaleWithResponse call
func ParseDeleteSaleResponse(rsp *http.Response) (*DeleteSaleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSaleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSaleResponse parses an HTTP response from a GetSaleWithResponse call
func ParseGetSaleResponse(rsp *http.Response) (*GetSaleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSaleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sale
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSaleResponse parses an HTTP response from a UpdateSaleWithResponse call
func ParseUpdateSaleResponse(rsp *http.Response) (*UpdateSaleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSaleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sale
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefundMarketplaceSaleResponse parses an HTTP response from a RefundMarketplaceSaleWithResponse call
func ParseRefundMarketplaceSaleResponse(rsp *http.Response) (*RefundMarketplaceSaleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefundMarketplaceSaleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RefundMarketplaceSaleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSendTransactionReceiptResponse parses an HTTP response from a SendTransactionReceiptWithResponse call
func ParseSendTransactionReceiptResponse(rsp *http.Response) (*SendTransactionReceiptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendTransactionReceiptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeprecatedListSubtransactionsResponse parses an HTTP response from a DeprecatedListSubtransactionsWithResponse call
func ParseDeprecatedListSubtransactionsResponse(rsp *http.Response) (*DeprecatedListSubtransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeprecatedListSubtransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subtransactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeprecatedGetSubtransactionResponse parses an HTTP response from a DeprecatedGetSubtransactionWithResponse call
func ParseDeprecatedGetSubtransactionResponse(rsp *http.Response) (*DeprecatedGetSubtransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeprecatedGetSubtransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subtransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSpaceResponse parses an HTTP response from a CreateSpaceWithResponse call
func ParseCreateSpaceResponse(rsp *http.Response) (*CreateSpaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Space
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSpaceResponse parses an HTTP response from a DeleteSpaceWithResponse call
func ParseDeleteSpaceResponse(rsp *http.Response) (*DeleteSpaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSpaceResponse parses an HTTP response from a GetSpaceWithResponse call
func ParseGetSpaceResponse(rsp *http.Response) (*GetSpaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Space
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSpaceResponse parses an HTTP response from a UpdateSpaceWithResponse call
func ParseUpdateSpaceResponse(rsp *http.Response) (*UpdateSpaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Space
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStreamBlockedTimesResponse parses an HTTP response from a StreamBlockedTimesWithResponse call
func ParseStreamBlockedTimesResponse(rsp *http.Response) (*StreamBlockedTimesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamBlockedTimesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamEmployeesResponse parses an HTTP response from a StreamEmployeesWithResponse call
func ParseStreamEmployeesResponse(rsp *http.Response) (*StreamEmployeesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamEmployeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamEventTypeGroupsResponse parses an HTTP response from a StreamEventTypeGroupsWithResponse call
func ParseStreamEventTypeGroupsResponse(rsp *http.Response) (*StreamEventTypeGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamEventTypeGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamEventTypesResponse parses an HTTP response from a StreamEventTypesWithResponse call
func ParseStreamEventTypesResponse(rsp *http.Response) (*StreamEventTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamEventTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamEventsResponse parses an HTTP response from a StreamEventsWithResponse call
func ParseStreamEventsResponse(rsp *http.Response) (*StreamEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamSalesMetricsResponse parses an HTTP response from a StreamSalesMetricsWithResponse call
func ParseStreamSalesMetricsResponse(rsp *http.Response) (*StreamSalesMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamSalesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamNotificationsResponse parses an HTTP response from a StreamNotificationsWithResponse call
func ParseStreamNotificationsResponse(rsp *http.Response) (*StreamNotificationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamProductGroupsResponse parses an HTTP response from a StreamProductGroupsWithResponse call
func ParseStreamProductGroupsResponse(rsp *http.Response) (*StreamProductGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamProductGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamProductsResponse parses an HTTP response from a StreamProductsWithResponse call
func ParseStreamProductsResponse(rsp *http.Response) (*StreamProductsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamResourcesResponse parses an HTTP response from a StreamResourcesWithResponse call
func ParseStreamResourcesResponse(rsp *http.Response) (*StreamResourcesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamSpacesResponse parses an HTTP response from a StreamSpacesWithResponse call
func ParseStreamSpacesResponse(rsp *http.Response) (*StreamSpacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamSpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStreamTimeSlotReservationsResponse parses an HTTP response from a StreamTimeSlotReservationsWithResponse call
func ParseStreamTimeSlotReservationsResponse(rsp *http.Response) (*StreamTimeSlotReservationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamTimeSlotReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBillingInvoiceResponse parses an HTTP response from a GetBillingInvoiceWithResponse call
func ParseGetBillingInvoiceResponse(rsp *http.Response) (*GetBillingInvoiceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PowerupSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionResponse parses an HTTP response from a GetSubscriptionWithResponse call
func ParseGetSubscriptionResponse(rsp *http.Response) (*GetSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PowerupSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSubtransactionResponse parses an HTTP response from a CreateSubtransactionWithResponse call
func ParseCreateSubtransactionResponse(rsp *http.Response) (*CreateSubtransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubtransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subtransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSubtransactionResponse parses an HTTP response from a DeleteSubtransactionWithResponse call
func ParseDeleteSubtransactionResponse(rsp *http.Response) (*DeleteSubtransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubtransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSubtransactionResponse parses an HTTP response from a GetSubtransactionWithResponse call
func ParseGetSubtransactionResponse(rsp *http.Response) (*GetSubtransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubtransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subtransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTerminalResponse parses an HTTP response from a DeleteTerminalWithResponse call
func ParseDeleteTerminalResponse(rsp *http.Response) (*DeleteTerminalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTerminalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTerminalResponse parses an HTTP response from a GetTerminalWithResponse call
func ParseGetTerminalResponse(rsp *http.Response) (*GetTerminalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTerminalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Terminal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTerminalResponse parses an HTTP response from a UpdateTerminalWithResponse call
func ParseUpdateTerminalResponse(rsp *http.Response) (*UpdateTerminalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTerminalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Terminal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOAuthConsentResponse parses an HTTP response from a GetOAuthConsentWithResponse call
func ParseGetOAuthConsentResponse(rsp *http.Response) (*GetOAuthConsentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOAuthLoginResponse parses an HTTP response from a GetOAuthLoginWithResponse call
func ParseGetOAuthLoginResponse(rsp *http.Response) (*GetOAuthLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOAuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostOAuthLoginResponse parses an HTTP response from a PostOAuthLoginWithResponse call
func ParsePostOAuthLoginResponse(rsp *http.Response) (*PostOAuthLoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOAuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTimeSlotReservationResponse parses an HTTP response from a GetTimeSlotReservationWithResponse call
func ParseGetTimeSlotReservationResponse(rsp *http.Response) (*GetTimeSlotReservationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimeSlotReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TimeSlotReservation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckinToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTransactionResponse parses an HTTP response from a CreateTransactionWithResponse call
func ParseCreateTransactionResponse(rsp *http.Response) (*CreateTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTransactionResponse parses an HTTP response from a DeleteTransactionWithResponse call
func ParseDeleteTransactionResponse(rsp *http.Response) (*DeleteTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTransactionResponse parses an HTTP response from a UpdateTransactionWithResponse call
func ParseUpdateTransactionResponse(rsp *http.Response) (*UpdateTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLineItemsResponse parses an HTTP response from a ListLineItemsWithResponse call
func ParseListLineItemsResponse(rsp *http.Response) (*ListLineItemsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLineItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LineItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSubtransactionsResponse parses an HTTP response from a ListSubtransactionsWithResponse call
func ParseListSubtransactionsResponse(rsp *http.Response) (*ListSubtransactionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubtransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subtransactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGoogleCalendarConnectionResponse parses an HTTP response from a DeleteGoogleCalendarConnectionWithResponse call
func ParseDeleteGoogleCalendarConnectionResponse(rsp *http.Response) (*DeleteGoogleCalendarConnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGoogleCalendarConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGoogleCalendarConnectionResponse parses an HTTP response from a GetGoogleCalendarConnectionWithResponse call
func ParseGetGoogleCalendarConnectionResponse(rsp *http.Response) (*GetGoogleCalendarConnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoogleCalendarConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GoogleCalendarConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateGoogleCalendarConnectionResponse parses an HTTP response from a CreateGoogleCalendarConnectionWithResponse call
func ParseCreateGoogleCalendarConnectionResponse(rsp *http.Response) (*CreateGoogleCalendarConnectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGoogleCalendarConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GoogleCalendarConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserOAuthResponse parses an HTTP response from a UserOAuthWithResponse call
func ParseUserOAuthResponse(rsp *http.Response) (*UserOAuthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserOAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUserSettlementAccountsResponse parses an HTTP response from a ListUserSettlementAccountsWithResponse call
func ParseListUserSettlementAccountsResponse(rsp *http.Response) (*ListUserSettlementAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserSettlementAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SettlementAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUserTerminalsResponse parses an HTTP response from a ListUserTerminalsWithResponse call
func ParseListUserTerminalsResponse(rsp *http.Response) (*ListUserTerminalsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserTerminalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Terminals
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserTerminalResponse parses an HTTP response from a DeleteUserTerminalWithResponse call
func ParseDeleteUserTerminalResponse(rsp *http.Response) (*DeleteUserTerminalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserTerminalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserTerminalResponse parses an HTTP response from a GetUserTerminalWithResponse call
func ParseGetUserTerminalResponse(rsp *http.Response) (*GetUserTerminalResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTerminalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Terminal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUserTokensResponse parses an HTTP response from a ListUserTokensWithResponse call
func ParseListUserTokensResponse(rsp *http.Response) (*ListUserTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tokens
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserTokenResponse parses an HTTP response from a CreateUserTokenWithResponse call
func ParseCreateUserTokenResponse(rsp *http.Response) (*CreateUserTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserTokenResponse parses an HTTP response from a DeleteUserTokenWithResponse call
func ParseDeleteUserTokenResponse(rsp *http.Response) (*DeleteUserTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserTokenResponse parses an HTTP response from a GetUserTokenWithResponse call
func ParseGetUserTokenResponse(rsp *http.Response) (*GetUserTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVoucherTemplateResponse parses an HTTP response from a CreateVoucherTemplateWithResponse call
func ParseCreateVoucherTemplateResponse(rsp *http.Response) (*CreateVoucherTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVoucherTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoucherTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVoucherTemplateResponse parses an HTTP response from a DeleteVoucherTemplateWithResponse call
func ParseDeleteVoucherTemplateResponse(rsp *http.Response) (*DeleteVoucherTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVoucherTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateVoucherTemplateResponse parses an HTTP response from a UpdateVoucherTemplateWithResponse call
func ParseUpdateVoucherTemplateResponse(rsp *http.Response) (*UpdateVoucherTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVoucherTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoucherTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVoucherResponse parses an HTTP response from a DeleteVoucherWithResponse call
func ParseDeleteVoucherResponse(rsp *http.Response) (*DeleteVoucherResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVoucherResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVoucherResponse parses an HTTP response from a GetVoucherWithResponse call
func ParseGetVoucherResponse(rsp *http.Response) (*GetVoucherResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoucherResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Voucher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVoucherResponse parses an HTTP response from a UpdateVoucherWithResponse call
func ParseUpdateVoucherResponse(rsp *http.Response) (*UpdateVoucherResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVoucherResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Voucher
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVoucherNotificationResponse parses an HTTP response from a CreateVoucherNotificationWithResponse call
func ParseCreateVoucherNotificationResponse(rsp *http.Response) (*CreateVoucherNotificationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVoucherNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateWaitlistEntryResponse parses an HTTP response from a CreateWaitlistEntryWithResponse call
func ParseCreateWaitlistEntryResponse(rsp *http.Response) (*CreateWaitlistEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWaitlistEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WaitlistEntryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWaitlistEntryResponse parses an HTTP response from a DeleteWaitlistEntryWithResponse call
func ParseDeleteWaitlistEntryResponse(rsp *http.Response) (*DeleteWaitlistEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWaitlistEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWaitlistEntryResponse parses an HTTP response from a GetWaitlistEntryWithResponse call
func ParseGetWaitlistEntryResponse(rsp *http.Response) (*GetWaitlistEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWaitlistEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WaitlistEntryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWaitlistEntryResponse parses an HTTP response from a UpdateWaitlistEntryWithResponse call
func ParseUpdateWaitlistEntryResponse(rsp *http.Response) (*UpdateWaitlistEntryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWaitlistEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WaitlistEntryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWebhookInvocationResponse parses an HTTP response from a GetWebhookInvocationWithResponse call
func ParseGetWebhookInvocationResponse(rsp *http.Response) (*GetWebhookInvocationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookInvocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookInvocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookInvocationResponse parses an HTTP response from a UpdateWebhookInvocationWithResponse call
func ParseUpdateWebhookInvocationResponse(rsp *http.Response) (*UpdateWebhookInvocationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookInvocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookInvocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWebhookResponse parses an HTTP response from a CreateWebhookWithResponse call
func ParseCreateWebhookResponse(rsp *http.Response) (*CreateWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWebhookEventsResponse parses an HTTP response from a ListWebhookEventsWithResponse call
func ParseListWebhookEventsResponse(rsp *http.Response) (*ListWebhookEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWebhookEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookEvents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookResponse parses an HTTP response from a UpdateWebhookWithResponse call
func ParseUpdateWebhookResponse(rsp *http.Response) (*UpdateWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
